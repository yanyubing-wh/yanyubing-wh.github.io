<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="鄢玉兵的博客" type="application/atom+xml" />






<meta name="description" content="1：算法1：二分查找：非递归1：二分查找简介 12345678二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n&#x2F;2]与x做比较，如果x=a[n&#x2F;2],则找到x,算法中止；如果x&amp;lt;a[n&#x2F;2],则只要在数组a的左半部分继续搜索x,如果x&amp;gt;a[n&#x2F;2],则只要在数组a的右半部搜索x.时间复杂度无非就是while循环的次数！总共有n个元素，渐渐跟下去就是n,n&#x2F;2,n&#x2F;4,...">
<meta property="og:type" content="article">
<meta property="og:title" content="java数据结构和算法（10）10种算法">
<meta property="og:url" content="https:&#x2F;&#x2F;yanyubing.xyz&#x2F;2018&#x2F;08&#x2F;10&#x2F;java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%8910%E7%A7%8D%E7%AE%97%E6%B3%95&#x2F;index.html">
<meta property="og:site_name" content="鄢玉兵的博客">
<meta property="og:description" content="1：算法1：二分查找：非递归1：二分查找简介 12345678二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n&#x2F;2]与x做比较，如果x=a[n&#x2F;2],则找到x,算法中止；如果x&amp;lt;a[n&#x2F;2],则只要在数组a的左半部分继续搜索x,如果x&amp;gt;a[n&#x2F;2],则只要在数组a的右半部搜索x.时间复杂度无非就是while循环的次数！总共有n个元素，渐渐跟下去就是n,n&#x2F;2,n&#x2F;4,...">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-12-06T02:57:40.943Z">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yanyubing.xyz/2018/08/10/java数据结构和算法（10）10种算法/"/>





  <title>java数据结构和算法（10）10种算法 | 鄢玉兵的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<a href="https://yanyubing.xyz"><img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_red_aa0000.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">鄢玉兵的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yanyubing.xyz/2018/08/10/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%8910%E7%A7%8D%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="鄢玉兵">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鄢玉兵的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java数据结构和算法（10）10种算法</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-10T21:46:12+08:00">
                2018-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1：算法"><a href="#1：算法" class="headerlink" title="1：算法"></a>1：算法</h1><h3 id="1：二分查找：非递归"><a href="#1：二分查找：非递归" class="headerlink" title="1：二分查找：非递归"></a>1：二分查找：非递归</h3><p>1：二分查找简介</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x&lt;a[n/2],则只要在数组a的左半部分继续搜索x,如果x&gt;a[n/2],则只要在数组a的右半部搜索x.</span><br><span class="line">时间复杂度无非就是while循环的次数！</span><br><span class="line">总共有n个元素，</span><br><span class="line">渐渐跟下去就是n,n/2,n/4,....n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数</span><br><span class="line">由于你n/2^k取整后&gt;=1</span><br><span class="line">即令n/2^k=1</span><br><span class="line">可得k=log2n,（是以2为底，n的对数）</span><br><span class="line">所以时间复杂度可以表示O(h)=O(log2n)</span><br></pre></td></tr></table></figure>

<p>2：代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.it.binarysearchnorecursion;</span><br><span class="line"></span><br><span class="line">//二分查找，非递归</span><br><span class="line">public class BinarySearchNoRecur &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;1, 2, 5, 8, 12, 34, 56, 234&#125;;</span><br><span class="line">        int index=binarySearch(arr, 1);</span><br><span class="line">        System.out.println(&quot;index=&quot;+index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //二分查找非递归实现,arr升序</span><br><span class="line">    public static int binarySearch(int[] arr, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = arr.length - 1;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            if (arr[mid] == target) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (arr[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2：分治算法-汉诺塔"><a href="#2：分治算法-汉诺塔" class="headerlink" title="2：分治算法-汉诺塔"></a>2：分治算法-汉诺塔</h3><p>1：汉诺塔介绍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</span><br></pre></td></tr></table></figure>

<p>2：实现思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：A柱，B柱,C柱，n为盘子的个数</span><br><span class="line">2：当n=1时，A-C</span><br><span class="line">2：当n=2时，A-B，A-C,B-C</span><br><span class="line">3：当n=3时，A→C,A→B,C→B,A→C,B→A,B→C,A→C</span><br><span class="line">n个盘子的时候，移动次数s=2^n – 1</span><br><span class="line"></span><br><span class="line">规律当N个盘子的时候，可以当成两个盘子，把上面n-1当一个整体，把n-1个盘子先移动到B（A-B），然后再把最底下盘子移动到C，即A-C，最终把n-1个盘子移动到C，即B-C</span><br></pre></td></tr></table></figure>

<p>3：代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.it.dac;</span><br><span class="line"></span><br><span class="line">//汉诺塔</span><br><span class="line">public class HanoiTower &#123;</span><br><span class="line">    private static int sum = 0;//记录移动的次数</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int num=10;</span><br><span class="line">        hanoiTower(num, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;);</span><br><span class="line">        System.out.println(&quot;当&quot; + num + &quot;个盘的时候，一起移动了&quot; + sum + &quot;次&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param num 汉诺塔盘的个数</span><br><span class="line">     * @param A   柱A</span><br><span class="line">     * @param B   柱B</span><br><span class="line">     * @param C   柱C</span><br><span class="line">     */</span><br><span class="line">    public static void hanoiTower(int num, char A, char B, char C) &#123;</span><br><span class="line">        //如果只有一个盘</span><br><span class="line">        if (num == 1) &#123;</span><br><span class="line">            System.out.println(&quot;第&quot; + num + &quot;个盘&quot; + A + &quot;-&quot; + C);</span><br><span class="line">            sum++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //当n&gt;2时，先把最上面的盘（所有盘）和最下面的一个盘</span><br><span class="line">            //先把最上面的所有盘，A-B</span><br><span class="line">            hanoiTower(num - 1, A, C, B);</span><br><span class="line">            //最后移动最后一个盘A-C</span><br><span class="line">            System.out.println(&quot;第&quot; + num + &quot;个盘&quot; + A + &quot;-&quot; + C);</span><br><span class="line">            sum++;</span><br><span class="line">            //把B塔所有盘移动到C</span><br><span class="line">            hanoiTower(num - 1, B, A, C);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3：动态规划算法-背包问题"><a href="#3：动态规划算法-背包问题" class="headerlink" title="3：动态规划算法-背包问题"></a>3：动态规划算法-背包问题</h3><p>1：01背包问题概述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V？它是在1978年由Merkel和Hellman提出的。</span><br></pre></td></tr></table></figure>

<p>2：实现思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义：有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</span><br><span class="line">f[i][v]=max&#123; f[i-1][v], f[i-1][v-w[i]]+v[i] &#125;。</span><br><span class="line">可以压缩空间，f[v]=max&#123;f[v],f[v-w[i]]+v[i]&#125;</span><br><span class="line">f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值</span><br><span class="line">f[i-1][v]表示前i-1件物品恰放入一个容量为v的背包可以获得的最大价值</span><br><span class="line">f[i-1][v-w[i]]+v[i]表示前i-1件物品放入到容量为（v-第i件物品的重量）的空间产生的最大价值+第i件物品的价值</span><br></pre></td></tr></table></figure>

<p>3：代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">核心代码：</span><br><span class="line"></span><br><span class="line">//开始动态规划,i代表物品个数，j代表背包容量</span><br><span class="line">        for (int i = 1; i &lt; v.length; i++) &#123;//不处理第一行，</span><br><span class="line">            for (int j = 1; j &lt; v[0].length; j++) &#123;//不处理第一列</span><br><span class="line">                if (w[i - 1] &gt; j) &#123;//说明第i个物品的重量大于背包重量,无法加入进去</span><br><span class="line">                    v[i][j] = v[i - 1][j];</span><br><span class="line">                &#125; else &#123;//说明第i个物品的重量小于背包的重量，则可以进行比较</span><br><span class="line">                    //因为i从1开始，索引需要-1</span><br><span class="line">                    //v[i][j] = Math.max(v[i - 1][j], (val[i - 1] + v[i - 1][j - w[i - 1]]));</span><br><span class="line">                    //为了记录商品的存放情况，不能用max</span><br><span class="line">                    if (v[i - 1][j] &gt; (val[i - 1] + v[i - 1][j - w[i - 1]])) &#123;</span><br><span class="line">                        v[i][j] = v[i - 1][j];</span><br><span class="line">                    &#125; else if (v[i - 1][j] &lt; (val[i - 1] + v[i - 1][j - w[i - 1]])) &#123;</span><br><span class="line">                        v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];</span><br><span class="line">                        path[i][j] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        v[i][j] = v[i - 1][j];</span><br><span class="line">                        System.out.println(&quot;且存在多种分配方案&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package com.it.knapsackproblem;</span><br><span class="line"></span><br><span class="line">//01背包问题</span><br><span class="line">public class KnapsackProblem &#123;</span><br><span class="line">    private static int sumW = 0;//记录总使用重量</span><br><span class="line">    private static int sumVal = 0;//记录总使用价值</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] w = &#123;1, 4, 3, 6, 10, 2, 5&#125;;//物品的重量</span><br><span class="line">        int[] val = &#123;1500, 3000, 2000, 2444, 4000, 2333, 2000&#125;;//物品的价值</span><br><span class="line">        int m = 10;//背包的重量</span><br><span class="line">        int n = val.length;//物品的个数</span><br><span class="line">        //v[i][j]表示前i个物品放到容量为j的背包中的最大价值</span><br><span class="line">        int[][] v = new int[n + 1][m + 1];</span><br><span class="line">        //定义二维数组用于记录存放情况</span><br><span class="line">        int[][] path = new int[n + 1][m + 1];</span><br><span class="line">        //初始化，</span><br><span class="line">        for (int i = 0; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[i][0] = 0;//当背包容量为0时，最大价值为0</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; v[0].length; j++) &#123;</span><br><span class="line">            v[0][j] = 0;//当物品为0个时，最大价值为0</span><br><span class="line">        &#125;</span><br><span class="line">        //开始动态规划,i代表物品个数，j代表背包容量</span><br><span class="line">        for (int i = 1; i &lt; v.length; i++) &#123;//不处理第一行，</span><br><span class="line">            for (int j = 1; j &lt; v[0].length; j++) &#123;//不处理第一列</span><br><span class="line">                if (w[i - 1] &gt; j) &#123;//说明第i个物品的重量大于背包重量,无法加入进去</span><br><span class="line">                    v[i][j] = v[i - 1][j];</span><br><span class="line">                &#125; else &#123;//说明第i个物品的重量小于背包的重量，则可以进行比较</span><br><span class="line">                    //因为i从1开始，索引需要-1</span><br><span class="line">                    //v[i][j] = Math.max(v[i - 1][j], (val[i - 1] + v[i - 1][j - w[i - 1]]));</span><br><span class="line">                    //为了记录商品的存放情况，不能用max</span><br><span class="line">                    if (v[i - 1][j] &gt; (val[i - 1] + v[i - 1][j - w[i - 1]])) &#123;</span><br><span class="line">                        v[i][j] = v[i - 1][j];</span><br><span class="line">                    &#125; else if (v[i - 1][j] &lt; (val[i - 1] + v[i - 1][j - w[i - 1]])) &#123;</span><br><span class="line">                        v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];</span><br><span class="line">                        path[i][j] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        v[i][j] = v[i - 1][j];</span><br><span class="line">                        System.out.println(&quot;且存在多种分配方案&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; v.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; v[i].length; j++) &#123;</span><br><span class="line">                System.out.print(v[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;路径为&quot;);</span><br><span class="line">        //得从后往前遍历</span><br><span class="line">        int i = path.length - 1;//行得最大下标</span><br><span class="line">        int j = path[0].length - 1;//列得最大下标</span><br><span class="line">        //从path数组得最后开始找，得到最优路径</span><br><span class="line">        while (i &gt; 0 &amp;&amp; j &gt; 0) &#123;</span><br><span class="line">            if (path[i][j] == 1) &#123;</span><br><span class="line">                //说明放置过数据</span><br><span class="line">                System.out.printf(&quot;第%d个商品放入背包&quot;, i);</span><br><span class="line">                sumW += w[i - 1];</span><br><span class="line">                sumVal += val[i - 1];</span><br><span class="line">                j -= w[i - 1];//最大重量得减去最后一个物品得重量</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            i--;//物品个数减少</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;背包可以使用的重量为&quot;+m);</span><br><span class="line">        System.out.println(&quot;总计使用重量为&quot;+sumW);</span><br><span class="line">        System.out.println(&quot;总计产生价值为&quot;+sumVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4：KMP算法-字符串匹配问题"><a href="#4：KMP算法-字符串匹配问题" class="headerlink" title="4：KMP算法-字符串匹配问题"></a>4：KMP算法-字符串匹配问题</h3><p>1：暴力匹配简介</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？</span><br><span class="line">首先，先理清楚了暴力匹配算法的流程及内在的逻辑：</span><br><span class="line">如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</span><br><span class="line">如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；</span><br><span class="line">如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</span><br></pre></td></tr></table></figure>

<p>2：暴力匹配代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假定：母串长度为N，字串长度为M，字串首字母在N中出现的次数为n次</span><br><span class="line">那么算法实际复杂度为：O(N)+O(n)*(M-)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.it.kmp;</span><br><span class="line"></span><br><span class="line">public class ViolenceMatch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 = &quot;wrfemwlrerw&quot;;</span><br><span class="line">        String str2 = &quot;lr&quot;;</span><br><span class="line">        System.out.println(violenceMatch(str1,str2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param str1 母串</span><br><span class="line">     * @param str2 子串</span><br><span class="line">     * @return 返回第一个索引值</span><br><span class="line">     */</span><br><span class="line">    //暴力匹配算法实现</span><br><span class="line">    public static int violenceMatch(String str1, String str2) &#123;</span><br><span class="line">        char[] s1 = str1.toCharArray();//是s1为母串</span><br><span class="line">        char[] s2 = str2.toCharArray();//说s2为字串</span><br><span class="line">        int s1Len = s1.length;</span><br><span class="line">        int s2Len = s2.length;</span><br><span class="line">        int i = 0;//i指向s1</span><br><span class="line">        int j = 0;//j指向s2</span><br><span class="line">        while (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;//保证匹配不越界</span><br><span class="line">            if (s1[i] == s2[j]) &#123;//说明匹配成功</span><br><span class="line">                i++;</span><br><span class="line">                j++;//如果全部都相等，则j会越界，即退出循环,此时的头索引即为i-j</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //如果不想等，则字串j继续置为0开始，</span><br><span class="line">                // 母串i的索引从第i-(j-1)个开始：即为前面一步和字串已经匹配到了j个元素，i需要回退j且+1开始</span><br><span class="line">                i = i - (j - 1);</span><br><span class="line">                j = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j == s2Len) &#123;</span><br><span class="line">            return i - j;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3：yanyubing算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">1：先遍历母串str1，找到字串str[0]在母串中的位子index，创建集合arr用于存放index；</span><br><span class="line">2：遍历集合arr取出arr.get(index)，循环字串长度，然后依次匹配，如果全部匹配成功，记录index</span><br><span class="line">3:将所有index存放到集合arr2中返回</span><br><span class="line"></span><br><span class="line">假定：母串长度为N，字串长度为M，字串首字母在N中出现的次数为n次</span><br><span class="line">那么算法实际复杂度为：O(N)+O(n)*(M-)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.it.minStr;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">//求最小子串</span><br><span class="line">public class M inStr &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = &quot;abcdefghijk&quot;;</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        for (int i = 0; i &lt; 80000000; i++) &#123;</span><br><span class="line">            int index = r.nextInt(s1.length());</span><br><span class="line">            stringBuilder.append(s1.charAt(index));</span><br><span class="line">        &#125;</span><br><span class="line">        s1 = stringBuilder.toString();</span><br><span class="line">//        System.out.println(s1);</span><br><span class="line">        //测试时间</span><br><span class="line">        String s2 = &quot;abd&quot;;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        ArrayList arrayList = minStr(s1, s2);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;8千万个母串查找字串耗时/ms；&quot;+(end - start));</span><br><span class="line">        System.out.println(&quot;头索引个数为&quot;+ arrayList.size());</span><br><span class="line">        System.out.println(&quot;头索引为&quot;+ arrayList.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //方法,返回满足条件的字串在母串中的索引的集合</span><br><span class="line">    public static ArrayList minStr(String s1, String s2) &#123;</span><br><span class="line">        //母串s1   字串s2</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();//创建一个集合，用来存放字串首字符在母串中出现的索引</span><br><span class="line">        char[] chars1 = s1.toCharArray();//转换为字符数组</span><br><span class="line">        char[] chars2 = s2.toCharArray();//转换为字符数组</span><br><span class="line">        for (int i = 0; i &lt; chars1.length - chars2.length + 1; i++) &#123;</span><br><span class="line">            if (chars2[0] == chars1[i]) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList2 = new ArrayList&lt;&gt;();//创建第二个集合，用来存放所有满足条件，当字串首字符在母串中出现的首字符索引</span><br><span class="line">        //拿到了首字母索引的集合，循环s2.length-2次，从s1索引为1开始和s2索引从每个i开始比较比较</span><br><span class="line">        if (chars2.length == 1) &#123;</span><br><span class="line">            return arrayList;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int j = 0; j &lt; arrayList.size(); j++) &#123;</span><br><span class="line">                boolean flag = true;</span><br><span class="line">                for (int i = 1; i &lt; s2.length(); i++) &#123;//每次比较循环s2.length-2次,制定flag标志为true，如果循环完成还为true，则表示该索引满足条件</span><br><span class="line">                    if (chars1[arrayList.get(j) + i] != chars2[i]) &#123;</span><br><span class="line">                        flag = false;//不满足条件时，把flag置为false,并且推出内层循环</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //一次循环完成之后flag还是true则证明字串满足条件，记录当前的索引</span><br><span class="line">                if (flag) &#123;</span><br><span class="line">                    arrayList2.add(arrayList.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return arrayList2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4：KMP算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：KMP算法实际思路就是尽可能减少已经被匹配过了的母串中的字符串</span><br><span class="line">2：需要借助与字串的部分匹配值表</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">部分匹配值表举例：如字串abcdabd</span><br><span class="line">   			头元素 						尾元素  						共有元素长度</span><br><span class="line">当1个元素时：a  						 		null  	     			  	     0</span><br><span class="line">当2个元素时：a 								 b	 		 			  		 0</span><br><span class="line">当3个元素时：(a，ab)  							(bc,c)	 				  		0</span><br><span class="line">当4个元素时：(a，ab,abc)  						(bcd,cd,d)	 			  		0</span><br><span class="line">当5个元素时：(a，ab,abc,abcd)  				(bcda,cda,da,a)	 	     		1</span><br><span class="line">当6个元素时：(a，ab,abc,abcd,abcda)  			(bcdab,cdab,dab,ab,b)	  		2	</span><br><span class="line">当7个元素时：(a，ab,abc,abcd,abcda,abcdab)  	(bcdabd,cdabd,dabd,abd,bd,d)	0</span><br><span class="line"></span><br><span class="line">即得到的字串abcdabd部分匹配值表为</span><br><span class="line">a	b	c	d	a	b	d</span><br><span class="line">0	0	0	0	1	2	0</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">package com.it.kmp;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Array;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class KMPAlgorithm &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 = &quot;BBC ABCDAB ABCDABCDABDE&quot;;</span><br><span class="line">        String str2 = &quot;ABCDABD&quot;;</span><br><span class="line">        int[] next = kmpNext(str2);//</span><br><span class="line">        System.out.println(Arrays.toString(next));//打印字串的部分匹配表的数组</span><br><span class="line">        int num = kmpSearch(str1, str2, next);</span><br><span class="line">        System.out.println(&quot;字串中找到的索引为：&quot;+num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param str1 母串</span><br><span class="line">     * @param str2 字串</span><br><span class="line">     * @param next 字串的部分匹配表</span><br><span class="line">     * @return 返回首字母索引的集合</span><br><span class="line">     */</span><br><span class="line">    //kmp算法</span><br><span class="line">    public static int kmpSearch(String str1, String str2, int[] next) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        //遍历</span><br><span class="line">        for (int i = 0, j = 0; i &lt; str1.length(); i++) &#123;//i指向母串str1,j指向str2</span><br><span class="line">            //还需要处理str2.charAt(j) ！= str1.charAt(i)的情况，调整j的大小</span><br><span class="line">            while (j &gt; 0 &amp;&amp; str2.charAt(j) != str1.charAt(i)) &#123;</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (str2.charAt(j) == str1.charAt(i)) &#123;//说明首字符相等</span><br><span class="line">                j++;//继续判断第二个字符，第三个...</span><br><span class="line">            &#125;</span><br><span class="line">            if (j == str2.length()) &#123;//如果j的长度==字串的长度了，那么就说明找到</span><br><span class="line">                return i - j + 1;//首字符索引添加到集合</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param dest 字串</span><br><span class="line">     * @return 部分匹配值表的数组</span><br><span class="line">     */</span><br><span class="line">    public static int[] kmpNext(String dest) &#123;</span><br><span class="line">        //创建一个next数组保存部分匹配值表</span><br><span class="line">        int[] next = new int[dest.length()];</span><br><span class="line">        next[0] = 0;//字符串长度为1的时候，部分匹配值为0</span><br><span class="line">        ArrayList&lt;String&gt; s1 = new ArrayList&lt;String&gt;();//用于存放前缀元素的字符串</span><br><span class="line">        ArrayList&lt;String&gt; s2 = new ArrayList&lt;String&gt;();//用于存放后缀元素</span><br><span class="line">        //我的思路是循环</span><br><span class="line">        for (int i = 1; i &lt; dest.length(); i++) &#123;//i表示第几个元素加入</span><br><span class="line">            /*     * 部分匹配值表举例：如字串abcdabd   			头元素 		尾元素  共有元素长度</span><br><span class="line">当1个元素时：a  						 		null  	     			  	     0</span><br><span class="line">当2个元素时：a 								 b	 		 			  		 0</span><br><span class="line">当3个元素时：(a，ab)  							(bc,c)	 				  		0</span><br><span class="line">当4个元素时：(a，ab,abc)  						(bcd,cd,d)	 			  		0</span><br><span class="line">当5个元素时：(a，ab,abc,abcd)  				(bcda,cda,da,a)	 	     		1</span><br><span class="line">当6个元素时：(a，ab,abc,abcd,abcda)  			(bcdab,cdab,dab,ab,b)	  		2</span><br><span class="line">当7个元素时：(a，ab,abc,abcd,abcda,abcdab)  	(bcdabd,cdabd,dabd,abd,bd,d)	0</span><br><span class="line">*/</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;//当i=3时，</span><br><span class="line">                s1.add(dest.substring(0, j));</span><br><span class="line">                s2.add(dest.substring(j, i + 1));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;当i为&quot; + i + &quot;时&quot;);</span><br><span class="line">            System.out.println(&quot;集合s1为&quot; + s1.toString());</span><br><span class="line">            System.out.println(&quot;集合s2为&quot; + s2.toString());</span><br><span class="line">            System.out.println();</span><br><span class="line">            //循环结束表示添加元素完成，开始比较</span><br><span class="line">            //比较s1与s2</span><br><span class="line">            for (int j = 0; j &lt; s1.size(); j++) &#123;</span><br><span class="line">                for (int k = 0; k &lt; s2.size(); k++) &#123;</span><br><span class="line">                    if (s1.get(j).equals(s2.get(k))) &#123;//说明存在相同元素</span><br><span class="line">                        next[i] = s1.get(j).length();//把相同元素的长度赋值给next[i]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;//比较完成之后需要重置s1与s2</span><br><span class="line">            s1.clear();</span><br><span class="line">            s2.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五：贪心算法-集合覆盖问题"><a href="#五：贪心算法-集合覆盖问题" class="headerlink" title="五：贪心算法-集合覆盖问题"></a>五：贪心算法-集合覆盖问题</h3><p>1：贪心算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">假设存在下面需要付费的广播台，以及广播台覆盖可以覆盖的地区，如何选择最少的广播台，让所有的地区都可以接收到信号</span><br><span class="line">广播台			覆盖地区</span><br><span class="line">k1			&quot;北京&quot;上海&quot;&quot;天津&quot;</span><br><span class="line">k2			&quot;广州&quot;&quot;北京&quot;&quot;深圳&quot;</span><br><span class="line">k3			&quot;成都&quot;&quot;上海&quot;&quot;杭州&quot;</span><br><span class="line">k4			&quot;上海&quot;&quot;天津&quot;</span><br><span class="line">k5			&quot;杭州&quot;&quot;大连&quot;</span><br><span class="line"></span><br><span class="line">贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</span><br><span class="line">贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 </span><br><span class="line"></span><br><span class="line">实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</span><br></pre></td></tr></table></figure>

<p>2：贪心算法思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：覆盖问题，遍历所有广播台，找到一个覆盖了最多未覆盖地区的电台（此电台可能包含一些已经覆盖的地区，但是没关系）</span><br><span class="line">2：将这些电台加入到集合，去掉已经加入的电台</span><br><span class="line">3：重复第1步，直到覆盖完全部地区</span><br></pre></td></tr></table></figure>

<p>3：代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思路清晰，主要就是对于集合的操作</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package com.it.greedy;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">//贪心算法</span><br><span class="line">public class GreedyAlgorithm &#123;</span><br><span class="line">    //存放所有地区,所有地区为全局变量，并且随时需要改变</span><br><span class="line">    static HashSet&lt;String&gt; allAreas = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建广播电台</span><br><span class="line">        HashMap&lt;String, HashSet&gt; broadcasts = new HashMap&lt;&gt;();</span><br><span class="line">        //将各个电台放入</span><br><span class="line">        HashSet&lt;String&gt; hashSet1 = new HashSet();</span><br><span class="line">        hashSet1.add(&quot;北京&quot;);</span><br><span class="line">        hashSet1.add(&quot;上海&quot;);</span><br><span class="line">        hashSet1.add(&quot;天津&quot;);</span><br><span class="line">        HashSet&lt;String&gt; hashSet2 = new HashSet();</span><br><span class="line">        hashSet2.add(&quot;广州&quot;);</span><br><span class="line">        hashSet2.add(&quot;北京&quot;);</span><br><span class="line">        hashSet2.add(&quot;深圳&quot;);</span><br><span class="line">        HashSet&lt;String&gt; hashSet3 = new HashSet();</span><br><span class="line">        hashSet3.add(&quot;成都&quot;);</span><br><span class="line">        hashSet3.add(&quot;上海&quot;);</span><br><span class="line">        hashSet3.add(&quot;杭州&quot;);</span><br><span class="line">        HashSet&lt;String&gt; hashSet4 = new HashSet();</span><br><span class="line">        hashSet4.add(&quot;上海&quot;);</span><br><span class="line">        hashSet4.add(&quot;天津&quot;);</span><br><span class="line">        HashSet&lt;String&gt; hashSet5 = new HashSet();</span><br><span class="line">        hashSet5.add(&quot;杭州&quot;);</span><br><span class="line">        hashSet5.add(&quot;大连&quot;);</span><br><span class="line">        //加入到map</span><br><span class="line">        broadcasts.put(&quot;k1&quot;, hashSet1);</span><br><span class="line">        broadcasts.put(&quot;k2&quot;, hashSet2);</span><br><span class="line">        broadcasts.put(&quot;k3&quot;, hashSet3);</span><br><span class="line">        broadcasts.put(&quot;k4&quot;, hashSet4);</span><br><span class="line">        broadcasts.put(&quot;k5&quot;, hashSet5);</span><br><span class="line">        for (Map.Entry&lt;String, HashSet&gt; Entry : broadcasts.entrySet()) &#123;</span><br><span class="line">            HashSet&lt;String&gt; value = Entry.getValue();//得到value</span><br><span class="line">            for (String s : value) &#123;</span><br><span class="line">                allAreas.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //添加完所有地区</span><br><span class="line">        System.out.println(&quot;需要覆盖的地区&quot;);</span><br><span class="line">        System.out.println(allAreas.toString());</span><br><span class="line">        System.out.println();</span><br><span class="line">        //创建ArrayList集合，存放选择的电台集合。</span><br><span class="line">        // 选择的条件为：遍历电台，将最多的未覆盖的地区的电台加入到选择的集合中</span><br><span class="line">        ArrayList&lt;String&gt; selects = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //定义一个数组,用于存放每个电台与还未覆盖地区的交集的个数</span><br><span class="line">        int arr[] = new int[broadcasts.size()];//长度为电台总个数</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();//存放电台集合</span><br><span class="line">        arrayList.add(&quot;k1&quot;);</span><br><span class="line">        arrayList.add(&quot;k2&quot;);</span><br><span class="line">        arrayList.add(&quot;k3&quot;);</span><br><span class="line">        arrayList.add(&quot;k4&quot;);</span><br><span class="line">        arrayList.add(&quot;k5&quot;);</span><br><span class="line"></span><br><span class="line">        while (allAreas.size() &gt; 0) &#123;</span><br><span class="line">            System.out.println(&quot;需要覆盖的地区&quot;);</span><br><span class="line">            System.out.println(allAreas.toString());</span><br><span class="line">            System.out.println();</span><br><span class="line">            int index = 0;//手动创建索引</span><br><span class="line">            //遍历广播电台</span><br><span class="line">            for (Map.Entry&lt;String, HashSet&gt; stringHashSetEntry : broadcasts.entrySet()) &#123;</span><br><span class="line">                String key = stringHashSetEntry.getKey();//得到电台名称</span><br><span class="line">                HashSet&lt;String&gt; value = stringHashSetEntry.getValue();//得到每个电台对应的覆盖地区</span><br><span class="line">                int count = 0;</span><br><span class="line">                for (String s : value) &#123;</span><br><span class="line">                    if (allAreas.contains(s)) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[index] = count;</span><br><span class="line">                index++;</span><br><span class="line">                //每次循环完成之后count为当前k1电台与allAreas的交集的个数</span><br><span class="line">            &#125;</span><br><span class="line">            //所有的循环完成之后即得到了存放交集的arr，遍历数组取出最大值</span><br><span class="line">            // 将对应的电台加入selects电台集合</span><br><span class="line">            // 并且将该电台所覆盖的地区从需要覆盖的地区中去除</span><br><span class="line">            int max = 0;</span><br><span class="line">            int index2 = 0;//记录最大值所在的索引</span><br><span class="line">            for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                if (arr[i] &gt; max) &#123;</span><br><span class="line">                    max = arr[i];</span><br><span class="line">                    index2 = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //循环结束即得到了最大值的索引，添加对应的电台到电台集合</span><br><span class="line">            selects.add(arrayList.get(index2));//&quot;k1&quot;</span><br><span class="line">            System.out.println(&quot;得到的电台为：&quot; + arrayList.get(index2));</span><br><span class="line">            //移除对应电台所覆盖的地区</span><br><span class="line">            HashSet&lt;String&gt; hashSet = broadcasts.get(arrayList.get(index2));//得到&quot;k1&quot;电台对应覆盖地区的集合</span><br><span class="line">            for (String s : hashSet) &#123;</span><br><span class="line">                allAreas.remove(s);</span><br><span class="line">            &#125;//移除了地区</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;得到的电台为：&quot; + selects.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六：普利姆算法-修路问题"><a href="#六：普利姆算法-修路问题" class="headerlink" title="六：普利姆算法-修路问题"></a>六：普利姆算法-修路问题</h3><p>1：普里姆算法（Prim算法）简介-最小生成树MST</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）发现；并在1957年由美国计算机科学家罗伯特·普里姆（英语：Robert C. Prim）独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。</span><br></pre></td></tr></table></figure>

<p>2：算法描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1).输入：一个加权连通图，其中顶点集合为V，边集合为E；</span><br><span class="line">2).初始化：Vnew = &#123;x&#125;，其中x为集合V中的任一节点（起始点），Enew = &#123;&#125;,为空；</span><br><span class="line">3).重复下列操作，直到Vnew = V：</span><br><span class="line">a.在集合E中选取权值最小的边&lt;u, v&gt;，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</span><br><span class="line">b.将v加入集合Vnew中，将&lt;u, v&gt;边加入集合Enew中；</span><br><span class="line">4).输出：使用集合Vnew和Enew来描述所得到的最小生成树。</span><br><span class="line"></span><br><span class="line">图解见：https://baike.baidu.com/item/Prim/10242166?fr=aladdin#1</span><br></pre></td></tr></table></figure>

<p>3：代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">package com.it.prim;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">//普利姆算法</span><br><span class="line">public class PrimAlgorithm &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//测试图是否创建成功</span><br><span class="line">        char[] data = new char[]&#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</span><br><span class="line">        int verxs = data.length;</span><br><span class="line">        //邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通</span><br><span class="line">        int[][] weight = new int[][]&#123;</span><br><span class="line">                &#123;10000, 5, 7, 10000, 10000, 10000, 2&#125;,</span><br><span class="line">                &#123;5, 10000, 10000, 9, 10000, 10000, 3&#125;,</span><br><span class="line">                &#123;7, 10000, 10000, 10000, 8, 10000, 10000&#125;,</span><br><span class="line">                &#123;10000, 9, 10000, 10000, 10000, 4, 10000&#125;,</span><br><span class="line">                &#123;10000, 10000, 8, 10000, 10000, 5, 4&#125;,</span><br><span class="line">                &#123;10000, 10000, 10000, 4, 5, 10000, 6&#125;,</span><br><span class="line">                &#123;2, 3, 10000, 10000, 4, 6, 10000&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        //创建MGraph对象</span><br><span class="line">        MGraph graph = new MGraph(verxs);</span><br><span class="line">        //创建一个MinTree对象</span><br><span class="line">        MinTree minTree = new MinTree();</span><br><span class="line">        minTree.createGraph(graph, verxs, data, weight);</span><br><span class="line">        //输出</span><br><span class="line">        minTree.showGraph(graph);</span><br><span class="line">        //测试普利姆算法</span><br><span class="line">        minTree.prim(graph, 1);//</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//构建最小生成树--&gt;村庄的图</span><br><span class="line">class MinTree &#123;</span><br><span class="line">    //创建图的临接矩阵</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param graph  图对象</span><br><span class="line">     * @param verxs  图对应的顶点的个数</span><br><span class="line">     * @param data   图的各个顶点的值</span><br><span class="line">     * @param weight 图的临接矩阵</span><br><span class="line">     *               初始化图对象</span><br><span class="line">     */</span><br><span class="line">    public void createGraph(MGraph graph, int verxs, char data[], int[][] weight) &#123;</span><br><span class="line">        int i, j;</span><br><span class="line">        for (i = 0; i &lt; verxs; i++) &#123;//顶点</span><br><span class="line">            graph.data[i] = data[i];</span><br><span class="line">            for (j = 0; j &lt; verxs; j++) &#123;</span><br><span class="line">                graph.weight[i][j] = weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历图，显示图的临接矩阵</span><br><span class="line">    public void showGraph(MGraph graph) &#123;</span><br><span class="line">        for (int[] link : graph.weight) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//编写prim算法，得到最小生成树</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param graph 图</span><br><span class="line">     * @param v     表示从图的第几个顶点开始生成&apos;A&apos;-&gt;0 &apos;B&apos;-&gt;1...</span><br><span class="line">     */</span><br><span class="line">    public void prim(MGraph graph, int v) &#123;</span><br><span class="line">        //visited[] 标记结点(顶点)是否被访问过</span><br><span class="line">        int visited[] = new int[graph.verxs];</span><br><span class="line">        //visited[] 默认元素的值都是0, 表示没有访问过</span><br><span class="line">//		for(int i =0; i &lt;graph.verxs; i++) &#123;</span><br><span class="line">//			visited[i] = 0;</span><br><span class="line">//		&#125;</span><br><span class="line"></span><br><span class="line">        //把当前这个结点标记为已访问</span><br><span class="line">        visited[v] = 1;</span><br><span class="line">        //h1 和 h2 记录两个顶点的下标</span><br><span class="line">        int h1 = -1;</span><br><span class="line">        int h2 = -1;</span><br><span class="line">        int minWeight = 10000; //将 minWeight 初始成一个大数，后面在遍历过程中，会被替换</span><br><span class="line">        for (int k = 1; k &lt; graph.verxs; k++) &#123;//因为有 graph.verxs顶点，普利姆算法结束后，有 graph.verxs-1边</span><br><span class="line"></span><br><span class="line">            //这个是确定每一次生成的子图 ，和哪个结点的距离最近</span><br><span class="line">            for (int i = 0; i &lt; graph.verxs; i++) &#123;// i结点表示被访问过的结点</span><br><span class="line">                for (int j = 0; j &lt; graph.verxs; j++) &#123;//j结点表示还没有访问过的结点</span><br><span class="line">                    if (visited[i] == 1 &amp;&amp; visited[j] == 0 &amp;&amp; graph.weight[i][j] &lt; minWeight) &#123;</span><br><span class="line">                        //替换minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边)</span><br><span class="line">                        minWeight = graph.weight[i][j];</span><br><span class="line">                        h1 = i;</span><br><span class="line">                        h2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //找到一条边是最小</span><br><span class="line">            System.out.println(&quot;边&lt;&quot; + graph.data[h1] + &quot;,&quot; + graph.data[h2] + &quot;&gt; 权值:&quot; + minWeight);</span><br><span class="line">            //将当前这个结点标记为已经访问</span><br><span class="line">            visited[h2] = 1;</span><br><span class="line">            //minWeight 重新设置为最大值 10000</span><br><span class="line">            minWeight = 10000;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//图</span><br><span class="line">class MGraph &#123;</span><br><span class="line">    int verxs;//表示图的节点个数</span><br><span class="line">    char[] data;//存放节点的数据</span><br><span class="line">    int[][] weight;//存放边，临接矩阵</span><br><span class="line"></span><br><span class="line">    public MGraph(int verxs) &#123;//构造器</span><br><span class="line">        this.verxs = verxs;</span><br><span class="line">        data = new char[verxs];</span><br><span class="line">        weight = new int[verxs][verxs];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七：克鲁斯卡尔算法-公交站问题"><a href="#七：克鲁斯卡尔算法-公交站问题" class="headerlink" title="七：克鲁斯卡尔算法-公交站问题"></a>七：克鲁斯卡尔算法-公交站问题</h3><p>1：Kruskal算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Kruskal算法是一种用来查找最小生成树的算法，由Joseph Kruskal在1956年发表。用来解决同样问题的还有Prim算法和Boruvka算法等。三种算法都是贪心算法的应用。和Boruvka算法不同的地方是，Kruskal算法在图中存在相同权值的边时也有效。 </span><br><span class="line"> </span><br><span class="line">1：新建图G，G中拥有原图中相同的节点，但没有边；</span><br><span class="line">2：将原图中所有的边按权值从小到大排序；</span><br><span class="line">3：从权值最小的边开始，如果这条边连接的两个节点于图G中不会形成回路，则添加这条边到图G中；</span><br><span class="line">4：重复3，直至图G中所有的节点都在同一个连通分量中。</span><br><span class="line"></span><br><span class="line">核心思想是不要形成回路，如何判断如何形成了回路！需要加入边的两个顶点不能指向同一个终点。</span><br></pre></td></tr></table></figure>

<p>2：代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">核心代码：获取终点的方法</span><br><span class="line">/**</span><br><span class="line">    * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同</span><br><span class="line">    * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成</span><br><span class="line">    * @param i : 表示传入的顶点对应的下标</span><br><span class="line">    * @return 返回的就是 下标为i的这个顶点对应的终点的下标, 一会回头还有来理解</span><br><span class="line">    */</span><br><span class="line">   private int getEnd(int[] ends, int i) &#123; // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]</span><br><span class="line">       while(ends[i] != 0) &#123;</span><br><span class="line">           i = ends[i];</span><br><span class="line">       &#125;</span><br><span class="line">       return i;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">package com.it.kruskalCase;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class KruskalCase &#123;</span><br><span class="line"></span><br><span class="line">    private int edgeNum; //边的个数</span><br><span class="line">    private char[] vertexs; //顶点数组</span><br><span class="line">    private int[][] matrix; //邻接矩阵</span><br><span class="line">    //使用 INF 表示两个顶点不能连通</span><br><span class="line">    private static final int INF = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char[] vertexs = &#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</span><br><span class="line">        //克鲁斯卡尔算法的邻接矩阵</span><br><span class="line">        int matrix[][] = &#123;</span><br><span class="line">                /*A*//*B*//*C*//*D*//*E*//*F*//*G*/</span><br><span class="line">                /*A*/ &#123;   0,  12, INF, INF, INF,  16,  14&#125;,</span><br><span class="line">                /*B*/ &#123;  12,   0,  10, INF, INF,   7, INF&#125;,</span><br><span class="line">                /*C*/ &#123; INF,  10,   0,   3,   5,   6, INF&#125;,</span><br><span class="line">                /*D*/ &#123; INF, INF,   3,   0,   4, INF, INF&#125;,</span><br><span class="line">                /*E*/ &#123; INF, INF,   5,   4,   0,   2,   8&#125;,</span><br><span class="line">                /*F*/ &#123;  16,   7,   6, INF,   2,   0,   9&#125;,</span><br><span class="line">                /*G*/ &#123;  14, INF, INF, INF,   8,   9,   0&#125;&#125;;</span><br><span class="line">        //大家可以在去测试其它的邻接矩阵，结果都可以得到最小生成树.</span><br><span class="line"></span><br><span class="line">        //创建KruskalCase 对象实例</span><br><span class="line">        KruskalCase kruskalCase = new KruskalCase(vertexs, matrix);</span><br><span class="line">        //输出构建的</span><br><span class="line">        kruskalCase.print();</span><br><span class="line">        kruskalCase.kruskal();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public KruskalCase(char[] vertexs, int[][] matrix) &#123;</span><br><span class="line">        //初始化顶点数和边的个数</span><br><span class="line">        int vlen = vertexs.length;</span><br><span class="line"></span><br><span class="line">        //初始化顶点, 复制拷贝的方式</span><br><span class="line">        this.vertexs = new char[vlen];</span><br><span class="line">        for(int i = 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            this.vertexs[i] = vertexs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //初始化边, 使用的是复制拷贝的方式</span><br><span class="line">        this.matrix = new int[vlen][vlen];</span><br><span class="line">        for(int i = 0; i &lt; vlen; i++) &#123;</span><br><span class="line">            for(int j= 0; j &lt; vlen; j++) &#123;</span><br><span class="line">                this.matrix[i][j] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //统计边的条数</span><br><span class="line">        for(int i =0; i &lt; vlen; i++) &#123;</span><br><span class="line">            for(int j = i+1; j &lt; vlen; j++) &#123;</span><br><span class="line">                if(this.matrix[i][j] != INF) &#123;</span><br><span class="line">                    edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void kruskal() &#123;</span><br><span class="line">        int index = 0; //表示最后结果数组的索引</span><br><span class="line">        int[] ends = new int[edgeNum]; //用于保存&quot;已有最小生成树&quot; 中的每个顶点在最小生成树中的终点</span><br><span class="line">        //创建结果数组, 保存最后的最小生成树</span><br><span class="line">        EData[] rets = new EData[edgeNum];</span><br><span class="line"></span><br><span class="line">        //获取图中 所有的边的集合 ， 一共有12边</span><br><span class="line">        EData[] edges = getEdges();</span><br><span class="line">        System.out.println(&quot;图的边的集合=&quot; + Arrays.toString(edges) + &quot; 共&quot;+ edges.length); //12</span><br><span class="line"></span><br><span class="line">        //按照边的权值大小进行排序(从小到大)</span><br><span class="line">        sortEdges(edges);</span><br><span class="line"></span><br><span class="line">        //遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入 rets, 否则不能加入</span><br><span class="line">        for(int i=0; i &lt; edgeNum; i++) &#123;</span><br><span class="line">            //获取到第i条边的第一个顶点(起点)</span><br><span class="line">            int p1 = getPosition(edges[i].start); //p1=4</span><br><span class="line">            //获取到第i条边的第2个顶点</span><br><span class="line">            int p2 = getPosition(edges[i].end); //p2 = 5</span><br><span class="line"></span><br><span class="line">            //获取p1这个顶点在已有最小生成树中的终点</span><br><span class="line">            int m = getEnd(ends, p1); //m = 4</span><br><span class="line">            //获取p2这个顶点在已有最小生成树中的终点</span><br><span class="line">            int n = getEnd(ends, p2); // n = 5</span><br><span class="line">            //是否构成回路</span><br><span class="line">            if(m != n) &#123; //没有构成回路</span><br><span class="line">                ends[m] = n; // 设置m 在&quot;已有最小生成树&quot;中的终点 &lt;E,F&gt; [0,0,0,0,5,0,0,0,0,0,0,0]</span><br><span class="line">                rets[index++] = edges[i]; //有一条边加入到rets数组</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。</span><br><span class="line">        //统计并打印 &quot;最小生成树&quot;, 输出  rets</span><br><span class="line">        System.out.println(&quot;最小生成树为&quot;);</span><br><span class="line">        for(int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            System.out.println(rets[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印邻接矩阵</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;邻接矩阵为: \n&quot;);</span><br><span class="line">        for(int i = 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            for(int j=0; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                System.out.printf(&quot;%12d&quot;, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();//换行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 功能：对边进行排序处理, 冒泡排序</span><br><span class="line">     * @param edges 边的集合</span><br><span class="line">     */</span><br><span class="line">    private void sortEdges(EData[] edges) &#123;</span><br><span class="line">        for(int i = 0; i &lt; edges.length - 1; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; edges.length - 1 - i; j++) &#123;</span><br><span class="line">                if(edges[j].weight &gt; edges[j+1].weight) &#123;//交换</span><br><span class="line">                    EData tmp = edges[j];</span><br><span class="line">                    edges[j] = edges[j+1];</span><br><span class="line">                    edges[j+1] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param ch 顶点的值，比如&apos;A&apos;,&apos;B&apos;</span><br><span class="line">     * @return 返回ch顶点对应的下标，如果找不到，返回-1</span><br><span class="line">     */</span><br><span class="line">    private int getPosition(char ch) &#123;</span><br><span class="line">        for(int i = 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            if(vertexs[i] == ch) &#123;//找到</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //找不到,返回-1</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 功能: 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组</span><br><span class="line">     * 是通过matrix 邻接矩阵来获取</span><br><span class="line">     * EData[] 形式 [[&apos;A&apos;,&apos;B&apos;, 12], [&apos;B&apos;,&apos;F&apos;,7], .....]</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private EData[] getEdges() &#123;</span><br><span class="line">        int index = 0;</span><br><span class="line">        EData[] edges = new EData[edgeNum];</span><br><span class="line">        for(int i = 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            for(int j=i+1; j &lt;vertexs.length; j++) &#123;</span><br><span class="line">                if(matrix[i][j] != INF) &#123;</span><br><span class="line">                    edges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return edges;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同</span><br><span class="line">     * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成</span><br><span class="line">     * @param i : 表示传入的顶点对应的下标</span><br><span class="line">     * @return 返回的就是 下标为i的这个顶点对应的终点的下标, 一会回头还有来理解</span><br><span class="line">     */</span><br><span class="line">    private int getEnd(int[] ends, int i) &#123; // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]</span><br><span class="line">        while(ends[i] != 0) &#123;</span><br><span class="line">            i = ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建一个类EData ，它的对象实例就表示一条边</span><br><span class="line">class EData &#123;</span><br><span class="line">    char start; //边的一个点</span><br><span class="line">    char end; //边的另外一个点</span><br><span class="line">    int weight; //边的权值</span><br><span class="line">    //构造器</span><br><span class="line">    public EData(char start, char end, int weight) &#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    //重写toString, 便于输出边信息</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;EData [&lt;&quot; + start + &quot;, &quot; + end + &quot;&gt;= &quot; + weight + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八：迪杰斯特拉算法-最短路径问题"><a href="#八：迪杰斯特拉算法-最短路径问题" class="headerlink" title="八：迪杰斯特拉算法-最短路径问题"></a>八：迪杰斯特拉算法-最短路径问题</h3><p>1：迪杰斯特拉算法介绍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</span><br><span class="line"></span><br><span class="line">通过被选定的单一顶点源，思想主要是图的广度优先算法。</span><br></pre></td></tr></table></figure>

<p>2：实现步骤</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.指定一个节点，例如我们要计算 &apos;A&apos; 到其他节点的最短路径</span><br><span class="line"></span><br><span class="line">2.引入两个集合（S、U），S集合包含已求出的最短路径的点（以及相应的最短长度），U集合包含未求出最短路径的点（以及A到该点的路径，注意 A-&gt;C由于没有直接相连 初始时为∞）</span><br><span class="line"></span><br><span class="line">3.初始化两个集合，S集合初始时 只有当前要计算的节点，A-&gt;A = 0，</span><br><span class="line">U集合初始时为 A-&gt;B = 4, A-&gt;C = ∞, A-&gt;D = 2, A-&gt;E = ∞，</span><br><span class="line"></span><br><span class="line">4.从U集合中找出路径最短的点，加入S集合，例如 A-&gt;D = 2</span><br><span class="line"></span><br><span class="line">5:更新U集合路径，if ( &apos;AD 距离&apos;+&apos;D 到 B,C,E 的距离&apos;   &lt; &apos;A 到 B,C,E 的距离&apos; ) 则更新U</span><br><span class="line"></span><br><span class="line">6:循环执行 4、5 两步骤，直至遍历结束，得到A 到其他节点的最短路径</span><br></pre></td></tr></table></figure>

<p>3：代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">核心思想：</span><br><span class="line">1：第一次可以找到和A相邻最短的临接节点“例如K”，即A到该节点&quot;K&quot;路径最短；</span><br><span class="line">这时如果		A到K的路径+“K”到其他节点的路径 &lt;	A直接到其他节点的路径</span><br><span class="line">则需要更新A到其他节点路径最短的集合</span><br><span class="line">2：这一次又可以找到和A相邻的第二短的节点</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package com.it.dijkstra;</span><br><span class="line"></span><br><span class="line">public class Dijkstra &#123;</span><br><span class="line">    public static final int M = 10000; // 代表正无穷</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 二维数组每一行分别是 A、B、C、D、E 各点到其余点的距离,</span><br><span class="line">        // A -&gt; A 距离为0, 常量M 为正无穷</span><br><span class="line">        int[][] weight1 = &#123;</span><br><span class="line">                &#123;0, 4, M, 2, M&#125;,</span><br><span class="line">                &#123;4, 0, 4, 1, M&#125;,</span><br><span class="line">                &#123;M, 4, 0, 1, 3&#125;,</span><br><span class="line">                &#123;2, 1, 1, 0, 7&#125;,</span><br><span class="line">                &#123;M, M, 3, 7, 0&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        int start = 0;</span><br><span class="line"></span><br><span class="line">        int[] shortPath = dijkstra(weight1, start);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; shortPath.length; i++) &#123;</span><br><span class="line">            System.out.println(&quot;从&quot; + start + &quot;出发到&quot; + i + &quot;的最短距离为：&quot; + shortPath[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int[] dijkstra(int[][] weight, int start) &#123;</span><br><span class="line">        // 接受一个有向图的权重矩阵，和一个起点编号start（从0编号，顶点存在数组中）</span><br><span class="line">        // 返回一个int[] 数组，表示从start到它的最短路径长度</span><br><span class="line">        int n = weight.length; // 顶点个数</span><br><span class="line">        int[] shortPath = new int[n]; // 保存start到其他各点的最短路径</span><br><span class="line">        String[] path = new String[n]; // 保存start到其他各点最短路径的字符串表示</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            path[i] = start + &quot;--&gt;&quot; + i;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] visited = new int[n]; // 标记当前该顶点的最短路径是否已经求出,1表示已求出</span><br><span class="line"></span><br><span class="line">        // 初始化，第一个顶点已经求出</span><br><span class="line">        shortPath[start] = 0;</span><br><span class="line">        visited[start] = 1;</span><br><span class="line"></span><br><span class="line">        for (int count = 1; count &lt; n; count++) &#123; // 要加入n-1个顶点</span><br><span class="line">            int k = -1; // 选出一个距离初始顶点start最近的未标记顶点</span><br><span class="line">            int dmin = Integer.MAX_VALUE;</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                if (visited[i] == 0 &amp;&amp; weight[start][i] &lt; dmin) &#123;</span><br><span class="line">                    dmin = weight[start][i];</span><br><span class="line">                    k = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 将新选出的顶点标记为已求出最短路径，且到start的最短路径就是dmin</span><br><span class="line">            shortPath[k] = dmin;</span><br><span class="line">            visited[k] = 1;</span><br><span class="line"></span><br><span class="line">            // 以k为中间点，修正从start到未访问各点的距离</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                //如果 &apos;起始点到当前点距离&apos; + &apos;当前点到某点距离&apos; &lt; &apos;起始点到某点距离&apos;, 则更新</span><br><span class="line">                if (visited[i] == 0 &amp;&amp; weight[start][k] + weight[k][i] &lt; weight[start][i]) &#123;</span><br><span class="line">                    weight[start][i] = weight[start][k] + weight[k][i];</span><br><span class="line">                    path[i] = path[k] + &quot;--&gt;&quot; + i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;从&quot; + start + &quot;出发到&quot; + i + &quot;的最短路径为：&quot; + path[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;=====================================&quot;);</span><br><span class="line">        return shortPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九：弗洛伊德算法-最短路径"><a href="#九：弗洛伊德算法-最短路径" class="headerlink" title="九：弗洛伊德算法-最短路径"></a>九：弗洛伊德算法-最短路径</h3><p>1：Floyd算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。</span><br><span class="line"></span><br><span class="line">注意：目标是多源点，该算法的时间复杂度为（n^3）</span><br></pre></td></tr></table></figure>

<p>2：思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。</span><br><span class="line">2，对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。</span><br><span class="line">把图用邻接矩阵G表示出来，如果从Vi到Vj有路可达，则G[i][j]=d，d表示该路的长度；否则G[i][j]=无穷大。定义一个矩阵D用来记录所插入点的信息，D[i][j]表示从Vi到Vj需要经过的点，初始化D[i][j]=j。把各个顶点插入图中，比较插点后的距离与原来的距离，G[i][j] = min( G[i][j], G[i][k]+G[k][j] )，如果G[i][j]的值变小，则D[i][j]=k。在G中包含有两点之间最短道路的信息，而在D中则包含了最短通路径的信息。</span><br><span class="line">比如，要寻找从V5到V1的路径。根据D，假如D(5,1)=3则说明从V5到V1经过V3，路径为&#123;V5,V3,V1&#125;，如果D(5,3)=3，说明V5与V3直接相连，如果D(3,1)=1，说明V3与V1直接相连。</span><br></pre></td></tr></table></figure>

<p>3：其他</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Floyd算法适用于APSP(All Pairs Shortest Paths，多源最短路径)，是一种动态规划算法，稠密图效果最佳，边权可正可负。此算法简单有效，由于三重循环结构紧凑，对于稠密图，效率要高于执行|V|次Dijkstra算法，也要高于执行|V|次SPFA算法。</span><br><span class="line">优点：容易理解，可以算出任意两个节点之间的最短距离，代码编写简单。</span><br><span class="line">缺点：时间复杂度比较高，不适合计算大量数据。</span><br></pre></td></tr></table></figure>

<p>4：代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package com.it.floyd;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class FloydAlgorithm &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 测试看看图是否创建成功</span><br><span class="line">        char[] vertex = &#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</span><br><span class="line">        //创建邻接矩阵</span><br><span class="line">        int[][] matrix = new int[vertex.length][vertex.length];</span><br><span class="line">        final int N = 65535;</span><br><span class="line">        matrix[0] = new int[]&#123;0, 5, 7, N, N, N, 2&#125;;</span><br><span class="line">        matrix[1] = new int[]&#123;5, 0, N, 9, N, N, 3&#125;;</span><br><span class="line">        matrix[2] = new int[]&#123;7, N, 0, N, 8, N, N&#125;;</span><br><span class="line">        matrix[3] = new int[]&#123;N, 9, N, 0, N, 4, N&#125;;</span><br><span class="line">        matrix[4] = new int[]&#123;N, N, 8, N, 0, 5, 4&#125;;</span><br><span class="line">        matrix[5] = new int[]&#123;N, N, N, 4, 5, 0, 6&#125;;</span><br><span class="line">        matrix[6] = new int[]&#123;2, 3, N, N, 4, 6, 0&#125;;</span><br><span class="line"></span><br><span class="line">        //创建 Graph 对象</span><br><span class="line">        Graph graph = new Graph(vertex.length, matrix, vertex);</span><br><span class="line">        //调用弗洛伊德算法</span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建图</span><br><span class="line">class Graph &#123;</span><br><span class="line">    private char[] vertex; // 存放顶点的数组</span><br><span class="line">    private int[][] dis; // 保存，从各个顶点出发到其它顶点的距离，最后的结果，也是保留在该数组</span><br><span class="line">    private int[][] pre;// 保存到达目标顶点的前驱顶点</span><br><span class="line"></span><br><span class="line">    // 构造器</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param length 大小</span><br><span class="line">     * @param matrix 邻接矩阵</span><br><span class="line">     * @param vertex 顶点数组</span><br><span class="line">     */</span><br><span class="line">    public Graph(int length, int[][] matrix, char[] vertex) &#123;</span><br><span class="line">        this.vertex = vertex;</span><br><span class="line">        this.dis = matrix;</span><br><span class="line">        this.pre = new int[length][length];</span><br><span class="line">        // 对pre数组初始化, 注意存放的是前驱顶点的下标</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            Arrays.fill(pre[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 显示pre数组和dis数组</span><br><span class="line">    public void show() &#123;</span><br><span class="line"></span><br><span class="line">        //为了显示便于阅读，我们优化一下输出</span><br><span class="line">        char[] vertex = &#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</span><br><span class="line">        for (int k = 0; k &lt; dis.length; k++) &#123;</span><br><span class="line">            // 先将pre数组输出的一行</span><br><span class="line">            for (int i = 0; i &lt; dis.length; i++) &#123;</span><br><span class="line">                System.out.print(vertex[pre[k][i]] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            // 输出dis数组的一行数据</span><br><span class="line">            for (int i = 0; i &lt; dis.length; i++) &#123;</span><br><span class="line">                System.out.print(&quot;(&quot; + vertex[k] + &quot;到&quot; + vertex[i] + &quot;的最短路径是&quot; + dis[k][i] + &quot;) &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void floyd() &#123;</span><br><span class="line">        int len = 0; //变量保存距离</span><br><span class="line">        //对中间顶点遍历， k 就是中间顶点的下标 [A, B, C, D, E, F, G]</span><br><span class="line">        for (int k = 0; k &lt; dis.length; k++) &#123; //</span><br><span class="line">            //从i顶点开始出发 [A, B, C, D, E, F, G]</span><br><span class="line">            for (int i = 0; i &lt; dis.length; i++) &#123;</span><br><span class="line">                //到达j顶点 // [A, B, C, D, E, F, G]</span><br><span class="line">                for (int j = 0; j &lt; dis.length; j++) &#123;</span><br><span class="line">                    len = dis[i][k] + dis[k][j];// =&gt; 求出从i 顶点出发，经过 k中间顶点，到达 j 顶点距离</span><br><span class="line">                    if (len &lt; dis[i][j]) &#123;//如果len小于 dis[i][j]</span><br><span class="line">                        dis[i][j] = len;//更新距离</span><br><span class="line">                        pre[i][j] = pre[k][j];//更新前驱顶点</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十：马踏棋盘算法-骑士周游"><a href="#十：马踏棋盘算法-骑士周游" class="headerlink" title="十：马踏棋盘算法-骑士周游"></a>十：马踏棋盘算法-骑士周游</h3><p>1：简介</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将马随机放在国际象棋的Board[0～7][0～7]的某个方格中，马按走棋规则进行移动。，走遍棋盘上全部64个方格。编制非递归程序，求出马的行走路线，并按求出的行走路线，将数字1，2，…，64依次填入一个8×8的方阵，输出之。</span><br></pre></td></tr></table></figure>

<p>2：思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：可以用图的深度优先遍历+回溯；即一直走到底，然后发现走不通之后回溯</span><br><span class="line">2：问题所在，深度为64，回溯次数太多，栈中会产生很多方法！</span><br><span class="line">3：记录马下一步位置0-7，哪些可以走</span><br></pre></td></tr></table></figure>

<p>3：优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">贪心算法思路：</span><br><span class="line">如,当马儿接下来有8种方式都可以走，把种方式对应的下一次可以走的方式为1,1,2,3,4,4,4,5（已经进行了非递减排序）</span><br><span class="line">那么下一步直接选择下一步对应的下一步最小的位置进行，减少回溯的次数。</span><br><span class="line"></span><br><span class="line"> //根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数</span><br><span class="line">    public static void sort(ArrayList&lt;Point&gt; ps) &#123;</span><br><span class="line">        ps.sort(new Comparator&lt;Point&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Point o1, Point o2) &#123;</span><br><span class="line">                //获取到o1的下一步的所有位置个数</span><br><span class="line">                int count1 = next(o1).size();</span><br><span class="line">                //获取到o2的下一步的所有位置个数</span><br><span class="line">                int count2 = next(o2).size();</span><br><span class="line">                if (count1 &lt; count2) &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125; else if (count1 == count2) &#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<p>4：代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">核心代码：</span><br><span class="line"> while(!ps.isEmpty()) &#123;</span><br><span class="line">            Point p = ps.remove(0);//取出下一个可以走的位置</span><br><span class="line">            //判断该点是否已经访问过</span><br><span class="line">            if(!visited[p.y * X + p.x]) &#123;//说明还没有访问过</span><br><span class="line">                traversalChessboard(chessboard, p.y, p.x, step + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿是否完成了任务，使用   step 和应该走的步数比较 ，</span><br><span class="line">        //如果没有达到数量，则表示没有完成任务，将整个棋盘置0</span><br><span class="line">        //说明: step &lt; X * Y  成立的情况有两种</span><br><span class="line">        //1. 棋盘到目前位置,仍然没有走完</span><br><span class="line">        //2. 棋盘处于一个回溯过程</span><br><span class="line">        if(step &lt; X * Y &amp;&amp; !finished ) &#123;</span><br><span class="line">            chessboard[row][column] = 0;</span><br><span class="line">            visited[row * X + column] = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            finished = true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">package com.it.hourse;</span><br><span class="line"></span><br><span class="line">import java.awt.Point;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">public class HorseChessboard &#123;</span><br><span class="line"></span><br><span class="line">    private static int X; // 棋盘的列数</span><br><span class="line">    private static int Y; // 棋盘的行数</span><br><span class="line">    //创建一个数组，标记棋盘的各个位置是否被访问过</span><br><span class="line">    private static boolean visited[];</span><br><span class="line">    //使用一个属性，标记是否棋盘的所有位置都被访问</span><br><span class="line">    private static boolean finished; // 如果为true,表示成功</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;骑士周游算法，开始运行~~&quot;);</span><br><span class="line">        //测试骑士周游算法是否正确</span><br><span class="line">        X = 8;</span><br><span class="line">        Y = 8;</span><br><span class="line">        int row = 2; //马儿初始位置的行，从2开始编号</span><br><span class="line">        int column = 2; //马儿初始位置的列，从1开始编号</span><br><span class="line">        //创建棋盘</span><br><span class="line">        int[][] chessboard = new int[X][Y];</span><br><span class="line">        visited = new boolean[X * Y];//初始值都是false</span><br><span class="line">        //测试一下耗时</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        traversalChessboard(chessboard, row - 1, column - 1, 1);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;共耗时: &quot; + (end - start) + &quot; 毫秒&quot;);</span><br><span class="line"></span><br><span class="line">        //输出棋盘的最后情况</span><br><span class="line">        for(int[] rows : chessboard) &#123;</span><br><span class="line">            for(int step: rows) &#123;</span><br><span class="line">                System.out.print(step + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 完成骑士周游问题的算法</span><br><span class="line">     * @param chessboard 棋盘</span><br><span class="line">     * @param row 马儿当前的位置的行 从0开始</span><br><span class="line">     * @param column 马儿当前的位置的列  从0开始</span><br><span class="line">     * @param step 是第几步 ,初始位置就是第1步</span><br><span class="line">     */</span><br><span class="line">    public static void traversalChessboard(int[][] chessboard, int row, int column, int step) &#123;</span><br><span class="line">        chessboard[row][column] = step;</span><br><span class="line">        //row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36</span><br><span class="line">        visited[row * X + column] = true; //标记该位置已经访问</span><br><span class="line">        //获取当前位置可以走的下一个位置的集合</span><br><span class="line">        ArrayList&lt;Point&gt; ps = next(new Point(column, row));</span><br><span class="line">        //对ps进行排序,排序的规则就是对ps的所有的Point对象的下一步的位置的数目，进行非递减排序</span><br><span class="line">        sort(ps);</span><br><span class="line">        //遍历 ps</span><br><span class="line">        while(!ps.isEmpty()) &#123;</span><br><span class="line">            Point p = ps.remove(0);//取出下一个可以走的位置</span><br><span class="line">            //判断该点是否已经访问过</span><br><span class="line">            if(!visited[p.y * X + p.x]) &#123;//说明还没有访问过</span><br><span class="line">                traversalChessboard(chessboard, p.y, p.x, step + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿是否完成了任务，使用   step 和应该走的步数比较 ，</span><br><span class="line">        //如果没有达到数量，则表示没有完成任务，将整个棋盘置0</span><br><span class="line">        //说明: step &lt; X * Y  成立的情况有两种</span><br><span class="line">        //1. 棋盘到目前位置,仍然没有走完</span><br><span class="line">        //2. 棋盘处于一个回溯过程</span><br><span class="line">        if(step &lt; X * Y &amp;&amp; !finished ) &#123;</span><br><span class="line">            chessboard[row][column] = 0;</span><br><span class="line">            visited[row * X + column] = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            finished = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 功能： 根据当前位置(Point对象)，计算马儿还能走哪些位置(Point)，并放入到一个集合中(ArrayList), 最多有8个位置</span><br><span class="line">     * @param curPoint</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static ArrayList&lt;Point&gt; next(Point curPoint) &#123;</span><br><span class="line">        //创建一个ArrayList</span><br><span class="line">        ArrayList&lt;Point&gt; ps = new ArrayList&lt;Point&gt;();</span><br><span class="line">        //创建一个Point</span><br><span class="line">        Point p1 = new Point();</span><br><span class="line">        //表示马儿可以走5这个位置</span><br><span class="line">        if((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y -1) &gt;= 0) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走6这个位置</span><br><span class="line">        if((p1.x = curPoint.x - 1) &gt;=0 &amp;&amp; (p1.y=curPoint.y-2)&gt;=0) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走7这个位置</span><br><span class="line">        if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y - 2) &gt;= 0) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走0这个位置</span><br><span class="line">        if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y - 1) &gt;= 0) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走1这个位置</span><br><span class="line">        if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走2这个位置</span><br><span class="line">        if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走3这个位置</span><br><span class="line">        if ((p1.x = curPoint.x - 1) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走4这个位置</span><br><span class="line">        if ((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        return ps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数</span><br><span class="line">    public static void sort(ArrayList&lt;Point&gt; ps) &#123;</span><br><span class="line">        ps.sort(new Comparator&lt;Point&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Point o1, Point o2) &#123;</span><br><span class="line">                // TODO Auto-generated method stub</span><br><span class="line">                //获取到o1的下一步的所有位置个数</span><br><span class="line">                int count1 = next(o1).size();</span><br><span class="line">                //获取到o2的下一步的所有位置个数</span><br><span class="line">                int count2 = next(o2).size();</span><br><span class="line">                if(count1 &lt; count2) &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125; else if (count1 == count2) &#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

	<div>
  
    ﻿<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>

    

		

    

    


	
    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/24/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E5%9B%BE/" rel="next" title="java数据结构和算法（9）图">
                <i class="fa fa-chevron-left"></i> java数据结构和算法（9）图
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/06/%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E6%80%BB%E7%BB%93/" rel="prev" title="离线数仓-数据采集总结">
                离线数仓-数据采集总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">鄢玉兵</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1：算法"><span class="nav-number">1.</span> <span class="nav-text">1：算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1：二分查找：非递归"><span class="nav-number">1.0.1.</span> <span class="nav-text">1：二分查找：非递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2：分治算法-汉诺塔"><span class="nav-number">1.0.2.</span> <span class="nav-text">2：分治算法-汉诺塔</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3：动态规划算法-背包问题"><span class="nav-number">1.0.3.</span> <span class="nav-text">3：动态规划算法-背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4：KMP算法-字符串匹配问题"><span class="nav-number">1.0.4.</span> <span class="nav-text">4：KMP算法-字符串匹配问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五：贪心算法-集合覆盖问题"><span class="nav-number">1.0.5.</span> <span class="nav-text">五：贪心算法-集合覆盖问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六：普利姆算法-修路问题"><span class="nav-number">1.0.6.</span> <span class="nav-text">六：普利姆算法-修路问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七：克鲁斯卡尔算法-公交站问题"><span class="nav-number">1.0.7.</span> <span class="nav-text">七：克鲁斯卡尔算法-公交站问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八：迪杰斯特拉算法-最短路径问题"><span class="nav-number">1.0.8.</span> <span class="nav-text">八：迪杰斯特拉算法-最短路径问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九：弗洛伊德算法-最短路径"><span class="nav-number">1.0.9.</span> <span class="nav-text">九：弗洛伊德算法-最短路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十：马踏棋盘算法-骑士周游"><span class="nav-number">1.0.10.</span> <span class="nav-text">十：马踏棋盘算法-骑士周游</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">鄢玉兵</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

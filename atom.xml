<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鄢玉兵的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yanyubing.xyz/"/>
  <updated>2019-12-01T11:54:33.087Z</updated>
  <id>https://yanyubing.xyz/</id>
  
  <author>
    <name>鄢玉兵</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java数据结构和算法（五）哈希表</title>
    <link href="https://yanyubing.xyz/2019/12/01/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://yanyubing.xyz/2019/12/01/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2019-12-01T11:54:33.087Z</published>
    <updated>2019-12-01T11:54:33.087Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（五）查找</title>
    <link href="https://yanyubing.xyz/2019/12/01/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E6%9F%A5%E6%89%BE/"/>
    <id>https://yanyubing.xyz/2019/12/01/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E6%9F%A5%E6%89%BE/</id>
    <published>2019-12-01T11:22:27.801Z</published>
    <updated>2019-12-01T14:18:02.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：线性查找"><a href="#1：线性查找" class="headerlink" title="1：线性查找"></a>1：线性查找</h1><p>1：线性查找思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1：遍历数组，逐一匹配，相等即返回</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">public class SeqSearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] = &#123;1, 9, 11, -1, 34, 89&#125;;</span><br><span class="line">        int value = 9;</span><br><span class="line">        System.out.println(seqSearch(arr, value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int seqSearch(int[] arr, int value) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (value == arr[i]) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2：二分查找"><a href="#2：二分查找" class="headerlink" title="2：二分查找"></a>2：二分查找</h3><p>1：二分查找思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：要求数组有序（假设从下到大排序）</span><br><span class="line">2：首先确定该数组的中间的下标 mid=(left+right)/2</span><br><span class="line">3：arr[mid]与要查找的数val比较</span><br><span class="line">4：如果arr[mid]&gt;val，则表示val在arr[mid]左边，再次移动left和rigth继续查找</span><br><span class="line">5：相反arr[mid]&lt;val，同理</span><br><span class="line">6：arr[mid]==val则直接返回</span><br><span class="line">7：递归结束条件，rigth-left==1</span><br></pre></td></tr></table></figure><p>2：代码实现（1）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//该代码只能找到只有一个匹配的值的索引</span><br><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">public class BinarySearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] = &#123;1, 8, 10, 89, 1000, 1234&#125;;</span><br><span class="line">        int res = binarySearch(arr, 0, arr.length - 1, 10);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int binarySearch(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line">        if (right - left == 0) &#123;</span><br><span class="line">            return -1;//说明递归已经完成，没找到</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        if (arr[mid] &gt; findVal) &#123;//说明该值在左标</span><br><span class="line">            return binarySearch(arr, left, mid - 1, findVal);</span><br><span class="line">        &#125;</span><br><span class="line">        if (arr[mid] &lt; findVal) &#123;//说明该值在右标</span><br><span class="line">            return binarySearch(arr, mid + 1, right, findVal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mid;//最终找到的结果数据是这句话</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3：代码实现（二）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">//注意：使用二分查找的前提是 该数组是有序的.</span><br><span class="line">public class BinarySearch &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;;</span><br><span class="line">int arr[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 , 11, 12, 13,14,15,16,17,18,19,20 &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//int resIndex = binarySearch(arr, 0, arr.length - 1, 1000);</span><br><span class="line">//System.out.println(&quot;resIndex=&quot; + resIndex);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; resIndexList = binarySearch2(arr, 0, arr.length - 1, 1);</span><br><span class="line">System.out.println(&quot;resIndexList=&quot; + resIndexList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 二分查找算法</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param arr</span><br><span class="line"> *            数组</span><br><span class="line"> * @param left</span><br><span class="line"> *            左边的索引</span><br><span class="line"> * @param right</span><br><span class="line"> *            右边的索引</span><br><span class="line"> * @param findVal</span><br><span class="line"> *            要查找的值</span><br><span class="line"> * @return 如果找到就返回下标，如果没有找到，就返回 -1</span><br><span class="line"> */</span><br><span class="line">public static int binarySearch(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span><br><span class="line">if (left &gt; right) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (left + right) / 2;</span><br><span class="line">int midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">if (findVal &gt; midVal) &#123; // 向 右递归</span><br><span class="line">return binarySearch(arr, mid + 1, right, findVal);</span><br><span class="line">&#125; else if (findVal &lt; midVal) &#123; // 向左递归</span><br><span class="line">return binarySearch(arr, left, mid - 1, findVal);</span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//思考题:</span><br><span class="line">/*</span><br><span class="line"> *  &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中，</span><br><span class="line"> * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</span><br><span class="line"> * </span><br><span class="line"> * 思路分析</span><br><span class="line"> * 1. 在找到mid 索引值，不要马上返回</span><br><span class="line"> * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line"> * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line"> * 4. 将Arraylist返回</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public static List&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;hello~&quot;);</span><br><span class="line">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span><br><span class="line">if (left &gt; right) &#123;</span><br><span class="line">return new ArrayList&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line">int mid = (left + right) / 2;</span><br><span class="line">int midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">if (findVal &gt; midVal) &#123; // 向 右递归</span><br><span class="line">return binarySearch2(arr, mid + 1, right, findVal);</span><br><span class="line">&#125; else if (findVal &lt; midVal) &#123; // 向左递归</span><br><span class="line">return binarySearch2(arr, left, mid - 1, findVal);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// * 思路分析</span><br><span class="line">// * 1. 在找到mid 索引值，不要马上返回</span><br><span class="line">// * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line">// * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line">// * 4. 将Arraylist返回</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; resIndexlist = new ArrayList&lt;Integer&gt;();</span><br><span class="line">//向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line">int temp = mid - 1;</span><br><span class="line">while(true) &#123;</span><br><span class="line">if (temp &lt; 0 || arr[temp] != findVal) &#123;//退出</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//否则，就temp 放入到 resIndexlist</span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp -= 1; //temp左移</span><br><span class="line">&#125;</span><br><span class="line">resIndexlist.add(mid);  //</span><br><span class="line"></span><br><span class="line">//向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line">temp = mid + 1;</span><br><span class="line">while(true) &#123;</span><br><span class="line">if (temp &gt; arr.length - 1 || arr[temp] != findVal) &#123;//退出</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//否则，就temp 放入到 resIndexlist</span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp += 1; //temp右移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return resIndexlist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三：插值查找"><a href="#三：插值查找" class="headerlink" title="三：插值查找"></a>三：插值查找</h3><p>1：插值查找思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：插值查找和二分查找思想是一样，只是中值的确定由原来的二等分改变成了等比值，</span><br><span class="line">例如：mid(索引)=left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left])</span><br><span class="line">2:相当于更加适合线性的数组</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class InsertValueSearch &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">//int [] arr = new int[100];</span><br><span class="line">//for(int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">//arr[i] = i + 1;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;;</span><br><span class="line"></span><br><span class="line">int index = insertValueSearch(arr, 0, arr.length - 1, 1234);</span><br><span class="line">//int index = binarySearch(arr, 0, arr.length, 1);</span><br><span class="line">System.out.println(&quot;index = &quot; + index);</span><br><span class="line"></span><br><span class="line">//System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int binarySearch(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line">System.out.println(&quot;二分查找被调用~&quot;);</span><br><span class="line">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span><br><span class="line">if (left &gt; right) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (left + right) / 2;</span><br><span class="line">int midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">if (findVal &gt; midVal) &#123; // 向 右递归</span><br><span class="line">return binarySearch(arr, mid + 1, right, findVal);</span><br><span class="line">&#125; else if (findVal &lt; midVal) &#123; // 向左递归</span><br><span class="line">return binarySearch(arr, left, mid - 1, findVal);</span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写插值查找算法</span><br><span class="line">//说明：插值查找算法，也要求数组是有序的</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param arr 数组</span><br><span class="line"> * @param left 左边索引</span><br><span class="line"> * @param right 右边索引</span><br><span class="line"> * @param findVal 查找值</span><br><span class="line"> * @return 如果找到，就返回对应的下标，如果没有找到，返回-1</span><br><span class="line"> */</span><br><span class="line">public static int insertValueSearch(int[] arr, int left, int right, int findVal) &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(&quot;插值查找次数~~&quot;);</span><br><span class="line"></span><br><span class="line">//注意：findVal &lt; arr[0]  和  findVal &gt; arr[arr.length - 1] 必须需要</span><br><span class="line">//否则我们得到的 mid 可能越界</span><br><span class="line">if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1]) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 求出mid, 自适应</span><br><span class="line">int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">int midVal = arr[mid];</span><br><span class="line">if (findVal &gt; midVal) &#123; // 说明应该向右边递归</span><br><span class="line">return insertValueSearch(arr, mid + 1, right, findVal);</span><br><span class="line">&#125; else if (findVal &lt; midVal) &#123; // 说明向左递归查找</span><br><span class="line">return insertValueSearch(arr, left, mid - 1, findVal);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四：斐波那契查找"><a href="#四：斐波那契查找" class="headerlink" title="四：斐波那契查找"></a>四：斐波那契查找</h3><p>1：斐波那契查找思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：斐波那契查找和二分查找也类似，也是在于中值的mid的确定，mid依赖斐波那契数组来实现</span><br><span class="line">2：斐波那契数列1,1,2,3,5,8,13,21,34,55,89...，对应的是取索引需求</span><br><span class="line">3：例如元素组元素个数为10个，因为斐波那契中只有8,13，所有需要创建临时数组长度为13，拷贝原数组，剩余元素用arr[9]填充。</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class FibonacciSearch &#123;</span><br><span class="line"></span><br><span class="line">public static int maxSize = 20;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int [] arr = &#123;1,8, 10, 89, 1000, 1234&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;index=&quot; + fibSearch(arr, 189));// 0</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span><br><span class="line">//非递归方法得到一个斐波那契数列</span><br><span class="line">public static int[] fib() &#123;</span><br><span class="line">int[] f = new int[maxSize];</span><br><span class="line">f[0] = 1;</span><br><span class="line">f[1] = 1;</span><br><span class="line">for (int i = 2; i &lt; maxSize; i++) &#123;</span><br><span class="line">f[i] = f[i - 1] + f[i - 2];</span><br><span class="line">&#125;</span><br><span class="line">return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写斐波那契查找算法</span><br><span class="line">//使用非递归的方式编写算法</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param a  数组</span><br><span class="line"> * @param key 我们需要查找的关键码(值)</span><br><span class="line"> * @return 返回对应的下标，如果没有-1</span><br><span class="line"> */</span><br><span class="line">public static int fibSearch(int[] a, int key) &#123;</span><br><span class="line">int low = 0;</span><br><span class="line">int high = a.length - 1;</span><br><span class="line">int k = 0; //表示斐波那契分割数值的下标</span><br><span class="line">int mid = 0; //存放mid值</span><br><span class="line">int f[] = fib(); //获取到斐波那契数列</span><br><span class="line">//获取到斐波那契分割数值的下标</span><br><span class="line">while(high &gt; f[k] - 1) &#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span><br><span class="line">//不足的部分会使用0填充</span><br><span class="line">int[] temp = Arrays.copyOf(a, f[k]);</span><br><span class="line">//实际上需求使用a数组最后的数填充 temp</span><br><span class="line">//举例:</span><br><span class="line">//temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125;  =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125;</span><br><span class="line">for(int i = high + 1; i &lt; temp.length; i++) &#123;</span><br><span class="line">temp[i] = a[high];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用while来循环处理，找到我们的数 key</span><br><span class="line">while (low &lt;= high) &#123; // 只要这个条件满足，就可以找</span><br><span class="line">mid = low + f[k - 1] - 1;</span><br><span class="line">if(key &lt; temp[mid]) &#123; //我们应该继续向数组的前面查找(左边)</span><br><span class="line">high = mid - 1;</span><br><span class="line">//为甚是 k--</span><br><span class="line">//说明</span><br><span class="line">//1. 全部元素 = 前面的元素 + 后边元素</span><br><span class="line">//2. f[k] = f[k-1] + f[k-2]</span><br><span class="line">//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]</span><br><span class="line">//即 在 f[k-1] 的前面继续查找 k--</span><br><span class="line">//即下次循环 mid = f[k-1-1]-1</span><br><span class="line">k--;</span><br><span class="line">&#125; else if ( key &gt; temp[mid]) &#123; // 我们应该继续向数组的后面查找(右边)</span><br><span class="line">low = mid + 1;</span><br><span class="line">//为什么是k -=2</span><br><span class="line">//说明</span><br><span class="line">//1. 全部元素 = 前面的元素 + 后边元素</span><br><span class="line">//2. f[k] = f[k-1] + f[k-2]</span><br><span class="line">//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]</span><br><span class="line">//4. 即在f[k-2] 的前面进行查找 k -=2</span><br><span class="line">//5. 即下次循环 mid = f[k - 1 - 2] - 1</span><br><span class="line">k -= 2;</span><br><span class="line">&#125; else &#123; //找到</span><br><span class="line">//需要确定，返回的是哪个下标</span><br><span class="line">if(mid &lt;= high) &#123;</span><br><span class="line">return mid;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return high;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：线性查找&quot;&gt;&lt;a href=&quot;#1：线性查找&quot; class=&quot;headerlink&quot; title=&quot;1：线性查找&quot;&gt;&lt;/a&gt;1：线性查找&lt;/h1&gt;&lt;p&gt;1：线性查找思路&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法(四)排序算法</title>
    <link href="https://yanyubing.xyz/2019/11/28/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(%E5%9B%9B)%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://yanyubing.xyz/2019/11/28/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(%E5%9B%9B)%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2019-11-28T08:07:33.861Z</published>
    <updated>2019-11-29T13:25:31.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：排序"><a href="#一：排序" class="headerlink" title="一：排序"></a>一：排序</h1><h3 id="1：排序的分类"><a href="#1：排序的分类" class="headerlink" title="1：排序的分类"></a>1：排序的分类</h3><p>1：内部排序（使用内存）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：插入排序：直接插入排序，希尔排序</span><br><span class="line">2：选择排序：简单选择排序，堆排序</span><br><span class="line">3：交换排序：冒泡排序，快速排序</span><br><span class="line">4：归并排序</span><br><span class="line">5：基数排序</span><br></pre></td></tr></table></figure><p>2：外部排序：数据量过大的情况</p><h3 id="2：算法的时间复杂度"><a href="#2：算法的时间复杂度" class="headerlink" title="2：算法的时间复杂度"></a>2：算法的时间复杂度</h3><p>1：事后统计法：比较依赖机器性能</p><p>2：事前估算的方法：分析</p><p>3：时间频度：一个算法话费的时间与算法中语句执行次数成正比，哪个算法中语句执行次数多，它花费的时间就多</p><p>4：时间频度简化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：忽略常数项</span><br><span class="line">2：忽略低次项</span><br></pre></td></tr></table></figure><p>5：时间复杂度(又叫渐进时间复杂度)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：忽略低阶项</span><br><span class="line">2：取出最高阶系数</span><br><span class="line">3：只有常数阶O(1)</span><br></pre></td></tr></table></figure><p>6：常见的时间复杂度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1：常数阶O(1)</span><br><span class="line">2：对数阶O(log2n)</span><br><span class="line">3：线性阶O(n)</span><br><span class="line">4：线性对数阶O(nlog2n)</span><br><span class="line">5：平方阶O(n^2)</span><br><span class="line">6：立方阶O(n^3)</span><br><span class="line">7：k次方阶O(n^k)</span><br><span class="line">8：指数阶O(2^n)</span><br><span class="line">时间复杂度从上到下依次变劣！</span><br></pre></td></tr></table></figure><p>7：对数阶</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">  while (i &lt; n) &#123;</span><br><span class="line">   i = i * 2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>8：平均时间复杂度和最坏时间复杂度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间</span><br><span class="line">2：一般讨论的时间复杂度是最坏时间复杂度</span><br><span class="line">3：平均时间复杂度和最坏时间复杂度是否一致，和算法有关</span><br></pre></td></tr></table></figure><p>9：常见排序算法的时间复杂度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">排序方法时间复杂度（平均）时间复杂度（最坏)时间复杂度（最好)空间复杂度稳定性 复杂性</span><br><span class="line">直接插入排序  O(n2)O(n2)O(n)   O(1)稳定 简单</span><br><span class="line">希尔排序   O(nlog2n) O(n2) O(n)O(1)不稳定 较复杂</span><br><span class="line">直接选择排序  O(n2)    O(n2)O(n2)   O(1)   不稳定简单</span><br><span class="line">堆排序     O(nlog2n)      O(nlog2n)      O(nlog2n)         O(1) 不稳定  较复杂</span><br><span class="line">冒泡排序   O(n2) O(n2) O(n)O(1) 稳定  简单</span><br><span class="line">快速排序   O(nlog2n) O(n2) O(nlog2n)  O(nlog2n) 不稳定 较复杂</span><br><span class="line">归并排序   O(nlog2n)     O(nlog2n)     O(nlog2n)        O(n) 稳定  较复杂</span><br><span class="line">基数排序   O(d(n+r))    O(d(n+r))     O(d(n+r))      O(n+r)   稳定  较复杂</span><br></pre></td></tr></table></figure><h3 id="三：冒泡排序"><a href="#三：冒泡排序" class="headerlink" title="三：冒泡排序"></a>三：冒泡排序</h3><p>1：冒泡排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过对待排序序列从前向后，下标较小的元素开始，依次比较相邻元素的值；若发现逆序则交换，使值较大的元素逐渐向前移动到后部，就像水滴的气泡一样逐渐向上冒。</span><br><span class="line">第一次遍历完成就实现了最后一个元素是最大值，</span><br><span class="line">第二次遍历完成就实现了最后一个元素是倒数第二大值，</span><br><span class="line">...</span><br><span class="line">最多进行数组长度-1次遍历完成</span><br><span class="line">优化：在某趟排序中，没有发生一次排序，则可以提前完成排序。</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序   O(n2) O(n2) O(n)O(1) 稳定  简单</span><br><span class="line">优化之后：80000数据最终花费时间约10s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //      int arr[] = &#123;3, 9, -1, 10, 20&#125;;</span><br><span class="line">        //    bubbleSort(arr);</span><br><span class="line">        //测试冒泡排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[80000];</span><br><span class="line">        for (int i = 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 8000000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start =System.currentTimeMillis();</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        long end =System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot;+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //排序方式</span><br><span class="line">    public static void bubbleSort(int[] arr) &#123;</span><br><span class="line">        boolean flag = false;//优化：定义标志位，判断是否交换过</span><br><span class="line">        int tmp = 0;//临时变量，用于交换</span><br><span class="line">        for (int j = 0; j &lt; arr.length - 1; j++) &#123;</span><br><span class="line">            //一次内层循环完成最后一个数的确定</span><br><span class="line">            for (int i = 0; i &lt; arr.length - j - 1; i++) &#123;</span><br><span class="line">                //满足交换条件</span><br><span class="line">                if (arr[i] &gt; arr[i + 1]) &#123;</span><br><span class="line">                    tmp = arr[i + 1];</span><br><span class="line">                    arr[i + 1] = arr[i];</span><br><span class="line">                    arr[i] = tmp;</span><br><span class="line">                    flag = true;//交换之后就置为true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //一次循环结束，flag如果还是false，证明上次循环未交换，则证明已经有序，提前退出</span><br><span class="line">            if (!flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //重置flag，否则flag变为true之后无法起到再次验证的效果</span><br><span class="line">                flag = false;</span><br><span class="line">            &#125;</span><br><span class="line">//            System.out.printf(&quot;第%d趟排序之后\n&quot;, (j + 1));</span><br><span class="line">//            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">//        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四：选择排序"><a href="#四：选择排序" class="headerlink" title="四：选择排序"></a>四：选择排序</h3><p>1：选择排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：第一次遍历(从arr[0]-arr[n-1])完成之后找到最小值，然后与arr[0]交换</span><br><span class="line">2：第二次遍历(从arr[1]-arr[n-1])完成之后找到这里面的最小值，然后与arr[1]交换</span><br><span class="line">...</span><br><span class="line">3：经过n-1次遍历，最终完成排序</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接选择排序  O(n2)    O(n2)O(n2)   O(1)   不稳定简单</span><br><span class="line">时间花费：80000数据最终花费时间约2s，</span><br><span class="line">时间较冒泡排序短：循环语句少，交换次数少</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class SelectSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        int[] arr = &#123;101, 34, 119, 1&#125;;</span><br><span class="line">//        selectSort(arr);</span><br><span class="line">//        System.out.println(Arrays.toString(arr));</span><br><span class="line">        //测试冒泡排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[80000];</span><br><span class="line">        for (int i = 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 8000000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        selectSort(arr);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //选择排序</span><br><span class="line">    public static void selectSort(int[] arr) &#123;</span><br><span class="line">        //逐步推到</span><br><span class="line">        //原始数组 101，34，119，1</span><br><span class="line">        //第一轮 1，34，119，101</span><br><span class="line">        int min = arr[0];</span><br><span class="line">        int minIndex = 0;</span><br><span class="line">        int temp = 0;//用于交换</span><br><span class="line">        for (int j = 0; j &lt; arr.length; j++) &#123;//外层循环表示第几轮循环</span><br><span class="line">            minIndex = j;//最小值的索引置为j，因为每次内层循环从J开始</span><br><span class="line">            min = arr[j];//最小值置为arr[j]，因为每次内层循环从J开始</span><br><span class="line">            for (int i = j + 1; i &lt; arr.length; i++) &#123;//内层表示当前轮循环的遍历</span><br><span class="line">                if (arr[i] &lt;= min) &#123;//满足条件</span><br><span class="line">                    min = arr[i];//</span><br><span class="line">                    minIndex = i;//记录最小值的索引</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //一次循环之后找到了最小值的所有minIndex,arr[0]交换</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五：插入排序一：直接插入排序"><a href="#五：插入排序一：直接插入排序" class="headerlink" title="五：插入排序一：直接插入排序"></a>五：插入排序一：直接插入排序</h3><p>1：插入排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1：把n个待排序的元素看成一张有序表和一张无序表</span><br><span class="line">2：开始有序表中只包含一个元素，即arr[0]</span><br><span class="line">3:无序表中包含n-1个元素</span><br><span class="line">4：排序过程中，每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序码进行比较，将它插入到有序表的适当位置，使之成为新的有序表</span><br><span class="line">5：具体的比较过程</span><br><span class="line">例如：arr[3]为无序表的第一个元素，则将arr[3]与arr[2]进行比较，如果arr[2]&gt;arr[3]则将arr[2]后移一位；再将arr[3]与arr[1]比较，如果arr[3]&gt;arr[1]，则将arr[3]放在arr[2]的位置</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接插入排序  O(n2)O(n2)O(n)   O(1)稳定 简单</span><br><span class="line">时间花费：80000数据最终花费时间约1s，</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class InsertSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;   //测试冒泡排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[80000];</span><br><span class="line">        for (int i = 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 8000000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start =System.currentTimeMillis();</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        long end =System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot;+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入排序</span><br><span class="line">    public static void insertSort(int[] arr) &#123;</span><br><span class="line">        //逐步推导</span><br><span class="line">        //第一轮&#123;101，34，119，1&#125;=&gt;&#123;34,101,119,1&#125;</span><br><span class="line">        //定义待插入数</span><br><span class="line">        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            //每次待插入的元素往后移</span><br><span class="line">            int insertVal = arr[i];</span><br><span class="line">            //需要一个变量记录待插入的元素，不能使用arr[i]来记录，因为值可能会改变</span><br><span class="line">            //每次循环就把待插入的元素索引n与前n个元素从后往前比较</span><br><span class="line">            for (int j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">                if (insertVal &lt;= arr[j]) &#123;</span><br><span class="line">                    //将arr[j]后移</span><br><span class="line">                    arr[j + 1] = arr[j];</span><br><span class="line">                    if (j == 0) &#123;</span><br><span class="line">                        arr[j] = insertVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (insertVal &gt; arr[j]) &#123;</span><br><span class="line">                    //代表可以插入！直接将insertVal放在arr[j]的后面，注意此时需要结束当前内层循环</span><br><span class="line">                    arr[j + 1] = insertVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六：插入排序二：希尔排序"><a href="#六：插入排序二：希尔排序" class="headerlink" title="六：插入排序二：希尔排序"></a>六：插入排序二：希尔排序</h3><p>1：希尔排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：设待排序元素序列有n个元素，首先取一个整数increment（n/2取整）作为间隔将全部元素分为increment个子序列，所有距离为increment的元素放在同一个子序列中，在每一个子序列中分别实行直接插入排序。然后缩小间隔increment（上述的然后缩小间隔increment/2），重复上述子序列划分和排序工作。直到最后取increment=1，将所有元素放在同一个子序列中排序为止。</span><br><span class="line">2：由于开始时，increment的取值较大，每个子序列中的元素较少，排序速度较快，到排序后期increment取值逐渐变小，子序列中元素个数逐渐增多，但由于前面工作的基础，大多数元素已经基本有序，所以排序速度仍然很快。</span><br><span class="line">3：困难点是：步长x与循环轮数k之间的关系并且和arr.length的关系，以及每次插入排序尽头的判断</span><br><span class="line">4：希尔排序的关键在于提前通过步长把N组数据已经变成有序了，最后当步长=1的时候才是最终的方式，也就是插入排序！</span><br><span class="line">5：可以把希尔排序方式理解成一种化繁为简的思想，具体内部用哪种排序方式自己定（例如冒泡：交换，或者插入）</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">希尔排序   O(nlog2n) O(n2) O(n)O(1)不稳定 较复杂</span><br><span class="line">测试80000条数据花费60ms左右</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import sun.rmi.runtime.Log;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class ShellSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        int[] arr = &#123;6, 2314, 314, 234134, 3145132, 8, 9, 1, 7, 2, 1273, 4, 5&#125;;</span><br><span class="line">//        System.out.println(&quot;原始数据是：&quot; + Arrays.toString(arr));</span><br><span class="line">//        shellSort(arr);</span><br><span class="line">//        System.out.println(Arrays.toString(arr));</span><br><span class="line">        //测试希尔排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[80000];</span><br><span class="line">        for (int i = 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 800000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot; + (end - start));</span><br><span class="line">//        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用逐步推导</span><br><span class="line">    public static void shellSort(int[] arr) &#123;</span><br><span class="line">        //希尔排序的第一轮排序</span><br><span class="line">        //因为第一轮排序，是将10个数据分成了5组</span><br><span class="line">        //三层，第一层表示一共要进行多少轮的分组  9个数，</span><br><span class="line">        // 则第一轮分组为 1，5，9   2，6   3，7   4，8</span><br><span class="line">        //k为插入排序的轮数，</span><br><span class="line">        int kMax = (int) (Math.log(arr.length)/Math.log(2));//表示需要进行插入排序的轮数</span><br><span class="line">        //每轮的步长为1- arr.length/2   2-arr.length/2/2  3-arr.length/2/2/2</span><br><span class="line">        System.out.println(&quot;插入排序的轮数：&quot;+kMax);</span><br><span class="line">        for (int k = 1; k &lt;= kMax; k++) &#123;</span><br><span class="line">            int x = (int) (arr.length / Math.pow(2, k));//步长</span><br><span class="line">            System.out.printf(&quot;第%d轮的步长:%d\n&quot;,k,x);</span><br><span class="line">                for (int i = x; i &lt; arr.length; i++) &#123;//从步长x开始</span><br><span class="line">                    //每次待插入的元素往后移</span><br><span class="line">                    int insertVal = arr[i];</span><br><span class="line">                    //需要一个变量记录待插入的元素，不能使用arr[i]来记录，因为值可能会改变</span><br><span class="line">                    //每次循环就把待插入的元素索引n与前n/x个元素从后往前比较</span><br><span class="line">                    for (int j = i - x; j &gt;= i % x; j -= x) &#123;</span><br><span class="line">                        //每次只与前面步长差为x的比较，注意此时的左边尽头是i对步长取模</span><br><span class="line">                        if (insertVal &lt;= arr[j]) &#123;</span><br><span class="line">                            //将arr[j]后移</span><br><span class="line">                            arr[j + x] = arr[j];</span><br><span class="line">                            if (j == i % x) &#123;//判断已经到头了</span><br><span class="line">                                arr[j] = insertVal;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (insertVal &gt; arr[j]) &#123;</span><br><span class="line">//代表可以插入！直接将insertVal放在arr[j]的后面，注意此时需要结束当前内层循环</span><br><span class="line">                            arr[j + x] = insertVal;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">//                System.out.printf(&quot;第%d轮的步长是%d：&quot;, k, x);</span><br><span class="line">//                System.out.printf(&quot;第%d轮的排序是：&quot;, k);</span><br><span class="line">//                System.out.println(Arrays.toString(arr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="七：快速排序"><a href="#七：快速排序" class="headerlink" title="七：快速排序"></a>七：快速排序</h3><p>1：快速排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：通过一趟排序将要排序的数据分割成独立的两部分，基准值M=arr[(indexStart+indexEnd)/2]自己确定，其中一部分的所有数据都比另外一部分的所有数据小</span><br><span class="line">2：然后再按照此方法对这两部分数据分别进行快速排序</span><br><span class="line">3：整个排序过程可以递归进行，以此达到整个数据变成有序序列，递归的尽头是每个部分中只有一个元素</span><br><span class="line">4：具体的交换过程是一个方法（），左边索引indexStart向右移动，右边所有indexEnd向左移动；当arr[indexStart]&gt;M(基准值)&amp;&amp;arr[indexEnd]&lt;M时，进行交换；这样左边的所有元素就小于了基准值，右边的所有元素大于基准值,方法的参参数是数组，左索引值，右索引值</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class QuickSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//int[] arr = &#123;-9,78,0,23,-567,70, -1,900, 4561&#125;;</span><br><span class="line"></span><br><span class="line">//测试快排的执行速度</span><br><span class="line">// 创建要给80000个的随机的数组</span><br><span class="line">int[] arr = new int[8000000];</span><br><span class="line">for (int i = 0; i &lt; 8000000; i++) &#123;</span><br><span class="line">arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;排序前&quot;);</span><br><span class="line">Date data1 = new Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(&quot;排序前的时间是=&quot; + date1Str);</span><br><span class="line"></span><br><span class="line">quickSort(arr, 0, arr.length-1);</span><br><span class="line"></span><br><span class="line">Date data2 = new Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(&quot;排序前的时间是=&quot; + date2Str);</span><br><span class="line">//System.out.println(&quot;arr=&quot; + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void quickSort(int[] arr,int left, int right) &#123;</span><br><span class="line">int l = left; //左下标</span><br><span class="line">int r = right; //右下标</span><br><span class="line">//pivot 中轴值</span><br><span class="line">int pivot = arr[(left + right) / 2];</span><br><span class="line">int temp = 0; //临时变量，作为交换时使用</span><br><span class="line">//while循环的目的是让比pivot 值小放到左边</span><br><span class="line">//比pivot 值大放到右边</span><br><span class="line">while( l &lt; r) &#123;</span><br><span class="line">//在pivot的左边一直找,找到大于等于pivot值,才退出</span><br><span class="line">while( arr[l] &lt; pivot) &#123;</span><br><span class="line">l += 1;</span><br><span class="line">&#125;</span><br><span class="line">//在pivot的右边一直找,找到小于等于pivot值,才退出</span><br><span class="line">while(arr[r] &gt; pivot) &#123;</span><br><span class="line">r -= 1;</span><br><span class="line">&#125;</span><br><span class="line">//如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是</span><br><span class="line">//小于等于pivot值，右边全部是大于等于pivot值</span><br><span class="line">if( l &gt;= r) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//交换</span><br><span class="line">temp = arr[l];</span><br><span class="line">arr[l] = arr[r];</span><br><span class="line">arr[r] = temp;</span><br><span class="line"></span><br><span class="line">//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移</span><br><span class="line">if(arr[l] == pivot) &#123;</span><br><span class="line">r -= 1;</span><br><span class="line">&#125;</span><br><span class="line">//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移</span><br><span class="line">if(arr[r] == pivot) &#123;</span><br><span class="line">l += 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span><br><span class="line">if (l == r) &#123;</span><br><span class="line">l += 1;</span><br><span class="line">r -= 1;</span><br><span class="line">&#125;</span><br><span class="line">//向左递归</span><br><span class="line">if(left &lt; r) &#123;</span><br><span class="line">quickSort(arr, left, r);</span><br><span class="line">&#125;</span><br><span class="line">//向右递归</span><br><span class="line">if(right &gt; l) &#123;</span><br><span class="line">quickSort(arr, l, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八：基数排序：桶排序"><a href="#八：基数排序：桶排序" class="headerlink" title="八：基数排序：桶排序"></a>八：基数排序：桶排序</h3><p>1：基数排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基数排序第i趟将待排数组里的每个数的i位数放到tempj（j=1-10）队列中，然后再从这十个队列中取出数据，重新放到原数组里，直到i大于待排数的最大位数。</span><br><span class="line">1.数组里的数最大位数是n位，就需要排n趟，例如数组里最大的数是3位数，则需要排3趟。</span><br><span class="line">2.若数组里共有m个数，则需要十个长度为m的数组tempj（j=0-9）用来暂存i位上数为j的数，例如，第1趟，各位数为0的会被分配到temp0数组里，各位数为1的会被分配到temp1数组里......</span><br><span class="line">3.分配结束后，再依次从tempj数组中取出数据，遵循先进先进原则，例如对数组&#123;1，11，2，44，4&#125;，进行第1趟分配后，temp1=&#123;1,11&#125;，temp2=&#123;2&#125;，temp4=&#123;44，4&#125;，依次取出元素后&#123;1，11，2，44，4&#125;，第一趟结束</span><br><span class="line">4.循环到n趟后结束，排序完成</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基数排序   O(d(n+r))    O(d(n+r))     O(d(n+r))      O(n+r)   稳定  较复杂</span><br><span class="line">80000数据耗时：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class RadixSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] = &#123; 53, 3, 542, 748, 14, 214&#125;;</span><br><span class="line"></span><br><span class="line">        // 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G </span><br><span class="line">//int[] arr = new int[8000000];</span><br><span class="line">//for (int i = 0; i &lt; 8000000; i++) &#123;</span><br><span class="line">//arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span><br><span class="line">//&#125;</span><br><span class="line">        System.out.println(&quot;排序前&quot;);</span><br><span class="line">        Date data1 = new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">        System.out.println(&quot;排序前的时间是=&quot; + date1Str);</span><br><span class="line"></span><br><span class="line">        radixSort(arr);</span><br><span class="line"></span><br><span class="line">        Date data2 = new Date();</span><br><span class="line">        String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">        System.out.println(&quot;排序前的时间是=&quot; + date2Str);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;基数排序后 &quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //基数排序方法</span><br><span class="line">    public static void radixSort(int[] arr) &#123;</span><br><span class="line"></span><br><span class="line">        //根据前面的推导过程，我们可以得到最终的基数排序代码</span><br><span class="line"></span><br><span class="line">        //1. 得到数组中最大的数的位数</span><br><span class="line">        int max = arr[0]; //假设第一数就是最大数</span><br><span class="line">        for(int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //得到最大数是几位数</span><br><span class="line">        int maxLength = (max + &quot;&quot;).length();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span><br><span class="line">        //说明</span><br><span class="line">        //1. 二维数组包含10个一维数组</span><br><span class="line">        //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span><br><span class="line">        //3. 名明确，基数排序是使用空间换时间的经典算法</span><br><span class="line">        int[][] bucket = new int[10][arr.length];</span><br><span class="line"></span><br><span class="line">        //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span><br><span class="line">        //可以这里理解</span><br><span class="line">        //比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span><br><span class="line">        int[] bucketElementCounts = new int[10];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //这里我们使用循环将代码处理</span><br><span class="line"></span><br><span class="line">        for(int i = 0 , n = 1; i &lt; maxLength; i++, n *= 10) &#123;</span><br><span class="line">            //(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span><br><span class="line">            for(int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">                //取出每个元素的对应位的值</span><br><span class="line">                int digitOfElement = arr[j] / n % 10;</span><br><span class="line">                //放入到对应的桶中</span><br><span class="line">                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">                bucketElementCounts[digitOfElement]++;</span><br><span class="line">            &#125;</span><br><span class="line">            //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">            int index = 0;</span><br><span class="line">            //遍历每一桶，并将桶中是数据，放入到原数组</span><br><span class="line">            for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">                //如果桶中，有数据，我们才放入到原数组</span><br><span class="line">                if(bucketElementCounts[k] != 0) &#123;</span><br><span class="line">                    //循环该桶即第k个桶(即第k个一维数组), 放入</span><br><span class="line">                    for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                        //取出元素放入到arr</span><br><span class="line">                        arr[index++] = bucket[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span><br><span class="line">                bucketElementCounts[k] = 0;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            //System.out.println(&quot;第&quot;+(i+1)+&quot;轮，对个位的排序处理 arr =&quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">//第1轮(针对每个元素的个位进行排序处理)</span><br><span class="line">for(int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">//取出每个元素的个位的值</span><br><span class="line">int digitOfElement = arr[j] / 1 % 10;</span><br><span class="line">//放入到对应的桶中</span><br><span class="line">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">bucketElementCounts[digitOfElement]++;</span><br><span class="line">&#125;</span><br><span class="line">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">int index = 0;</span><br><span class="line">//遍历每一桶，并将桶中是数据，放入到原数组</span><br><span class="line">for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">//如果桶中，有数据，我们才放入到原数组</span><br><span class="line">if(bucketElementCounts[k] != 0) &#123;</span><br><span class="line">//循环该桶即第k个桶(即第k个一维数组), 放入</span><br><span class="line">for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">//取出元素放入到arr</span><br><span class="line">arr[index++] = bucket[k][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//第l轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span><br><span class="line">bucketElementCounts[k] = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;第1轮，对个位的排序处理 arr =&quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//==========================================</span><br><span class="line"></span><br><span class="line">//第2轮(针对每个元素的十位进行排序处理)</span><br><span class="line">for (int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">// 取出每个元素的十位的值</span><br><span class="line">int digitOfElement = arr[j] / 10  % 10; //748 / 10 =&gt; 74 % 10 =&gt; 4</span><br><span class="line">// 放入到对应的桶中</span><br><span class="line">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">bucketElementCounts[digitOfElement]++;</span><br><span class="line">&#125;</span><br><span class="line">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">index = 0;</span><br><span class="line">// 遍历每一桶，并将桶中是数据，放入到原数组</span><br><span class="line">for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">// 如果桶中，有数据，我们才放入到原数组</span><br><span class="line">if (bucketElementCounts[k] != 0) &#123;</span><br><span class="line">// 循环该桶即第k个桶(即第k个一维数组), 放入</span><br><span class="line">for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">// 取出元素放入到arr</span><br><span class="line">arr[index++] = bucket[k][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//第2轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span><br><span class="line">bucketElementCounts[k] = 0;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;第2轮，对个位的排序处理 arr =&quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第3轮(针对每个元素的百位进行排序处理)</span><br><span class="line">for (int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">// 取出每个元素的百位的值</span><br><span class="line">int digitOfElement = arr[j] / 100 % 10; // 748 / 100 =&gt; 7 % 10 = 7</span><br><span class="line">// 放入到对应的桶中</span><br><span class="line">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">bucketElementCounts[digitOfElement]++;</span><br><span class="line">&#125;</span><br><span class="line">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">index = 0;</span><br><span class="line">// 遍历每一桶，并将桶中是数据，放入到原数组</span><br><span class="line">for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">// 如果桶中，有数据，我们才放入到原数组</span><br><span class="line">if (bucketElementCounts[k] != 0) &#123;</span><br><span class="line">// 循环该桶即第k个桶(即第k个一维数组), 放入</span><br><span class="line">for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">// 取出元素放入到arr</span><br><span class="line">arr[index++] = bucket[k][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//第3轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span><br><span class="line">bucketElementCounts[k] = 0;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;第3轮，对个位的排序处理 arr =&quot; + Arrays.toString(arr)); */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九：归并排序"><a href="#九：归并排序" class="headerlink" title="九：归并排序"></a>九：归并排序</h3><p>1：归并排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2</span><br><span class="line">求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1</span><br><span class="line">合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class MergetSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //int arr[] = &#123; 8, 4, 5, 7, 1, 3, 6, 2 &#125;; //</span><br><span class="line"></span><br><span class="line">        //测试快排的执行速度</span><br><span class="line">        // 创建要给80000个的随机的数组</span><br><span class="line">        int[] arr = new int[8000000];</span><br><span class="line">        for (int i = 0; i &lt; 8000000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;排序前&quot;);</span><br><span class="line">        Date data1 = new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">        System.out.println(&quot;排序前的时间是=&quot; + date1Str);</span><br><span class="line"></span><br><span class="line">        int temp[] = new int[arr.length]; //归并排序需要一个额外空间</span><br><span class="line">        mergeSort(arr, 0, arr.length - 1, temp);</span><br><span class="line"></span><br><span class="line">        Date data2 = new Date();</span><br><span class="line">        String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">        System.out.println(&quot;排序前的时间是=&quot; + date2Str);</span><br><span class="line"></span><br><span class="line">        //System.out.println(&quot;归并排序后=&quot; + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //分+合方法</span><br><span class="line">    public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123;</span><br><span class="line">        if(left &lt; right) &#123;</span><br><span class="line">            int mid = (left + right) / 2; //中间索引</span><br><span class="line">            //向左递归进行分解</span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            //向右递归进行分解</span><br><span class="line">            mergeSort(arr, mid + 1, right, temp);</span><br><span class="line">            //合并</span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //合并的方法</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param arr 排序的原始数组</span><br><span class="line">     * @param left 左边有序序列的初始索引</span><br><span class="line">     * @param mid 中间索引</span><br><span class="line">     * @param right 右边索引</span><br><span class="line">     * @param temp 做中转的数组</span><br><span class="line">     */</span><br><span class="line">    public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123;</span><br><span class="line"></span><br><span class="line">        int i = left; // 初始化i, 左边有序序列的初始索引</span><br><span class="line">        int j = mid + 1; //初始化j, 右边有序序列的初始索引</span><br><span class="line">        int t = 0; // 指向temp数组的当前索引</span><br><span class="line"></span><br><span class="line">        //(一)</span><br><span class="line">        //先把左右两边(有序)的数据按照规则填充到temp数组</span><br><span class="line">        //直到左右两边的有序序列，有一边处理完毕为止</span><br><span class="line">        while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;//继续</span><br><span class="line">            //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span><br><span class="line">            //即将左边的当前元素，填充到 temp数组</span><br><span class="line">            //然后 t++, i++</span><br><span class="line">            if(arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t += 1;</span><br><span class="line">                i += 1;</span><br><span class="line">            &#125; else &#123; //反之,将右边有序序列的当前元素，填充到temp数组</span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t += 1;</span><br><span class="line">                j += 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //(二)</span><br><span class="line">        //把有剩余数据的一边的数据依次全部填充到temp</span><br><span class="line">        while( i &lt;= mid) &#123; //左边的有序序列还有剩余的元素，就全部填充到temp</span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += 1;</span><br><span class="line">            i += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while( j &lt;= right) &#123; //右边的有序序列还有剩余的元素，就全部填充到temp</span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += 1;</span><br><span class="line">            j += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //(三)</span><br><span class="line">        //将temp数组的元素拷贝到arr</span><br><span class="line">        //注意，并不是每次都拷贝所有</span><br><span class="line">        t = 0;</span><br><span class="line">        int tempLeft = left; //</span><br><span class="line">        //第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3</span><br><span class="line">        //最后一次 tempLeft = 0  right = 7</span><br><span class="line">        while(tempLeft &lt;= right) &#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            t += 1;</span><br><span class="line">            tempLeft += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：排序&quot;&gt;&lt;a href=&quot;#一：排序&quot; class=&quot;headerlink&quot; title=&quot;一：排序&quot;&gt;&lt;/a&gt;一：排序&lt;/h1&gt;&lt;h3 id=&quot;1：排序的分类&quot;&gt;&lt;a href=&quot;#1：排序的分类&quot; class=&quot;headerlink&quot; title=&quot;1：排
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法(三)递归</title>
    <link href="https://yanyubing.xyz/2019/11/28/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(%E4%B8%89)%E9%80%92%E5%BD%92/"/>
    <id>https://yanyubing.xyz/2019/11/28/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(%E4%B8%89)%E9%80%92%E5%BD%92/</id>
    <published>2019-11-28T04:00:40.688Z</published>
    <updated>2019-11-28T08:06:58.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：递归"><a href="#一：递归" class="headerlink" title="一：递归"></a>一：递归</h1><h3 id="1：递归介绍"><a href="#1：递归介绍" class="headerlink" title="1：递归介绍"></a>1：递归介绍</h3><p>1：递归的应用场景，迷宫问题（回溯），递归</p><p>2：概念，递归就是自己调用自己，每次传入一个不一样的参数</p><p>3：递归可以解决的问题：8皇后，汉若塔，阶乘问题，迷宫问题，球和篮子</p><p>4：各种算法，快排，归并，二分查找，分治算法等</p><p>5：将用栈解决的问题使用递归解决</p><p>6：递归使用遵守规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：执行一个方法时，就春季了一个新的受保护的独立空间（栈空间）</span><br><span class="line">2：方法的局部变量是独立的，不会相互影响</span><br><span class="line">3：如果方法中使用的是引用类型的变量，例如迷宫问题是的数组，就会共享该类型的数据</span><br><span class="line">4：递归必须向退出递归的条件逼近，否则就是无线递归，栈溢出stackOverflowError</span><br><span class="line">5：当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用就把结果返回给谁；同时当方法执行完毕或者返回时，该方法也就执行完毕</span><br></pre></td></tr></table></figure><h3 id="2：递归-迷宫问题"><a href="#2：递归-迷宫问题" class="headerlink" title="2：递归-迷宫问题"></a>2：递归-迷宫问题</h3><p>1：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">package com.it.rescursion;</span><br><span class="line"></span><br><span class="line">public class MiGong &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //二维数组创建一个迷宫</span><br><span class="line">        int[][] map = new int[8][7];</span><br><span class="line">        //使用1表示墙</span><br><span class="line">        // 上下全置为1</span><br><span class="line">        for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">            map[0][i] = 1;</span><br><span class="line">            map[7][i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        //左右置为1</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            map[i][0] = 1;</span><br><span class="line">            map[i][6] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        //设置相应挡板，1</span><br><span class="line">        map[3][1] = 1;</span><br><span class="line">        map[3][2] = 1;</span><br><span class="line">        //输出地图</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 7; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;迷宫问题&quot;);</span><br><span class="line">        //使用递归回溯给小球找路</span><br><span class="line">        setWay(map, 1, 1);</span><br><span class="line">        //使用新的地图，小球走过，并表示过得地图</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 7; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*说明：</span><br><span class="line">        map表示地图，i，j 表示从地图哪个位置开始出发（1,1）</span><br><span class="line">     *如果小球能到map[6][5]位置，则说明通路找到</span><br><span class="line">     约定：当map[i][j]为</span><br><span class="line">     0表示没有走过</span><br><span class="line">     1表示墙，</span><br><span class="line">     2表示通路，可以走</span><br><span class="line">     3表示该位置已经走过，但是走不通。</span><br><span class="line">     在走迷宫时先确定一个策略（方法）下→右→上→左；如果该路走不通则回溯</span><br><span class="line">     * */</span><br><span class="line">    //使用递归回溯来给小球找路</span><br><span class="line">    public static boolean setWay(int[][] map, int i, int j) &#123;</span><br><span class="line">        if (map[6][5] == 2) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (map[i][j] == 0) &#123;</span><br><span class="line">                //按照策略开始走   下→右→上→左</span><br><span class="line">                map[i][j] = 2;//假定可以走通</span><br><span class="line">                if (setWay(map, i + 1, j)) &#123;//向下走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (setWay(map, i, j + 1)) &#123;//向右走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (setWay(map, i - 1, j)) &#123;//向上走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (setWay(map, i, j - 1)) &#123;//向左走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //都走不通，说明是死路</span><br><span class="line">                    map[i][j] = 3;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果map[i][j]!=0;可能是1,2,3</span><br><span class="line">            else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3：递归-八皇后问题"><a href="#3：递归-八皇后问题" class="headerlink" title="3：递归-八皇后问题"></a>3：递归-八皇后问题</h3><p>1：思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：第一个皇后放在第一行第一列</span><br><span class="line">2：第二个皇后放在第二行第一列，然后判断是否ok,如果不Ok,继续放在第二列、第三列...依次把所有列放完，找到一个合适的</span><br><span class="line">3：继续第三个皇后，还是第一列，第二列...直到第8个皇后也能放在一个不冲突的位置，算是找到一个正确解</span><br><span class="line">4：当得到一个正确时，在栈回退到上一个栈，就会开始回溯，即将第一个皇后放在第一列的所有正确解全部都得到</span><br><span class="line">5：然后回头继续第一个皇后放在第二列，后面继续执行1,2,3,4的步骤</span><br><span class="line">说明：理论上需要二维数组，但是实际上可以用一位数组的索引（index+1）表示第几行</span><br><span class="line">6：合计92种</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package com.it.rescursion;</span><br><span class="line"></span><br><span class="line">public class Queue8 &#123;</span><br><span class="line">    //先定义一个max表示共有多少个皇后</span><br><span class="line">    int max = 8;</span><br><span class="line">    //定义一个数组，保存皇后防止位置的结果，比如arr=&#123;0,4,7,5,2,6,1,3&#125;</span><br><span class="line">    int array[] = new int[max];</span><br><span class="line">    static int count = 0;</span><br><span class="line">    static int judgeCount = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试</span><br><span class="line">        Queue8 queue8 = new Queue8();</span><br><span class="line">        queue8.check(0);</span><br><span class="line">        System.out.printf(&quot;一共有%d解法&quot;, count);</span><br><span class="line">        System.out.printf(&quot;一共判断冲突的次数%d次&quot;, judgeCount); // 1.5w</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //编写一个方法，放置第n个皇后</span><br><span class="line">    private void check(int n) &#123;</span><br><span class="line">        //n=8代表已经放完了8个皇后</span><br><span class="line">        if (n == max) &#123;</span><br><span class="line">            print();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //依次测试第n个皇后的放入，并判断是否冲突</span><br><span class="line">        for (int i = 0; i &lt; max; i++) &#123;</span><br><span class="line">            //i=0时，表示放置在第一列，i=1表示放置在第二列...</span><br><span class="line">            array[n] = i;</span><br><span class="line">            //判断当放置第N个皇后到i列时是否冲突；</span><br><span class="line">            if (judge(n)) &#123;</span><br><span class="line">                //接着放n+1个皇后</span><br><span class="line">                check(n + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            //如果冲突，则继续执行循环，放置在i+1列</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查看当我们放置第N个皇后时，就去检查该皇后是否和前面已经放置的皇后冲突</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param n 表示第N个皇后</span><br><span class="line">     */</span><br><span class="line">    private boolean judge(int n) &#123;</span><br><span class="line">        judgeCount++;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            //array[i] == array[n]这里表示是不是在同一列</span><br><span class="line">            // Math.abs(n - 1) == Math.abs(array[n] - array[i])表示第n个皇后是不是和第i个皇后在45°线上</span><br><span class="line">            if (array[i] == array[n] || Math.abs(n -i ) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //写一个方法可以将皇后摆放的位置输出</span><br><span class="line">        private void print () &#123;</span><br><span class="line">            count++;</span><br><span class="line">            for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">                System.out.print(array[i] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：递归&quot;&gt;&lt;a href=&quot;#一：递归&quot; class=&quot;headerlink&quot; title=&quot;一：递归&quot;&gt;&lt;/a&gt;一：递归&lt;/h1&gt;&lt;h3 id=&quot;1：递归介绍&quot;&gt;&lt;a href=&quot;#1：递归介绍&quot; class=&quot;headerlink&quot; title=&quot;1：递归介
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法(二)栈</title>
    <link href="https://yanyubing.xyz/2019/11/27/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(%E4%BA%8C)%E6%A0%88/"/>
    <id>https://yanyubing.xyz/2019/11/27/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(%E4%BA%8C)%E6%A0%88/</id>
    <published>2019-11-27T08:55:10.889Z</published>
    <updated>2019-11-28T04:00:20.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：栈"><a href="#一：栈" class="headerlink" title="一：栈"></a>一：栈</h1><h3 id="1：栈的应用场景"><a href="#1：栈的应用场景" class="headerlink" title="1：栈的应用场景"></a>1：栈的应用场景</h3><p>1：子程序的调用</p><p>2：处理递归调用</p><p>3：表达式的转换</p><p>4：二叉树的遍历</p><p>5：图形的深度优先搜索法</p><h3 id="2：用数组模拟栈，代码实现出栈与入栈思路"><a href="#2：用数组模拟栈，代码实现出栈与入栈思路" class="headerlink" title="2：用数组模拟栈，代码实现出栈与入栈思路"></a>2：用数组模拟栈，代码实现出栈与入栈思路</h3><p>1：需要栈的大小</p><p>2：需要定义栈顶top,初始化为-1</p><p>3：入栈，当有数据加入栈pop()，top++，加入数据</p><p>4：出栈，当有数据取出时push()，top–，取出数据</p><p>5：注意：出栈之后数组的元素并没有改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">package com.it.stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayStackDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试ArrayStack</span><br><span class="line">        ArrayStack stack = new ArrayStack(4);</span><br><span class="line">        String key = &quot;&quot;;//控制输入字符</span><br><span class="line">        boolean loop = true;//控制退出菜单</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            System.out.println(&quot;----------------&quot;);</span><br><span class="line">            System.out.println(&quot;show:表示显示栈&quot;);</span><br><span class="line">            System.out.println(&quot;exit:退出程序&quot;);</span><br><span class="line">            System.out.println(&quot;push:表示添加数据到栈&quot;);</span><br><span class="line">            System.out.println(&quot;pop:表示从栈取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;请输入你的选择&quot;);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &quot;show&quot;:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;push&quot;:</span><br><span class="line">                    System.out.println(&quot;请输入要加入的数&quot;);</span><br><span class="line">                    int value = scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;pop&quot;:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int pop = stack.pop();</span><br><span class="line">                        System.out.printf(&quot;出栈的数据是%d\n&quot;, pop);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;exit&quot;:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个类表示栈结构</span><br><span class="line">class ArrayStack &#123;</span><br><span class="line">    private int mazSize;//栈的最大大小</span><br><span class="line">    private int[] stack;//数组模拟战，数据放在该数组中</span><br><span class="line">    private int top = -1;//初始化栈顶为-1</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public ArrayStack(int mazSize) &#123;</span><br><span class="line">        this.mazSize = mazSize;</span><br><span class="line">        //初始化数组</span><br><span class="line">        stack = new int[this.mazSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈空</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return top == mazSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return top == -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public void push(int value) &#123;</span><br><span class="line">        //先判断是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;栈满&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;栈空，没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历栈,需要从栈顶开始显示数据</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;栈空，没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = top; i &gt;= 0; i--) &#123;</span><br><span class="line">            System.out.printf(&quot;stack[%d]=%d\n&quot;, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3：栈实现综合计算器：中缀表达式"><a href="#3：栈实现综合计算器：中缀表达式" class="headerlink" title="3：栈实现综合计算器：中缀表达式"></a>3：栈实现综合计算器：中缀表达式</h3><p>1：创建一个数栈numStack，存放数</p><p>2：创建一个符号栈operStack，存放运算符</p><p>3：通过index值（索引），遍历我们的表达式</p><p>4：如果我们发现的是一个数字，就直接放入数栈</p><p>5：如果扫描的是一个符号</p><p>​    1：如果发现目前的符号栈为空，就直接入栈</p><p>​    2：如果符号栈有操作符，就进行比较。如果当前的操作符优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数再从符号栈中pop出一个符号，进行运算，将得到的结构再入数栈，然后再把当前符号入符号栈；如果当前的操作符优先级大于栈中的操作符，就直接入符号栈。</p><p>6：当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并进行运算，最后在数栈中只有一个数字，就是表达式的结果</p><p>7：注意：栈的判断条件，如操作符栈最多只能有两个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">package com.it.stack;</span><br><span class="line"></span><br><span class="line">import javax.jws.soap.SOAPMessageHandlers;</span><br><span class="line"></span><br><span class="line">public class Calculator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //表达式</span><br><span class="line">        String expression = &quot;5+9+297-1&quot;;</span><br><span class="line">        //创建两个栈,这里大小设置为10，实际上应该只能用到2-3左右</span><br><span class="line">        ArrayStack2 numStack = new ArrayStack2(10);</span><br><span class="line">        ArrayStack2 operStack = new ArrayStack2(10);</span><br><span class="line">        //定义相关变量</span><br><span class="line">        int index = 0;//用于扫描</span><br><span class="line">        int num1 = 0;</span><br><span class="line">        int num2 = 0;</span><br><span class="line">        int oper = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        char ch = &apos; &apos;;//将每次扫描的char保存到ch</span><br><span class="line">        String keepNum = &quot;&quot;;//用于拼接多位数</span><br><span class="line">        //        开始while循环扫描expression</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //依次得到expression的每一个字符</span><br><span class="line">            ch = expression.substring(index, index + 1).charAt(0);</span><br><span class="line">            //判断ch，不同处理</span><br><span class="line">            //如果是符号</span><br><span class="line">            if (operStack.isOper(ch)) &#123;</span><br><span class="line">                if (!operStack.isEmpty()) &#123;</span><br><span class="line">                    //满足该条件时运算</span><br><span class="line">                    if (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        res = numStack.cal(num1, num2, oper);</span><br><span class="line">                        //把运算结果入数栈</span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        //然后将当前的操作符入符号栈</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //如果为空，直接入符号栈</span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果是数，则直接入栈，注意此时传入的是字符‘1’；需要对照ascii表转换为数字1， -48</span><br><span class="line">            //注意这里有问题，不能处理多位数</span><br><span class="line">            //需要进行拼接</span><br><span class="line">            else &#123;</span><br><span class="line">                //处理多位数</span><br><span class="line">                keepNum += ch;</span><br><span class="line">                //如果ch已经是expression最后一位，直接入栈</span><br><span class="line">                if (index == expression.length() - 1) &#123;</span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                &#125; else &#123;//判断下一个字符是不是数字，如果是数字，则继续扫描，如果是字符，则入栈</span><br><span class="line">                    if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) &#123;</span><br><span class="line">                        //如果后一位是操作符，则入栈，keepNum=&quot;123&quot;，转为数字</span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        //重要，情况keepNum</span><br><span class="line">                        keepNum = &quot;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //让index+1，并判断是否扫描到expression最后</span><br><span class="line">            index++;</span><br><span class="line">            if (index == expression.length()) &#123;</span><br><span class="line">                //扫描结束</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //开始计算后面的情况</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //如果符号栈为空，则计算到最后的结果，数栈中只有一个数字【结果】</span><br><span class="line">            if (operStack.isEmpty()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            res = numStack.cal(num1, num2, oper);</span><br><span class="line">            //把运算结果入数栈</span><br><span class="line">            numStack.push(res);</span><br><span class="line">        &#125;</span><br><span class="line">        //将最后的数，pop出就是结果</span><br><span class="line">        int res2 = numStack.pop();</span><br><span class="line">        System.out.printf(&quot;表达式%s=%d&quot;, expression, res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个类表示栈结构</span><br><span class="line">class ArrayStack2 &#123;</span><br><span class="line">    private int mazSize;//栈的最大大小</span><br><span class="line">    private int[] stack;//数组模拟战，数据放在该数组中</span><br><span class="line">    private int top = -1;//初始化栈顶为-1</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public ArrayStack2(int mazSize) &#123;</span><br><span class="line">        this.mazSize = mazSize;</span><br><span class="line">        //初始化数组</span><br><span class="line">        stack = new int[this.mazSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈空</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return top == mazSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return top == -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public void push(int value) &#123;</span><br><span class="line">        //先判断是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;栈满&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;栈空，没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历栈,需要从栈顶开始显示数据</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;栈空，没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = top; i &gt;= 0; i--) &#123;</span><br><span class="line">            System.out.printf(&quot;stack[%d]=%d\n&quot;, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回运算符的优先级，优先级使用数字表示，数字越大则优先级越高</span><br><span class="line">    public int priority(int oper) &#123;</span><br><span class="line">        if (oper == &apos;*&apos; || oper == &apos;/&apos;) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (oper == &apos;+&apos; || oper == &apos;-&apos;) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1;//假定目前的表达式只有+，-，*，/</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是不是一个运算符</span><br><span class="line">    public boolean isOper(char val) &#123;</span><br><span class="line">        return val == &apos;+&apos; || val == &apos;-&apos; || val == &apos;*&apos; || val == &apos;/&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算方法</span><br><span class="line">    public int cal(int num1, int num2, int oper) &#123;</span><br><span class="line">        int res = 0;//用于存放计算的结果</span><br><span class="line">        switch (oper) &#123;</span><br><span class="line">            case &apos;+&apos;:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                break;</span><br><span class="line">            case &apos;-&apos;:</span><br><span class="line">                res = num2 - num1;//注意顺序</span><br><span class="line">                break;</span><br><span class="line">            case &apos;*&apos;:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                break;</span><br><span class="line">            case &apos;/&apos;:</span><br><span class="line">                res = num2 / num1;//注意顺序</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //增加返回栈顶值的方法</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        return stack[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4：波兰表达式：前缀表达式"><a href="#4：波兰表达式：前缀表达式" class="headerlink" title="4：波兰表达式：前缀表达式"></a>4：波兰表达式：前缀表达式</h3><p>1：举例：     - * + 3 4 5 8</p><p>2：计算步骤，从右至左扫描，将8 5 4 3 压入栈</p><p>3：遇到+运算符，因此弹出3 和 4 进行运算，计算出3+4的值7，然后入栈</p><p>4：遇到*运算符，弹出7和5 计算得出得出7X5=35，将35入栈</p><p>5：最后-运算符，计算出35-8的值，即27，由此得到最终结果</p><h3 id="5：逆波兰表达式：后缀表达式"><a href="#5：逆波兰表达式：后缀表达式" class="headerlink" title="5：逆波兰表达式：后缀表达式"></a>5：逆波兰表达式：后缀表达式</h3><p>1：举例：    3 4 + 5 * 6 -</p><p>2：计算步骤，从左至右扫描，将3和4压入栈</p><p>3：遇到+运算符，因此弹出4和3 ，计算出3+4的值，得7，将7入栈</p><p>5：将5入栈</p><p>6：接下来是X运算符，因此弹出5和7，计算出7*5=35，将35入栈</p><p>7：将6入栈</p><p>8：弹出6（栈顶）和35（栈顶下一个元素），计算35-6，即29</p><p>9：逆波兰表达式计算器的代码实现</p><p>​    1：需要输入一个逆波兰表达式</p><p>​    2：使用系统提供的栈(stack)</p><p>​    3：支持小括号和多位整数</p><p>​    4：思路如上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.it.stack;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class PolandNotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //定义一个逆波兰表达式</span><br><span class="line">        //(3+4)*5-6 =&gt; 3 4 + 5 * 6 -</span><br><span class="line">        //为了方便，逆波兰表达式的数字和符号用空格隔开</span><br><span class="line">        String suffixExpression = &quot;30 4 + 5 * 6 -&quot;;</span><br><span class="line">        //思路</span><br><span class="line">        //1：先将&quot;3 4 + 5 * 6 -&quot;放入ArrayList中，这里是为了方便根据索引扫描</span><br><span class="line">        //2：将ArrayList传递给一个方法，遍历ArrayList，配合栈，完成计算</span><br><span class="line">        List&lt;String&gt; list = getListString(suffixExpression);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        int res = calculate(list);</span><br><span class="line">        System.out.println(&quot;计算的结果是=&quot; + res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;String&gt; getListString(String suffixExpression) &#123;</span><br><span class="line">        String[] split = suffixExpression.split(&quot; &quot;);</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        for (String s : split) &#123;</span><br><span class="line">            //遍历添加元素到集合</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //运算</span><br><span class="line">    public static int calculate(List&lt;String&gt; ls) &#123;</span><br><span class="line">        //创建栈</span><br><span class="line">        Stack&lt;String&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (String item : ls) &#123;</span><br><span class="line">            //使用正则表达式取出数,匹配的是多位数</span><br><span class="line">            if (item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">                //入栈</span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int pop2 = Integer.parseInt(stack.pop());</span><br><span class="line">                int pop1 = Integer.parseInt(stack.pop());</span><br><span class="line">                int res = 0;</span><br><span class="line">                if (item.equals(&quot;+&quot;)) &#123;</span><br><span class="line">                    res = pop1 + pop2;</span><br><span class="line">                &#125; else if (item.equals(&quot;-&quot;)) &#123;</span><br><span class="line">                    res = pop1 - pop2;//先弹出的是pop2</span><br><span class="line">                &#125; else if (item.equals(&quot;*&quot;)) &#123;</span><br><span class="line">                    res = pop1 * pop2;</span><br><span class="line">                &#125; else if (item.equals(&quot;/&quot;)) &#123;</span><br><span class="line">                    res = pop1 / pop2;//先弹出的是pop2</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;运算符有误！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(&quot;&quot; + res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最后留在栈中的就是运算结果</span><br><span class="line">        return Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六：中缀表达式转换为后缀表达式"><a href="#六：中缀表达式转换为后缀表达式" class="headerlink" title="六：中缀表达式转换为后缀表达式"></a>六：中缀表达式转换为后缀表达式</h3><p>1：中缀表达式适合人的理解</p><p>2：后缀表达式适合计算机的运行</p><p>3：思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.初始化两个栈：运算符栈s1和储存中间结果的栈s2；</span><br><span class="line">2.从左至右扫描中缀表达式；</span><br><span class="line">3.遇到操作数时，将其压s2；</span><br><span class="line">4.遇到运算符时，比较其与s1栈顶运算符的优先级：</span><br><span class="line">　（1）如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</span><br><span class="line">　（2）否则，若优先级比栈顶运算符的高，也将运算符压入s1；</span><br><span class="line">　（3）否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较； </span><br><span class="line">5.遇到括号时：　</span><br><span class="line">（1）如果是左括号&quot;(&quot;，则直接压入s1　</span><br><span class="line">（2）如果是右括号&quot;)&quot;，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span><br><span class="line">6.重复步骤2至5，直到表达式的最右边</span><br><span class="line">7.将s1中剩余的运算符依次弹出并压入s2</span><br><span class="line">8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</span><br></pre></td></tr></table></figure><p>4：算法的层面</p><p>​    理解算法→灵活运用算法→自己设计算法</p><p>5：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">package com.it.stack;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class PolandNotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //定义一个逆波兰表达式</span><br><span class="line">        //(3+4)*5-6 =&gt; 3 4 + 5 * 6 -</span><br><span class="line">        //为了方便，逆波兰表达式的数字和符号用空格隔开</span><br><span class="line">/*        String suffixExpression = &quot;30 4 + 5 * 6 -&quot;;</span><br><span class="line">        //思路</span><br><span class="line">        //1：先将&quot;3 4 + 5 * 6 -&quot;放入ArrayList中，这里是为了方便根据索引扫描</span><br><span class="line">        //2：将ArrayList传递给一个方法，遍历ArrayList，配合栈，完成计算</span><br><span class="line">        List&lt;String&gt; list = getListString(suffixExpression);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        int res = calculate(list);</span><br><span class="line">        System.out.println(&quot;计算的结果是=&quot; + res);*/</span><br><span class="line"></span><br><span class="line">        //测试中缀表达式转换成list</span><br><span class="line">        String expression = &quot;1+((2+3)*4)-5&quot;;</span><br><span class="line">        List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);</span><br><span class="line">        System.out.println(&quot;中缀表达式\n&quot; + expression);</span><br><span class="line">        System.out.println(&quot;中缀表达式对应的list\n&quot; + infixExpressionList);</span><br><span class="line">        //将中缀表达式得到的list转换为逆波兰表达式的字符串</span><br><span class="line">        List&lt;String&gt; suffixExpressionList = parseSuffixExpressionList(infixExpressionList);</span><br><span class="line">        System.out.println(&quot;后缀表达式对应的list\n&quot; + suffixExpressionList);</span><br><span class="line">        //验算逆序表达式的结果</span><br><span class="line">        System.out.printf(&quot;expression=%d&quot;, calculate(suffixExpressionList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;String&gt; getListString(String suffixExpression) &#123;</span><br><span class="line">        String[] split = suffixExpression.split(&quot; &quot;);</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        for (String s : split) &#123;</span><br><span class="line">            //遍历添加元素到集合</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //运算</span><br><span class="line">    public static int calculate(List&lt;String&gt; ls) &#123;</span><br><span class="line">        //创建栈</span><br><span class="line">        Stack&lt;String&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (String item : ls) &#123;</span><br><span class="line">            //使用正则表达式取出数,匹配的是多位数</span><br><span class="line">            if (item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">                //入栈</span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int pop2 = Integer.parseInt(stack.pop());</span><br><span class="line">                int pop1 = Integer.parseInt(stack.pop());</span><br><span class="line">                int res = 0;</span><br><span class="line">                if (item.equals(&quot;+&quot;)) &#123;</span><br><span class="line">                    res = pop1 + pop2;</span><br><span class="line">                &#125; else if (item.equals(&quot;-&quot;)) &#123;</span><br><span class="line">                    res = pop1 - pop2;//先弹出的是pop2</span><br><span class="line">                &#125; else if (item.equals(&quot;*&quot;)) &#123;</span><br><span class="line">                    res = pop1 * pop2;</span><br><span class="line">                &#125; else if (item.equals(&quot;/&quot;)) &#123;</span><br><span class="line">                    res = pop1 / pop2;//先弹出的是pop2</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;运算符有误！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(&quot;&quot; + res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最后留在栈中的就是运算结果</span><br><span class="line">        return Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将中缀表达式转出对应的list</span><br><span class="line">    public static List&lt;String&gt; toInfixExpressionList(String s) &#123;</span><br><span class="line">        //定义一个list，存放中缀表达式的内容</span><br><span class="line">        List&lt;String&gt; ls = new ArrayList&lt;String&gt;();</span><br><span class="line">        int i = 0;//指针，用于遍历s</span><br><span class="line">        String str;//对多位数的拼接工作</span><br><span class="line">        char c;//每遍历一个字符，放在char中</span><br><span class="line">        do &#123;</span><br><span class="line">            //如果c是一个非数字，直接加入到ls</span><br><span class="line">            if ((c = s.charAt(i)) &lt; 48 || (c = s.charAt(i)) &gt; 57) &#123;</span><br><span class="line">                ls.add(&quot;&quot; + c);</span><br><span class="line">                i++;//i 需要后移</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //如果是一个数，需要考虑多位数问题</span><br><span class="line">                str = &quot;&quot;;//先将str置空</span><br><span class="line">                //‘0’ 【48】 ‘9’【57】</span><br><span class="line">                while (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= 48 &amp;&amp; (c = s.charAt(i)) &lt;= 57) &#123;</span><br><span class="line">                    str += c;//拼接</span><br><span class="line">                    i++;</span><br><span class="line">                    //while循环结束之后多位数就拼接完成</span><br><span class="line">                &#125;</span><br><span class="line">                ls.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (i &lt; s.length());</span><br><span class="line">        return ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将得到的中缀表达式转换成为的list=&gt;后缀表达式对应的list</span><br><span class="line">    public static List&lt;String&gt; parseSuffixExpressionList(List&lt;String&gt; ls) &#123;</span><br><span class="line">        //定义两个栈</span><br><span class="line">        Stack&lt;String&gt; s1 = new Stack&lt;String&gt;();//定义符号栈</span><br><span class="line">        //说明：因为S2这个栈，在整个过程中没有pop操作，而且后面我们还需要逆序输出，因此直接用ArrayList操作</span><br><span class="line">        //Stack stack2=new Stack();</span><br><span class="line">        List&lt;String&gt; s2 = new ArrayList&lt;&gt;();//储存中间结果的list</span><br><span class="line">        for (String item : ls) &#123;</span><br><span class="line">            if (item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125; else if (item.equals(&quot;(&quot;)) &#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125; else if (item.equals(&quot;)&quot;)) &#123;</span><br><span class="line">                //（2）如果是右括号&quot;)&quot;</span><br><span class="line">                while (!s1.peek().equals(&quot;(&quot;)) &#123;</span><br><span class="line">//                    则依次弹出s1栈顶的运算符，并压入s2</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                //直到遇到左括号为止，此时将这一对括号丢弃</span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //当item的优先级小于或等于栈顶运算符的优先级，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</span><br><span class="line">                //需要加入优先级高低的方法</span><br><span class="line">                while (s1.size() != 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item)) &#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //for循环完成之后，将item压入栈中</span><br><span class="line">        while (s1.size() != 0) &#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return s2;//因为是存放到list中，按照顺序输出就是后缀表达式对应的list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写一个类，可以返回一个运算符对应的优先级</span><br><span class="line">class Operation &#123;</span><br><span class="line">    private static int ADD = 1;</span><br><span class="line">    private static int SUB = 1;</span><br><span class="line">    private static int MUL = 2;</span><br><span class="line">    private static int DIV = 2;</span><br><span class="line"></span><br><span class="line">    public static int getValue(String operation) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        switch (operation) &#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                result = ADD;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                result = SUB;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                result = MUL;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;/&quot;:</span><br><span class="line">                result = DIV;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">//                System.out.println(&quot;不存在操作符&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：栈&quot;&gt;&lt;a href=&quot;#一：栈&quot; class=&quot;headerlink&quot; title=&quot;一：栈&quot;&gt;&lt;/a&gt;一：栈&lt;/h1&gt;&lt;h3 id=&quot;1：栈的应用场景&quot;&gt;&lt;a href=&quot;#1：栈的应用场景&quot; class=&quot;headerlink&quot; title=&quot;1：栈的应
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>怎么搭建自己的博客</title>
    <link href="https://yanyubing.xyz/2019/11/26/%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://yanyubing.xyz/2019/11/26/%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-11-26T04:32:14.553Z</published>
    <updated>2019-11-26T05:26:19.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h1><p>node.js</p><p>git</p><p>hexo</p><p>github账号</p><p>自己购买的域名</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>网上有很多基于hexo搭建github的博客可供参考：<a href="http://rosesnow.top/" target="_blank" rel="noopener">http://rosesnow.top</a> </p><p>这里主要描述流程和理解，方便遇到问题能够快速找到办法：</p><p>1：node.js是用于npm安装</p><p>2：hexo是本地博客servece</p><p>3：需要把hexo部署到github pages上</p><p>4：通过CNAME文件实现域名的重定向操作，最终实现自己的域名与hexo同步</p><p>5：直接在github上添加CANME文件可以实现一次转发，需要在blog/source目录下创建CNAME文件保证每次有效</p><p>6：最后在更新blog之后hexo  g ; hexo d 同步</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工具准备&quot;&gt;&lt;a href=&quot;#工具准备&quot; class=&quot;headerlink&quot; title=&quot;工具准备&quot;&gt;&lt;/a&gt;工具准备&lt;/h1&gt;&lt;p&gt;node.js&lt;/p&gt;
&lt;p&gt;git&lt;/p&gt;
&lt;p&gt;hexo&lt;/p&gt;
&lt;p&gt;github账号&lt;/p&gt;
&lt;p&gt;自己购买的域名&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法(一）数组，队列，链表</title>
    <link href="https://yanyubing.xyz/2018/11/28/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(%E4%B8%80%EF%BC%89%E6%95%B0%E7%BB%84%EF%BC%8C%E9%98%9F%E5%88%97%EF%BC%8C%E9%93%BE%E8%A1%A8/"/>
    <id>https://yanyubing.xyz/2018/11/28/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(%E4%B8%80%EF%BC%89%E6%95%B0%E7%BB%84%EF%BC%8C%E9%98%9F%E5%88%97%EF%BC%8C%E9%93%BE%E8%A1%A8/</id>
    <published>2018-11-28T13:46:12.000Z</published>
    <updated>2019-12-01T14:16:45.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1：数据结构分类https-leetcode-cn-com-interview"><a href="#1：数据结构分类https-leetcode-cn-com-interview" class="headerlink" title="1：数据结构分类https://leetcode-cn.com/interview/"></a>1：数据结构分类<a href="https://leetcode-cn.com/interview/" target="_blank" rel="noopener">https://leetcode-cn.com/interview/</a></h2><p>线性结构</p><p>线性结构分类：数组，队列，链表，栈</p><p>储存结构分类：顺序储存结构和链式储存结构</p><p>非线性结构</p><p>非线性结构分类：二维数组，多维数组，广义表，树结构，图结构</p><h2 id="2：稀疏数组"><a href="#2：稀疏数组" class="headerlink" title="2：稀疏数组"></a>2：稀疏数组</h2><p>1：基本介绍博客：<a href="https://www.cnblogs.com/blizzawang/p/11411602.html" target="_blank" rel="noopener">https://www.cnblogs.com/blizzawang/p/11411602.html</a> </p><p>2：逻辑：稀疏数组第一行第一列表示二维数组的行数，第一行第二列表示二维数组的列数，第一行第三列表示二维数组非0的个数，下列每一行的三个数分别表示哪一行，哪一列，对应的数是多少。</p><p>3：转换为稀疏数组主要用于对数据的压缩</p><p>4：二维数组与稀疏数组转换代码实现，核心思想为数据的对应转换！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">1：二维数组转换为稀疏数组思路：</span><br><span class="line">1.遍历原始的二维数组，得到有数据的个数n</span><br><span class="line">2.根据sum就可以创建稀疏数组sparseArr int[n+1][3]</span><br><span class="line">3.将二维数组的有效数据存入到稀疏数组</span><br><span class="line"></span><br><span class="line">2：稀疏数组转换为二维数组：</span><br><span class="line">1：先读取稀疏数组的第一行</span><br><span class="line">2：根据第一行的数据创建原始二位数组</span><br><span class="line">3：在读取稀疏数组后几行的数据，并赋给原始二维数组即可</span><br><span class="line"></span><br><span class="line">package com.it.sparsearray;</span><br><span class="line"></span><br><span class="line">//棋盘二维数组转换为稀疏数组</span><br><span class="line">public class SparseArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //先创建一个原始的二维数组 11*11</span><br><span class="line">        //0表示没有棋子，1表示黑子，2表示白子</span><br><span class="line">        int[][] chessArr1 = new int[11][11];</span><br><span class="line">        chessArr1[1][2] = 1;</span><br><span class="line">        chessArr1[2][3] = 2;</span><br><span class="line">        //原始的二维数组</span><br><span class="line">        for (int[] ints : chessArr1) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        //将二维数组转为稀疏数组的思路</span><br><span class="line">        //1：先遍历二维数组，得到非0的个数</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 11; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 11; j++) &#123;</span><br><span class="line">                if (chessArr1[i][j] != 0) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //2：创建对应的稀疏数组</span><br><span class="line">        int sparseArr[][] = new int[sum + 1][3];</span><br><span class="line">        //给稀疏数字赋值</span><br><span class="line">        sparseArr[0][0] = 11;</span><br><span class="line">        sparseArr[0][1] = 11;</span><br><span class="line">        sparseArr[0][2] = sum;</span><br><span class="line">        //遍历二维数组，将非0的值存放到稀疏数组中</span><br><span class="line">        int count = 0;//count用于记录是第几个非0数字</span><br><span class="line">        for (int i = 0; i &lt; 11; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 11; j++) &#123;</span><br><span class="line">                if (chessArr1[i][j] != 0) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][0] = i;</span><br><span class="line">                    sparseArr[count][1] = j;</span><br><span class="line">                    sparseArr[count][2] = chessArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //输出稀疏数组</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;得到的稀疏数组如下&quot;);</span><br><span class="line">        for (int i = 0; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;%d\t%d\t%d\t\n&quot;, sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);</span><br><span class="line">        &#125;</span><br><span class="line">        //根据稀疏数组的第一行数据，创建元素二维数组</span><br><span class="line">        int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">        //输出恢复后的二维数组</span><br><span class="line">        System.out.println(&quot;转换为二维数组如下&quot;);</span><br><span class="line">        for (int i = 1; i &lt; sparseArr[0][2] + 1; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int[] ints : chessArr2) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3：队列"><a href="#3：队列" class="headerlink" title="3：队列"></a>3：队列</h1><p>1：队列基本介绍</p><p>​    队列是一个有序表，可以用数组或者链表来实现</p><p>​    队列为先入先出原则</p><p>​    队列加数据从尾部开始加，首部不变；取数据从首部开始取，尾部不变</p><p>​    核心思想：普通队列，如队列大小为10，那么只能add10次数据，因为数组索引用过已经无法再次使用；而环形队列判断队列是否满的依据则是队列中是否已经占满数据。</p><p>​    注意：取出数据之后数组元素并未被移除，环形队列也是</p><p>2：普通队列实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">package com.it.queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayQueue queue = new ArrayQueue(5);</span><br><span class="line">        char key = &apos; &apos;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        boolean loop = true;</span><br><span class="line">        //输出一个菜单</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">            System.out.println(&quot;e(exit):退出队列&quot;);</span><br><span class="line">            System.out.println(&quot;a(add):添加数据到队列&quot;);</span><br><span class="line">            System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;h(head):查看队列的数据&quot;);</span><br><span class="line">            key = scanner.next().charAt(0);//接收一个字符</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &apos;s&apos;://显示队列</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;a&apos;://添加数据</span><br><span class="line">                    System.out.println(&quot;请输入一个数&quot;);</span><br><span class="line">                    int value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;g&apos;://取出数据</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = queue.getQueue();</span><br><span class="line">                        System.out.printf(&quot;取出的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;h&apos;://查看队列头的数据是什么</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = queue.headQueue();</span><br><span class="line">                        System.out.printf(&quot;队列头的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;e&apos;://退出</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;--------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用数组模拟队列，编写一个ArrayQueue类</span><br><span class="line">class ArrayQueue &#123;</span><br><span class="line">    private int maxSize;//表示数组最大容量</span><br><span class="line">    private int front;//队列头</span><br><span class="line">    private int rear;//队列尾</span><br><span class="line">    private int[] arr;//该数据用于队列存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    //创建队列的构造器,数组最大容量</span><br><span class="line">    public ArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = -1;//指向队列头部的前一个位置</span><br><span class="line">        rear = -1;//指向队列尾部</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        //当尾部到达了队列最后一个无法添加数据</span><br><span class="line">        return rear == maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        //当队列头与队列尾相等时为空</span><br><span class="line">        return rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;队列满，无法加入数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //未满，可以加入数据</span><br><span class="line">        rear++;//让rear后移</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getQueue() &#123;</span><br><span class="line">        //判断队列是否空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            //通过抛出异常处理</span><br><span class="line">            throw new RuntimeException(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //front后移</span><br><span class="line">        front++;</span><br><span class="line">        //获取数据</span><br><span class="line">        return arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showQueue() &#123;</span><br><span class="line">        //遍历</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;队列空的，没数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d]=%d\n&quot;, i, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int headQueue() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列空的，没数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //front指向数组头部前一位</span><br><span class="line">        return arr[front + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3：环形队列实现思路</p><p>​    1：front变量的含义调整，front指向队列的第一个元素，也就是arr[front]就是队列的第一个元素，front初始值默认为0，rear的初始值为0</p><p>​    2：rear变量的含义做一个调整，rear指向队列最后一个元素的后一个位置，因为希望空出一个空间作为约定</p><p>​    3：当队列满时，条件是（rear+1）%maxSize=front</p><p>​    4：当队列为空的条件：rear=front</p><p>​    5：当我们这样分析，队列中有效的数据个数（rear+maxSize-front)%maxSize</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">//环形队列</span><br><span class="line">package com.it.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class CircleArrayQueue &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CircleArray circleArray = new CircleArray(5);</span><br><span class="line">        char key = &apos; &apos;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        boolean loop = true;</span><br><span class="line">        System.out.println(&quot;测试环形队列！&quot;);</span><br><span class="line">        //输出一个菜单</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">            System.out.println(&quot;e(exit):退出队列&quot;);</span><br><span class="line">            System.out.println(&quot;a(add):添加数据到队列&quot;);</span><br><span class="line">            System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;h(head):查看队列的数据&quot;);</span><br><span class="line">            key = scanner.next().charAt(0);//接收一个字符</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &apos;s&apos;://显示队列</span><br><span class="line">                    circleArray.showQueue();</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;a&apos;://添加数据</span><br><span class="line">                    System.out.println(&quot;请输入一个数&quot;);</span><br><span class="line">                    int value = scanner.nextInt();</span><br><span class="line">                    circleArray.addQueue(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;g&apos;://取出数据</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.getQueue();</span><br><span class="line">                        System.out.printf(&quot;取出的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;h&apos;://查看队列头的数据是什么</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.headQueue();</span><br><span class="line">                        System.out.printf(&quot;队列头的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;e&apos;://退出</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;--------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用数组模拟队列，编写一个ArrayQueue类</span><br><span class="line">class CircleArray &#123;</span><br><span class="line">    private int maxSize;//表示数组最大容量</span><br><span class="line">    //    front变量的含义调整，front指向队列的第一个元素，也就是arr[front]就是队列的第一个元素，front初始值默认为0，rear的初始值为0</span><br><span class="line">    private int front;//队列头</span><br><span class="line">    //    rear变量的含义做一个调整，rear指向队列最后一个元素的后一个位置，因为希望空出一个空间作为约定</span><br><span class="line">    private int rear;//队列尾</span><br><span class="line">    private int[] arr;//该数据用于队列存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    //创建队列的构造器,数组最大容量</span><br><span class="line">    public CircleArray(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = 0;//指向队列头部的前一个位置</span><br><span class="line">        rear = 0;//指向队列尾部</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        //判断是否满</span><br><span class="line">        return (rear + 1) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        //当队列头与队列尾相等时为空</span><br><span class="line">        return rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;队列满，无法加入数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //未满，可以加入数据</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        rear = (rear + 1) % maxSize;//让rear后移，这里必须考虑取模</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getQueue() &#123;</span><br><span class="line">        //判断队列是否空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            //通过抛出异常处理</span><br><span class="line">            throw new RuntimeException(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //这里分析出front对应的值保留到一个临时变量</span><br><span class="line">        //将front后移,考虑取模</span><br><span class="line">        //将临时变量的变量返回</span><br><span class="line">        int value = arr[front];</span><br><span class="line">        front = (front + 1) % maxSize;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showQueue() &#123;</span><br><span class="line">        //遍历</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;队列空的，没数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //思路，从front开始遍历</span><br><span class="line">        for (int i = front; i &lt; (front + size()); i++) &#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d]=%d\n&quot;, i % maxSize, arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //求出当前队列有效数据的个数，为了遍历</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int headQueue() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列空的，没数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //front指向数组头部前一位</span><br><span class="line">        return arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4：单向链表"><a href="#4：单向链表" class="headerlink" title="4：单向链表"></a>4：单向链表</h1><p>1：链表基本介绍</p><p>​    链表是以节点的方式来储存，链式储存</p><p>​    每个节点包含data域，next域：指向下一个节点</p><p>​    链表的各个节点不一定是连续储存</p><p>​    链表分带头节点的链表和没有头节点的链表，根据实际需求来确定</p><p>2：单链表的创建（添加），显示单向链表的分析</p><p>​    head节点：不存放具体的数据，作用就是表示单链表头</p><p>​    先创建一个head头节点，作用就是单链表的头</p><p>​    后面我们每添加一个节点，就直接加入到链表的最后</p><p>​    通过一个辅助的指针，帮助遍历</p><p>3：单链表代码实现</p><p>​    1：直接添加到英雄的尾部</p><p>​    2：考虑节点排名添加（插入）</p><p>​    思路：</p><p>​        1：首先找到新添加的节点位置，通过辅助变量（指针）</p><p>​        2：新的节点.next=temp.next</p><p>​        3：将temp.next=新的节点</p><p>​        4：可以在内存中实现排序</p><p>​    3：修改节点</p><p>​    4：删除节点</p><p>​        1：找到需要删除节点的前一个节点</p><p>​        2：temp.next=temp.next.next</p><p>​        3：被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收</p><p>​    5：求单链表的节点个数</p><p>​        1：遍历（temp后移）并且length++；</p><p>​    6：查找单链表中的倒数第k个节点</p><p>​        1：编写一个方法，接收head节点，同时接收一个index</p><p>​        2：index表示倒数第index的索引</p><p>​        3：先遍历链表，拿到链表所有个数getLength，再获取第n-index节点信息</p><p>​    7：链表的反转</p><p>​        1：创建新的链表（定义一个新的链表头reverse）</p><p>​        2：遍历原链表可以获取顺数每个节点的信息</p><p>​        3：每遍历一个节点就将其取出并放在新链表的最前方</p><p>​        4：原来链表的head.next=reverse.next</p><p>​    8：链表的逆序打印</p><p>​        1：方法一：单链表反转之后打印</p><p>​        2：方法二：利用栈这个数据结构，将各个节点压入栈中，然后利用栈的先进后出的特点，实现逆序打印效果</p><p>​        3：方法三：循环，判断temp是否是尾结点，打印尾结点，把尾结点前一结点.next赋值为null，并且重置temp=head.next；如果最后只有一个节点，即head.next=temp，且temp.next==null，则打印temp然后退出循环</p><p>​        4：方法四：递归</p><p>​        注意：操作链表时，一定要注意链表是否已经改变！</p><p>​    9：多个链表的合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line">package com.it.com.it.linkedlist;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">//链表实现水浒英雄的增删改查</span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试，先创建节点</span><br><span class="line">        HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);</span><br><span class="line">        HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);</span><br><span class="line">        HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line">        //创建链表</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line">        //直接加入</span><br><span class="line">//        singleLinkedList.add(hero1);</span><br><span class="line">//        singleLinkedList.add(hero4);</span><br><span class="line">//        singleLinkedList.add(hero2);</span><br><span class="line">//        singleLinkedList.add(hero3);</span><br><span class="line">        //按照编号添加</span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        //测试修改代码</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        HeroNode heroNode = new HeroNode(2, &quot;小卢&quot;, &quot;玉麒麟~~~&quot;);</span><br><span class="line">        singleLinkedList.update(heroNode);</span><br><span class="line">        //打印</span><br><span class="line">        System.out.println(&quot;修改之后链表的情况&quot;);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        //删除节点</span><br><span class="line">        singleLinkedList.del(1);</span><br><span class="line">//        singleLinkedList.del(4);</span><br><span class="line">//        singleLinkedList.del(2);</span><br><span class="line">//        singleLinkedList.del(3);</span><br><span class="line">        System.out.println(&quot;删除之后链表的情况&quot;);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        //测试链表节点个数</span><br><span class="line">//        System.out.println(&quot;有效节点个数&quot; + getLength(singleLinkedList.getHead()));</span><br><span class="line">        //测试倒数第k个节点</span><br><span class="line">//        int index = 3;</span><br><span class="line">//        HeroNode res = findLastIndexNode(singleLinkedList.getHead(), index);</span><br><span class="line">//        System.out.println(&quot;res=&quot; + res);</span><br><span class="line">        //测试反转链表</span><br><span class="line">//        System.out.println(&quot;反转之后链表是：&quot;);//这个方法改变了链表的结构</span><br><span class="line">//        reverseList(singleLinkedList.getHead());</span><br><span class="line">        //测试反转打印</span><br><span class="line">        System.out.println(&quot;反转打印方式二，栈方法：&quot;);</span><br><span class="line">        singleLinkedList.reversePrint();</span><br><span class="line">        System.out.println(&quot;反转打印方式一：&quot;);//这个方法该表了链表的结构</span><br><span class="line">        singleLinkedList.printReverse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义singleLinkedList管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //初始化一个头结点，头结点不要动,不存放具体数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    public HeroNode getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点到单向链表,这里没考虑排名</span><br><span class="line">    //1:找到最后节点（next域为null），把最后节点的next域指向新的节点</span><br><span class="line">    public void add(HeroNode heroNode) &#123;</span><br><span class="line">//因为head节点不能动，因此我们需要一个辅助遍历temp指针，来移动</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            if (temp.next == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到，就将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //当退出循环时，temp就指向了链表的最后</span><br><span class="line">        //将最后节点的next指向新的节点</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种方式添加英雄，如果有这个排名，则添加失败，并给出提示</span><br><span class="line">    public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">        //因为是单链表，因为我们找到的temp是位于添加位置的前一个节点，否则无法添加</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = false;//标识添加编号是否存在，默认为false</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp.next == null) &#123;//说明temp已经在链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125; else if (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">                //位置找到，该节点添加到temp和temp.next之间插入</span><br><span class="line">                break;</span><br><span class="line">            &#125; else if (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                flag = true;//说明编号存在</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;//后移，遍历链表</span><br><span class="line">        &#125;</span><br><span class="line">        //退出循环之后，判断flag值</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            System.out.printf(&quot;准备插入的英雄的编号%d已经存在\n&quot;, heroNode.no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //插入到链表中，temp的后面</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改节点信息，根据no编号来修改，即no编号不能改</span><br><span class="line">    public void update(HeroNode newHeroNode) &#123;</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //找到需要修改的节点，根据no编号</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        boolean flag = false;//表示是否找到该节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;//链表已经遍历结束</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                //找到节点</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //退出循环之后，根据flag判断是否找到要修改的节点</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;没找到编号为%d的节点，不能修改\n&quot;, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除节点</span><br><span class="line">//说明：是temp.next.no和需要删除的节点的no比较</span><br><span class="line">    public void del(int no) &#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = false;//标志是否找到待删除的节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp.next == null) &#123;</span><br><span class="line">                break;//到达链表尾部</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.next.no == no) &#123;</span><br><span class="line">                //找到待删除节点的前一个节点temp</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断flag</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            //可以删除</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;要删除的%d节点不存在\n&quot;, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //统计链表节点个数：去除头结点</span><br><span class="line">    public static int getLength(HeroNode head) &#123;</span><br><span class="line">        int length = 0;</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            HeroNode temp = head.next;</span><br><span class="line">            while (temp != null) &#123;</span><br><span class="line">                length++;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取单链表的倒数第K个节点</span><br><span class="line">    public static HeroNode findLastIndexNode(HeroNode hero, int index) &#123;</span><br><span class="line">        if (hero.next == null) &#123;</span><br><span class="line">            //链表为空</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //第一次遍历得到链表的长度（节点个数）</span><br><span class="line">        int size = getLength(hero);</span><br><span class="line">        //第二次遍历，先做index校验，是否合理</span><br><span class="line">        if (index &lt;= 0 || index &gt; size) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义一个辅助遍历temp</span><br><span class="line">        HeroNode temp = hero.next;</span><br><span class="line">        //往后数size-index个</span><br><span class="line">        for (int i = 0; i &lt; size - index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历链表，使用辅助变量遍历，因为head不能动</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //因为头结点不能动，所以我们需要一个辅助遍历来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //判断是否到链表的最后</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //输出节点信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            //temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //单链表反转</span><br><span class="line">    public static void reverseList(HeroNode head) &#123;</span><br><span class="line">        //如果当前链表为空，或者只有一个节点，无需反转，直接返回</span><br><span class="line">        if (head.next == null || head.next.next == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义一个辅助指针，帮助我们遍历原来链表</span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        HeroNode next = null;//指向当前节点cur的下一个节点，作为中间变量</span><br><span class="line">        int sum = getLength(head);</span><br><span class="line">        //定义反转链表,注意此时的head在改变，所以提前获取到固定长度</span><br><span class="line">        HeroNode reverserHead = new HeroNode(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line">        for (int i = 0; i &lt; sum; i++) &#123;</span><br><span class="line">            //给原链表下个节点赋值,后续把next赋值给cur，达到移动的效果</span><br><span class="line">            next = cur.next;</span><br><span class="line">            //拼接操作，把reverserHead.next给cur.next,再把cur节点作为reverserHead.next</span><br><span class="line">            cur.next = reverserHead.next;</span><br><span class="line">            reverserHead.next = cur;</span><br><span class="line">            //next赋值给cur，达到移动的效果</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历反转链表，这里也可以直接把反转链表的next赋值给原来的head.next，直接用用来的list（）方法遍历</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (reverserHead.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //因为头结点不能动，所以我们需要一个辅助遍历来遍历</span><br><span class="line">        HeroNode temp = reverserHead.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //判断是否到链表的最后</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //输出节点信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            //temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printReverse() &#123;</span><br><span class="line">        HeroNode temp = head;//temp</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == head &amp;&amp; temp.next.next == null) &#123;</span><br><span class="line">                System.out.println(temp.next);</span><br><span class="line">                break;</span><br><span class="line">            &#125;//temp代表倒数第二个节点</span><br><span class="line">            if (temp.next.next == null) &#123;</span><br><span class="line">                System.out.println(temp.next);</span><br><span class="line">                temp.next = null;</span><br><span class="line">                temp = head;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //方式二</span><br><span class="line">    public void reversePrint() &#123;</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个栈，将各个节点压入栈中</span><br><span class="line">        Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;//cur后移</span><br><span class="line">        &#125;</span><br><span class="line">        //将栈中的节点进行打印，pop出栈,先进后出</span><br><span class="line">        while (stack.size() &gt; 0) &#123;</span><br><span class="line">            System.out.println(stack.pop());//后进先出</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建heroNode节点,每个heroNode对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode next;//指向下一个节点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int hNo, String hName, String hNickname) &#123;</span><br><span class="line">        this.no = hNo;</span><br><span class="line">        this.name = hName;</span><br><span class="line">        this.nickname = hNickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写tostring</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode[no=&quot; + no + &quot;,name=&quot; + name + &quot;,nickname=&quot; + nickname + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五：双向链表"><a href="#五：双向链表" class="headerlink" title="五：双向链表"></a>五：双向链表</h1><p>1：单向链表，查找只能一个方向next，而双休链表可以双向</p><p>2：单向链表不能自我删除，需要靠辅助节点temp</p><p>3：双向链表的遍历，添加，修改，删除的操作思路</p><p>​    添加步骤（默认添加到双向链表的最后）：</p><p>​    1：先找到双向链表的最后节点</p><p>​    2：temp.next=newHoroNode</p><p>​    3：newHoroNode.pre=temp</p><p>​    删除步骤：</p><p>​    1: 直接找到要删除的节点，比如temp</p><p>​    2：temp.pre.next=temp.next</p><p>​    3：temp.next.pre=temp.pre</p><p>4：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">package com.it.com.it.linkedlist;</span><br><span class="line"></span><br><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 测试</span><br><span class="line">        System.out.println(&quot;双向链表的测试&quot;);</span><br><span class="line">        // 先创建节点</span><br><span class="line">        HeroNode2 hero1 = new HeroNode2(1, &quot;宋江&quot;, &quot;及时雨&quot;);</span><br><span class="line">        HeroNode2 hero2 = new HeroNode2(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode2 hero3 = new HeroNode2(3, &quot;吴用&quot;, &quot;智多星&quot;);</span><br><span class="line">        HeroNode2 hero4 = new HeroNode2(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line">        // 创建一个双向链表</span><br><span class="line">        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();</span><br><span class="line">        // 添加数据</span><br><span class="line">        doubleLinkedList.add(hero1);</span><br><span class="line">        doubleLinkedList.add(hero2);</span><br><span class="line">        doubleLinkedList.add(hero3);</span><br><span class="line">        doubleLinkedList.add(hero4);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        // 修改</span><br><span class="line">        HeroNode2 newHeroNode = new HeroNode2(4, &quot;公孙胜&quot;, &quot;入云龙&quot;);</span><br><span class="line">        doubleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(&quot;修改后的链表情况&quot;);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        // 删除</span><br><span class="line">        doubleLinkedList.del(3);</span><br><span class="line">        System.out.println(&quot;删除后的链表情况~~&quot;);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个双向链表的类</span><br><span class="line">class DoubleLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    // 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">    private HeroNode2 head = new HeroNode2(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    // 返回头节点</span><br><span class="line">    public HeroNode2 getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历双向链表的方法</span><br><span class="line">    // 显示链表[遍历]</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        // 判断链表是否为空</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 判断是否到链表最后</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 输出节点的信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            // 将temp后移， 一定小心</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加一个节点到双向链表的最后.</span><br><span class="line">    public void add(HeroNode2 heroNode) &#123;</span><br><span class="line"></span><br><span class="line">        // 因为head节点不能动，因此我们需要一个辅助遍历 temp</span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        // 遍历链表，找到最后</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 找到链表的最后</span><br><span class="line">            if (temp.next == null) &#123;//</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果没有找到最后, 将将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当退出while循环时，temp就指向了链表的最后</span><br><span class="line">        // 形成一个双向链表</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样</span><br><span class="line">    // 只是 节点类型改成 HeroNode2</span><br><span class="line">    public void update(HeroNode2 newHeroNode) &#123;</span><br><span class="line">        // 判断是否空</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空~&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到需要修改的节点, 根据no编号</span><br><span class="line">        // 定义一个辅助变量</span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        boolean flag = false; // 表示是否找到该节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break; // 已经遍历完链表</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                // 找到</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 根据flag 判断是否找到要修改的节点</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; else &#123; // 没有找到</span><br><span class="line">            System.out.printf(&quot;没有找到 编号 %d 的节点，不能修改\n&quot;, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从双向链表中删除一个节点,</span><br><span class="line">    // 说明</span><br><span class="line">    // 1 对于双向链表，我们可以直接找到要删除的这个节点</span><br><span class="line">    // 2 找到后，自我删除即可</span><br><span class="line">    public void del(int no) &#123;</span><br><span class="line"></span><br><span class="line">        // 判断当前链表是否为空</span><br><span class="line">        if (head.next == null) &#123;// 空链表</span><br><span class="line">            System.out.println(&quot;链表为空，无法删除&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode2 temp = head.next; // 辅助变量(指针)</span><br><span class="line">        boolean flag = false; // 标志是否找到待删除节点的</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == null) &#123; // 已经到链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no == no) &#123;</span><br><span class="line">                // 找到的待删除节点的前一个节点temp</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next; // temp后移，遍历</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断flag</span><br><span class="line">        if (flag) &#123; // 找到</span><br><span class="line">            // 可以删除</span><br><span class="line">            // temp.next = temp.next.next;[单向链表]</span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            // 这里我们的代码有问题?</span><br><span class="line">            // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span><br><span class="line">            if (temp.next != null) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;要删除的 %d 节点不存在\n&quot;, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义HeroNode2 ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode2 next; // 指向下一个节点, 默认为null</span><br><span class="line">    public HeroNode2 pre; // 指向前一个节点, 默认为null</span><br><span class="line">    // 构造器</span><br><span class="line"></span><br><span class="line">    public HeroNode2(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为了显示方法，我们重新toString</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickname=&quot; + nickname + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六：单向环形链表（约瑟夫环）"><a href="#六：单向环形链表（约瑟夫环）" class="headerlink" title="六：单向环形链表（约瑟夫环）"></a>六：单向环形链表（约瑟夫环）</h1><p>1：约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3，1。 </p><p>2：创建环形链表思路</p><p>​    1：先创建第一个节点，让first指向该节点，加入到已有的环形链表中即可</p><p>​    2：后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中</p><p>3：遍历环形链表</p><p>​    1：先让一个辅助指针（变量）curBoy,指向first节点</p><p>​    2：通过while循环遍历该环形链表即可，curBoy.next==first，结束</p><p>4：创建、遍历环形链表代码实现</p><p>5：出圈思路</p><p>​    1：根据用户的输入，生成一个小孩出圈的顺序</p><p>​    2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">package com.it.com.it.linkedlist;</span><br><span class="line"></span><br><span class="line">//约瑟夫问题：环形链表解决</span><br><span class="line">public class Josepfu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(10);</span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line">        //测试小孩出圈</span><br><span class="line">        circleSingleLinkedList.countBoy(1, 2, 10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建环形链表</span><br><span class="line">class CircleSingleLinkedList &#123;</span><br><span class="line">    //创建一个first节点，无编号</span><br><span class="line">    private Boy first = null;</span><br><span class="line"></span><br><span class="line">    //添加节点，构建成环形链表</span><br><span class="line">    public void addBoy(int nums) &#123;</span><br><span class="line">        //nums表示环形链表节点个数</span><br><span class="line">        if (nums &lt; 1) &#123;</span><br><span class="line">            System.out.println(&quot;nums值不正确&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy curBoy = null;//辅助指针，帮助构建环形链表</span><br><span class="line">        //使用for循环创建环形链表</span><br><span class="line">        for (int i = 1; i &lt;= nums; i++) &#123;</span><br><span class="line">            //根据编号创建小孩节点</span><br><span class="line">            Boy boy = new Boy(i);</span><br><span class="line">            //给第一个小孩赋值</span><br><span class="line">            if (i == 1) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);</span><br><span class="line">                //让curBoy指向第一个小孩，因为first不能变动，需要让curBoy辅助</span><br><span class="line">                curBoy = first;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //构建环</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                //curBoy后移</span><br><span class="line">                curBoy = curBoy.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历环形链表</span><br><span class="line">    public void showBoy() &#123;</span><br><span class="line">        //判断链表是否为空</span><br><span class="line">        if (first == null) &#123;</span><br><span class="line">            System.out.println(&quot;没有小孩--&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //使用辅助指针帮助遍历</span><br><span class="line">        Boy curBoy = first;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.printf(&quot;小孩的编号%d:\n&quot;, curBoy.getNo());</span><br><span class="line">            //已经遍历完毕</span><br><span class="line">            if (curBoy.getNext() == first) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">//            curBoy后移</span><br><span class="line">            curBoy = curBoy.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //根据用户的输入，计算出圈的顺序</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param startNo  表示从第几个小孩开始数数</span><br><span class="line">     * @param countNum 表示数几下</span><br><span class="line">     * @param nums     表示最初有几个小孩，作为校验</span><br><span class="line">     */</span><br><span class="line">    public void countBoy(int startNo, int countNum, int nums) &#123;</span><br><span class="line">        if (first == null || startNo &lt; 1 || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(&quot;参数有误，请重新输入&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个辅助指针，帮助小孩出圈</span><br><span class="line">        Boy helper = first;</span><br><span class="line">        //使helper指向最后节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //相等说明helper在最后</span><br><span class="line">            if (helper.getNext() == first) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //helper后移</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //报数前，先让first和helper移动startNo-1次</span><br><span class="line">        for (int i = 0; i &lt; startNo - 1; i++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //当小孩报数时，让first和helper指针同时移动countNum-1次，然后出圈</span><br><span class="line">        //这里是一个循环操作，知道圈中只有一个节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //说明圈中只有一个节点</span><br><span class="line">            if (helper == first) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //让first和helper指针同时移动countNum-1次，然后出圈</span><br><span class="line">            for (int i = 0; i &lt; countNum - 1; i++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            //这时first指向的节点就是要出圈的节点</span><br><span class="line">            System.out.printf(&quot;小孩%d出圈\n&quot;, first.getNo());</span><br><span class="line">            //first指向的节点出圈</span><br><span class="line">            first = first.getNext();//使first后移</span><br><span class="line">            helper.setNext(first);//使helper的next指向first</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;最后留在圈中的小孩编号是%d\n&quot;, first.getNo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建一个boy，表示一个节点</span><br><span class="line">class Boy &#123;</span><br><span class="line">    private int no;</span><br><span class="line">    private Boy next;//指向下一个节点，默认null</span><br><span class="line"></span><br><span class="line">    public Boy(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Boy getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(Boy next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1：数据结构分类https-leetcode-cn-com-interview&quot;&gt;&lt;a href=&quot;#1：数据结构分类https-leetcode-cn-com-interview&quot; class=&quot;headerlink&quot; title=&quot;1：数据结构分类https:
      
    
    </summary>
    
    
      <category term="java" scheme="https://yanyubing.xyz/categories/java/"/>
    
    
      <category term="java" scheme="https://yanyubing.xyz/tags/java/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鄢玉兵的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yanyubing.xyz/"/>
  <updated>2019-11-27T08:55:10.889Z</updated>
  <id>https://yanyubing.xyz/</id>
  
  <author>
    <name>鄢玉兵</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java数据结构和算法(二)栈</title>
    <link href="https://yanyubing.xyz/2019/11/27/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(%E4%BA%8C)%E6%A0%88/"/>
    <id>https://yanyubing.xyz/2019/11/27/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(%E4%BA%8C)%E6%A0%88/</id>
    <published>2019-11-27T08:55:10.889Z</published>
    <updated>2019-11-27T08:55:10.889Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法(一）数组，队列，链表</title>
    <link href="https://yanyubing.xyz/2019/11/27/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(%E4%B8%80%EF%BC%89%E6%95%B0%E7%BB%84%EF%BC%8C%E9%98%9F%E5%88%97%EF%BC%8C%E9%93%BE%E8%A1%A8/"/>
    <id>https://yanyubing.xyz/2019/11/27/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(%E4%B8%80%EF%BC%89%E6%95%B0%E7%BB%84%EF%BC%8C%E9%98%9F%E5%88%97%EF%BC%8C%E9%93%BE%E8%A1%A8/</id>
    <published>2019-11-27T08:52:42.617Z</published>
    <updated>2019-11-27T08:52:43.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1：数据结构分类https-leetcode-cn-com-interview"><a href="#1：数据结构分类https-leetcode-cn-com-interview" class="headerlink" title="1：数据结构分类https://leetcode-cn.com/interview/"></a>1：数据结构分类<a href="https://leetcode-cn.com/interview/" target="_blank" rel="noopener">https://leetcode-cn.com/interview/</a></h2><p>线性结构</p><p>线性结构分类：数组，队列，链表，栈</p><p>储存结构分类：顺序储存结构和链式储存结构</p><p>非线性结构</p><p>非线性结构分类：二维数组，多维数组，广义表，树结构，图结构</p><h2 id="2：稀疏数组"><a href="#2：稀疏数组" class="headerlink" title="2：稀疏数组"></a>2：稀疏数组</h2><p>1：基本介绍博客：<a href="https://www.cnblogs.com/blizzawang/p/11411602.html" target="_blank" rel="noopener">https://www.cnblogs.com/blizzawang/p/11411602.html</a> </p><p>2：逻辑：稀疏数组第一行第一列表示二维数组的行数，第一行第二列表示二维数组的列数，第一行第三列表示二维数组非0的个数，下列每一行的三个数分别表示哪一行，哪一列，对应的数是多少。</p><p>3：转换为稀疏数组主要用于对数据的压缩</p><p>4：二维数组与稀疏数组转换代码实现，核心思想为数据的对应转换！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">1：二维数组转换为稀疏数组思路：</span><br><span class="line">1.遍历原始的二维数组，得到有数据的个数n</span><br><span class="line">2.根据sum就可以创建稀疏数组sparseArr int[n+1][3]</span><br><span class="line">3.将二维数组的有效数据存入到稀疏数组</span><br><span class="line"></span><br><span class="line">2：稀疏数组转换为二维数组：</span><br><span class="line">1：先读取稀疏数组的第一行</span><br><span class="line">2：根据第一行的数据创建原始二位数组</span><br><span class="line">3：在读取稀疏数组后几行的数据，并赋给原始二维数组即可</span><br><span class="line"></span><br><span class="line">package com.it.sparsearray;</span><br><span class="line"></span><br><span class="line">//棋盘二维数组转换为稀疏数组</span><br><span class="line">public class SparseArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //先创建一个原始的二维数组 11*11</span><br><span class="line">        //0表示没有棋子，1表示黑子，2表示白子</span><br><span class="line">        int[][] chessArr1 = new int[11][11];</span><br><span class="line">        chessArr1[1][2] = 1;</span><br><span class="line">        chessArr1[2][3] = 2;</span><br><span class="line">        //原始的二维数组</span><br><span class="line">        for (int[] ints : chessArr1) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        //将二维数组转为稀疏数组的思路</span><br><span class="line">        //1：先遍历二维数组，得到非0的个数</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 11; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 11; j++) &#123;</span><br><span class="line">                if (chessArr1[i][j] != 0) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //2：创建对应的稀疏数组</span><br><span class="line">        int sparseArr[][] = new int[sum + 1][3];</span><br><span class="line">        //给稀疏数字赋值</span><br><span class="line">        sparseArr[0][0] = 11;</span><br><span class="line">        sparseArr[0][1] = 11;</span><br><span class="line">        sparseArr[0][2] = sum;</span><br><span class="line">        //遍历二维数组，将非0的值存放到稀疏数组中</span><br><span class="line">        int count = 0;//count用于记录是第几个非0数字</span><br><span class="line">        for (int i = 0; i &lt; 11; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 11; j++) &#123;</span><br><span class="line">                if (chessArr1[i][j] != 0) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][0] = i;</span><br><span class="line">                    sparseArr[count][1] = j;</span><br><span class="line">                    sparseArr[count][2] = chessArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //输出稀疏数组</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;得到的稀疏数组如下&quot;);</span><br><span class="line">        for (int i = 0; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;%d\t%d\t%d\t\n&quot;, sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);</span><br><span class="line">        &#125;</span><br><span class="line">        //根据稀疏数组的第一行数据，创建元素二维数组</span><br><span class="line">        int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">        //输出恢复后的二维数组</span><br><span class="line">        System.out.println(&quot;转换为二维数组如下&quot;);</span><br><span class="line">        for (int i = 1; i &lt; sparseArr[0][2] + 1; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int[] ints : chessArr2) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3：队列"><a href="#3：队列" class="headerlink" title="3：队列"></a>3：队列</h1><p>1：队列基本介绍</p><p>​    队列是一个有序表，可以用数组或者链表来实现</p><p>​    队列为先入先出原则</p><p>​    队列加数据从尾部开始加，首部不变；取数据从首部开始取，尾部不变</p><p>​    核心思想：普通队列，如队列大小为10，那么只能add10次数据，因为数组索引用过已经无法再次使用；而环形队列判断队列是否满的依据则是队列中是否已经占满数据。</p><p>​    注意：取出数据之后数组元素并未被移除，环形队列也是</p><p>2：普通队列实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">package com.it.queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayQueue queue = new ArrayQueue(5);</span><br><span class="line">        char key = &apos; &apos;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        boolean loop = true;</span><br><span class="line">        //输出一个菜单</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">            System.out.println(&quot;e(exit):退出队列&quot;);</span><br><span class="line">            System.out.println(&quot;a(add):添加数据到队列&quot;);</span><br><span class="line">            System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;h(head):查看队列的数据&quot;);</span><br><span class="line">            key = scanner.next().charAt(0);//接收一个字符</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &apos;s&apos;://显示队列</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;a&apos;://添加数据</span><br><span class="line">                    System.out.println(&quot;请输入一个数&quot;);</span><br><span class="line">                    int value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;g&apos;://取出数据</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = queue.getQueue();</span><br><span class="line">                        System.out.printf(&quot;取出的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;h&apos;://查看队列头的数据是什么</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = queue.headQueue();</span><br><span class="line">                        System.out.printf(&quot;队列头的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;e&apos;://退出</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;--------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用数组模拟队列，编写一个ArrayQueue类</span><br><span class="line">class ArrayQueue &#123;</span><br><span class="line">    private int maxSize;//表示数组最大容量</span><br><span class="line">    private int front;//队列头</span><br><span class="line">    private int rear;//队列尾</span><br><span class="line">    private int[] arr;//该数据用于队列存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    //创建队列的构造器,数组最大容量</span><br><span class="line">    public ArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = -1;//指向队列头部的前一个位置</span><br><span class="line">        rear = -1;//指向队列尾部</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        //当尾部到达了队列最后一个无法添加数据</span><br><span class="line">        return rear == maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        //当队列头与队列尾相等时为空</span><br><span class="line">        return rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;队列满，无法加入数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //未满，可以加入数据</span><br><span class="line">        rear++;//让rear后移</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getQueue() &#123;</span><br><span class="line">        //判断队列是否空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            //通过抛出异常处理</span><br><span class="line">            throw new RuntimeException(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //front后移</span><br><span class="line">        front++;</span><br><span class="line">        //获取数据</span><br><span class="line">        return arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showQueue() &#123;</span><br><span class="line">        //遍历</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;队列空的，没数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d]=%d\n&quot;, i, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int headQueue() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列空的，没数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //front指向数组头部前一位</span><br><span class="line">        return arr[front + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3：环形队列实现思路</p><p>​    1：front变量的含义调整，front指向队列的第一个元素，也就是arr[front]就是队列的第一个元素，front初始值默认为0，rear的初始值为0</p><p>​    2：rear变量的含义做一个调整，rear指向队列最后一个元素的后一个位置，因为希望空出一个空间作为约定</p><p>​    3：当队列满时，条件是（rear+1）%maxSize=front</p><p>​    4：当队列为空的条件：rear=front</p><p>​    5：当我们这样分析，队列中有效的数据个数（rear+maxSize-front)%maxSize</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">//环形队列</span><br><span class="line">package com.it.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class CircleArrayQueue &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CircleArray circleArray = new CircleArray(5);</span><br><span class="line">        char key = &apos; &apos;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        boolean loop = true;</span><br><span class="line">        System.out.println(&quot;测试环形队列！&quot;);</span><br><span class="line">        //输出一个菜单</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">            System.out.println(&quot;e(exit):退出队列&quot;);</span><br><span class="line">            System.out.println(&quot;a(add):添加数据到队列&quot;);</span><br><span class="line">            System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;h(head):查看队列的数据&quot;);</span><br><span class="line">            key = scanner.next().charAt(0);//接收一个字符</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &apos;s&apos;://显示队列</span><br><span class="line">                    circleArray.showQueue();</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;a&apos;://添加数据</span><br><span class="line">                    System.out.println(&quot;请输入一个数&quot;);</span><br><span class="line">                    int value = scanner.nextInt();</span><br><span class="line">                    circleArray.addQueue(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;g&apos;://取出数据</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.getQueue();</span><br><span class="line">                        System.out.printf(&quot;取出的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;h&apos;://查看队列头的数据是什么</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.headQueue();</span><br><span class="line">                        System.out.printf(&quot;队列头的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;e&apos;://退出</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;--------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用数组模拟队列，编写一个ArrayQueue类</span><br><span class="line">class CircleArray &#123;</span><br><span class="line">    private int maxSize;//表示数组最大容量</span><br><span class="line">    //    front变量的含义调整，front指向队列的第一个元素，也就是arr[front]就是队列的第一个元素，front初始值默认为0，rear的初始值为0</span><br><span class="line">    private int front;//队列头</span><br><span class="line">    //    rear变量的含义做一个调整，rear指向队列最后一个元素的后一个位置，因为希望空出一个空间作为约定</span><br><span class="line">    private int rear;//队列尾</span><br><span class="line">    private int[] arr;//该数据用于队列存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    //创建队列的构造器,数组最大容量</span><br><span class="line">    public CircleArray(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = 0;//指向队列头部的前一个位置</span><br><span class="line">        rear = 0;//指向队列尾部</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        //判断是否满</span><br><span class="line">        return (rear + 1) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        //当队列头与队列尾相等时为空</span><br><span class="line">        return rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;队列满，无法加入数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //未满，可以加入数据</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        rear = (rear + 1) % maxSize;//让rear后移，这里必须考虑取模</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getQueue() &#123;</span><br><span class="line">        //判断队列是否空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            //通过抛出异常处理</span><br><span class="line">            throw new RuntimeException(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //这里分析出front对应的值保留到一个临时变量</span><br><span class="line">        //将front后移,考虑取模</span><br><span class="line">        //将临时变量的变量返回</span><br><span class="line">        int value = arr[front];</span><br><span class="line">        front = (front + 1) % maxSize;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showQueue() &#123;</span><br><span class="line">        //遍历</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;队列空的，没数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //思路，从front开始遍历</span><br><span class="line">        for (int i = front; i &lt; (front + size()); i++) &#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d]=%d\n&quot;, i % maxSize, arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //求出当前队列有效数据的个数，为了遍历</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int headQueue() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列空的，没数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //front指向数组头部前一位</span><br><span class="line">        return arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4：单向链表"><a href="#4：单向链表" class="headerlink" title="4：单向链表"></a>4：单向链表</h1><p>1：链表基本介绍</p><p>​    链表是以节点的方式来储存，链式储存</p><p>​    每个节点包含data域，next域：指向下一个节点</p><p>​    链表的各个节点不一定是连续储存</p><p>​    链表分带头节点的链表和没有头节点的链表，根据实际需求来确定</p><p>2：单链表的创建（添加），显示单向链表的分析</p><p>​    head节点：不存放具体的数据，作用就是表示单链表头</p><p>​    先创建一个head头节点，作用就是单链表的头</p><p>​    后面我们每添加一个节点，就直接加入到链表的最后</p><p>​    通过一个辅助的指针，帮助遍历</p><p>3：单链表代码实现</p><p>​    1：直接添加到英雄的尾部</p><p>​    2：考虑节点排名添加（插入）</p><p>​    思路：</p><p>​        1：首先找到新添加的节点位置，通过辅助变量（指针）</p><p>​        2：新的节点.next=temp.next</p><p>​        3：将temp.next=新的节点</p><p>​        4：可以在内存中实现排序</p><p>​    3：修改节点</p><p>​    4：删除节点</p><p>​        1：找到需要删除节点的前一个节点</p><p>​        2：temp.next=temp.next.next</p><p>​        3：被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收</p><p>​    5：求单链表的节点个数</p><p>​        1：遍历（temp后移）并且length++；</p><p>​    6：查找单链表中的倒数第k个节点</p><p>​        1：编写一个方法，接收head节点，同时接收一个index</p><p>​        2：index表示倒数第index的索引</p><p>​        3：先遍历链表，拿到链表所有个数getLength，再获取第n-index节点信息</p><p>​    7：链表的反转</p><p>​        1：创建新的链表（定义一个新的链表头reverse）</p><p>​        2：遍历原链表可以获取顺数每个节点的信息</p><p>​        3：每遍历一个节点就将其取出并放在新链表的最前方</p><p>​        4：原来链表的head.next=reverse.next</p><p>​    8：链表的逆序打印</p><p>​        1：方法一：单链表反转之后打印</p><p>​        2：方法二：利用栈这个数据结构，将各个节点压入栈中，然后利用栈的先进后出的特点，实现逆序打印效果</p><p>​        3：方法三：循环，判断temp是否是尾结点，打印尾结点，把尾结点前一结点.next赋值为null，并且重置temp=head.next；如果最后只有一个节点，即head.next=temp，且temp.next==null，则打印temp然后退出循环</p><p>​        4：方法四：递归</p><p>​        注意：操作链表时，一定要注意链表是否已经改变！</p><p>​    9：多个链表的合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line">package com.it.com.it.linkedlist;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">//链表实现水浒英雄的增删改查</span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试，先创建节点</span><br><span class="line">        HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);</span><br><span class="line">        HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);</span><br><span class="line">        HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line">        //创建链表</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line">        //直接加入</span><br><span class="line">//        singleLinkedList.add(hero1);</span><br><span class="line">//        singleLinkedList.add(hero4);</span><br><span class="line">//        singleLinkedList.add(hero2);</span><br><span class="line">//        singleLinkedList.add(hero3);</span><br><span class="line">        //按照编号添加</span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        //测试修改代码</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        HeroNode heroNode = new HeroNode(2, &quot;小卢&quot;, &quot;玉麒麟~~~&quot;);</span><br><span class="line">        singleLinkedList.update(heroNode);</span><br><span class="line">        //打印</span><br><span class="line">        System.out.println(&quot;修改之后链表的情况&quot;);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        //删除节点</span><br><span class="line">        singleLinkedList.del(1);</span><br><span class="line">//        singleLinkedList.del(4);</span><br><span class="line">//        singleLinkedList.del(2);</span><br><span class="line">//        singleLinkedList.del(3);</span><br><span class="line">        System.out.println(&quot;删除之后链表的情况&quot;);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        //测试链表节点个数</span><br><span class="line">//        System.out.println(&quot;有效节点个数&quot; + getLength(singleLinkedList.getHead()));</span><br><span class="line">        //测试倒数第k个节点</span><br><span class="line">//        int index = 3;</span><br><span class="line">//        HeroNode res = findLastIndexNode(singleLinkedList.getHead(), index);</span><br><span class="line">//        System.out.println(&quot;res=&quot; + res);</span><br><span class="line">        //测试反转链表</span><br><span class="line">//        System.out.println(&quot;反转之后链表是：&quot;);//这个方法改变了链表的结构</span><br><span class="line">//        reverseList(singleLinkedList.getHead());</span><br><span class="line">        //测试反转打印</span><br><span class="line">        System.out.println(&quot;反转打印方式二，栈方法：&quot;);</span><br><span class="line">        singleLinkedList.reversePrint();</span><br><span class="line">        System.out.println(&quot;反转打印方式一：&quot;);//这个方法该表了链表的结构</span><br><span class="line">        singleLinkedList.printReverse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义singleLinkedList管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //初始化一个头结点，头结点不要动,不存放具体数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    public HeroNode getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点到单向链表,这里没考虑排名</span><br><span class="line">    //1:找到最后节点（next域为null），把最后节点的next域指向新的节点</span><br><span class="line">    public void add(HeroNode heroNode) &#123;</span><br><span class="line">//因为head节点不能动，因此我们需要一个辅助遍历temp指针，来移动</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            if (temp.next == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到，就将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //当退出循环时，temp就指向了链表的最后</span><br><span class="line">        //将最后节点的next指向新的节点</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种方式添加英雄，如果有这个排名，则添加失败，并给出提示</span><br><span class="line">    public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">        //因为是单链表，因为我们找到的temp是位于添加位置的前一个节点，否则无法添加</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = false;//标识添加编号是否存在，默认为false</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp.next == null) &#123;//说明temp已经在链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125; else if (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">                //位置找到，该节点添加到temp和temp.next之间插入</span><br><span class="line">                break;</span><br><span class="line">            &#125; else if (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                flag = true;//说明编号存在</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;//后移，遍历链表</span><br><span class="line">        &#125;</span><br><span class="line">        //退出循环之后，判断flag值</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            System.out.printf(&quot;准备插入的英雄的编号%d已经存在\n&quot;, heroNode.no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //插入到链表中，temp的后面</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改节点信息，根据no编号来修改，即no编号不能改</span><br><span class="line">    public void update(HeroNode newHeroNode) &#123;</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //找到需要修改的节点，根据no编号</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        boolean flag = false;//表示是否找到该节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;//链表已经遍历结束</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                //找到节点</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //退出循环之后，根据flag判断是否找到要修改的节点</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;没找到编号为%d的节点，不能修改\n&quot;, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除节点</span><br><span class="line">//说明：是temp.next.no和需要删除的节点的no比较</span><br><span class="line">    public void del(int no) &#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = false;//标志是否找到待删除的节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp.next == null) &#123;</span><br><span class="line">                break;//到达链表尾部</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.next.no == no) &#123;</span><br><span class="line">                //找到待删除节点的前一个节点temp</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断flag</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            //可以删除</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;要删除的%d节点不存在\n&quot;, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //统计链表节点个数：去除头结点</span><br><span class="line">    public static int getLength(HeroNode head) &#123;</span><br><span class="line">        int length = 0;</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            HeroNode temp = head.next;</span><br><span class="line">            while (temp != null) &#123;</span><br><span class="line">                length++;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取单链表的倒数第K个节点</span><br><span class="line">    public static HeroNode findLastIndexNode(HeroNode hero, int index) &#123;</span><br><span class="line">        if (hero.next == null) &#123;</span><br><span class="line">            //链表为空</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //第一次遍历得到链表的长度（节点个数）</span><br><span class="line">        int size = getLength(hero);</span><br><span class="line">        //第二次遍历，先做index校验，是否合理</span><br><span class="line">        if (index &lt;= 0 || index &gt; size) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义一个辅助遍历temp</span><br><span class="line">        HeroNode temp = hero.next;</span><br><span class="line">        //往后数size-index个</span><br><span class="line">        for (int i = 0; i &lt; size - index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历链表，使用辅助变量遍历，因为head不能动</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //因为头结点不能动，所以我们需要一个辅助遍历来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //判断是否到链表的最后</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //输出节点信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            //temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //单链表反转</span><br><span class="line">    public static void reverseList(HeroNode head) &#123;</span><br><span class="line">        //如果当前链表为空，或者只有一个节点，无需反转，直接返回</span><br><span class="line">        if (head.next == null || head.next.next == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义一个辅助指针，帮助我们遍历原来链表</span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        HeroNode next = null;//指向当前节点cur的下一个节点，作为中间变量</span><br><span class="line">        int sum = getLength(head);</span><br><span class="line">        //定义反转链表,注意此时的head在改变，所以提前获取到固定长度</span><br><span class="line">        HeroNode reverserHead = new HeroNode(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line">        for (int i = 0; i &lt; sum; i++) &#123;</span><br><span class="line">            //给原链表下个节点赋值,后续把next赋值给cur，达到移动的效果</span><br><span class="line">            next = cur.next;</span><br><span class="line">            //拼接操作，把reverserHead.next给cur.next,再把cur节点作为reverserHead.next</span><br><span class="line">            cur.next = reverserHead.next;</span><br><span class="line">            reverserHead.next = cur;</span><br><span class="line">            //next赋值给cur，达到移动的效果</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历反转链表，这里也可以直接把反转链表的next赋值给原来的head.next，直接用用来的list（）方法遍历</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (reverserHead.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //因为头结点不能动，所以我们需要一个辅助遍历来遍历</span><br><span class="line">        HeroNode temp = reverserHead.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //判断是否到链表的最后</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //输出节点信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            //temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printReverse() &#123;</span><br><span class="line">        HeroNode temp = head;//temp</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == head &amp;&amp; temp.next.next == null) &#123;</span><br><span class="line">                System.out.println(temp.next);</span><br><span class="line">                break;</span><br><span class="line">            &#125;//temp代表倒数第二个节点</span><br><span class="line">            if (temp.next.next == null) &#123;</span><br><span class="line">                System.out.println(temp.next);</span><br><span class="line">                temp.next = null;</span><br><span class="line">                temp = head;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //方式二</span><br><span class="line">    public void reversePrint() &#123;</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个栈，将各个节点压入栈中</span><br><span class="line">        Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;//cur后移</span><br><span class="line">        &#125;</span><br><span class="line">        //将栈中的节点进行打印，pop出栈,先进后出</span><br><span class="line">        while (stack.size() &gt; 0) &#123;</span><br><span class="line">            System.out.println(stack.pop());//后进先出</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建heroNode节点,每个heroNode对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode next;//指向下一个节点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int hNo, String hName, String hNickname) &#123;</span><br><span class="line">        this.no = hNo;</span><br><span class="line">        this.name = hName;</span><br><span class="line">        this.nickname = hNickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写tostring</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode[no=&quot; + no + &quot;,name=&quot; + name + &quot;,nickname=&quot; + nickname + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五：双向链表"><a href="#五：双向链表" class="headerlink" title="五：双向链表"></a>五：双向链表</h1><p>1：单向链表，查找只能一个方向next，而双休链表可以双向</p><p>2：单向链表不能自我删除，需要靠辅助节点temp</p><p>3：双向链表的遍历，添加，修改，删除的操作思路</p><p>​    添加步骤（默认添加到双向链表的最后）：</p><p>​    1：先找到双向链表的最后节点</p><p>​    2：temp.next=newHoroNode</p><p>​    3：newHoroNode.pre=temp</p><p>​    删除步骤：</p><p>​    1: 直接找到要删除的节点，比如temp</p><p>​    2：temp.pre.next=temp.next</p><p>​    3：temp.next.pre=temp.pre</p><p>4：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">package com.it.com.it.linkedlist;</span><br><span class="line"></span><br><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 测试</span><br><span class="line">        System.out.println(&quot;双向链表的测试&quot;);</span><br><span class="line">        // 先创建节点</span><br><span class="line">        HeroNode2 hero1 = new HeroNode2(1, &quot;宋江&quot;, &quot;及时雨&quot;);</span><br><span class="line">        HeroNode2 hero2 = new HeroNode2(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode2 hero3 = new HeroNode2(3, &quot;吴用&quot;, &quot;智多星&quot;);</span><br><span class="line">        HeroNode2 hero4 = new HeroNode2(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line">        // 创建一个双向链表</span><br><span class="line">        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();</span><br><span class="line">        // 添加数据</span><br><span class="line">        doubleLinkedList.add(hero1);</span><br><span class="line">        doubleLinkedList.add(hero2);</span><br><span class="line">        doubleLinkedList.add(hero3);</span><br><span class="line">        doubleLinkedList.add(hero4);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        // 修改</span><br><span class="line">        HeroNode2 newHeroNode = new HeroNode2(4, &quot;公孙胜&quot;, &quot;入云龙&quot;);</span><br><span class="line">        doubleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(&quot;修改后的链表情况&quot;);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        // 删除</span><br><span class="line">        doubleLinkedList.del(3);</span><br><span class="line">        System.out.println(&quot;删除后的链表情况~~&quot;);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个双向链表的类</span><br><span class="line">class DoubleLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    // 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">    private HeroNode2 head = new HeroNode2(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    // 返回头节点</span><br><span class="line">    public HeroNode2 getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历双向链表的方法</span><br><span class="line">    // 显示链表[遍历]</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        // 判断链表是否为空</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 判断是否到链表最后</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 输出节点的信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            // 将temp后移， 一定小心</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加一个节点到双向链表的最后.</span><br><span class="line">    public void add(HeroNode2 heroNode) &#123;</span><br><span class="line"></span><br><span class="line">        // 因为head节点不能动，因此我们需要一个辅助遍历 temp</span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        // 遍历链表，找到最后</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 找到链表的最后</span><br><span class="line">            if (temp.next == null) &#123;//</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果没有找到最后, 将将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当退出while循环时，temp就指向了链表的最后</span><br><span class="line">        // 形成一个双向链表</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样</span><br><span class="line">    // 只是 节点类型改成 HeroNode2</span><br><span class="line">    public void update(HeroNode2 newHeroNode) &#123;</span><br><span class="line">        // 判断是否空</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空~&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到需要修改的节点, 根据no编号</span><br><span class="line">        // 定义一个辅助变量</span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        boolean flag = false; // 表示是否找到该节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break; // 已经遍历完链表</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                // 找到</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 根据flag 判断是否找到要修改的节点</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; else &#123; // 没有找到</span><br><span class="line">            System.out.printf(&quot;没有找到 编号 %d 的节点，不能修改\n&quot;, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从双向链表中删除一个节点,</span><br><span class="line">    // 说明</span><br><span class="line">    // 1 对于双向链表，我们可以直接找到要删除的这个节点</span><br><span class="line">    // 2 找到后，自我删除即可</span><br><span class="line">    public void del(int no) &#123;</span><br><span class="line"></span><br><span class="line">        // 判断当前链表是否为空</span><br><span class="line">        if (head.next == null) &#123;// 空链表</span><br><span class="line">            System.out.println(&quot;链表为空，无法删除&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode2 temp = head.next; // 辅助变量(指针)</span><br><span class="line">        boolean flag = false; // 标志是否找到待删除节点的</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == null) &#123; // 已经到链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no == no) &#123;</span><br><span class="line">                // 找到的待删除节点的前一个节点temp</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next; // temp后移，遍历</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断flag</span><br><span class="line">        if (flag) &#123; // 找到</span><br><span class="line">            // 可以删除</span><br><span class="line">            // temp.next = temp.next.next;[单向链表]</span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            // 这里我们的代码有问题?</span><br><span class="line">            // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span><br><span class="line">            if (temp.next != null) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;要删除的 %d 节点不存在\n&quot;, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义HeroNode2 ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode2 next; // 指向下一个节点, 默认为null</span><br><span class="line">    public HeroNode2 pre; // 指向前一个节点, 默认为null</span><br><span class="line">    // 构造器</span><br><span class="line"></span><br><span class="line">    public HeroNode2(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为了显示方法，我们重新toString</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickname=&quot; + nickname + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六：单向环形链表（约瑟夫环）"><a href="#六：单向环形链表（约瑟夫环）" class="headerlink" title="六：单向环形链表（约瑟夫环）"></a>六：单向环形链表（约瑟夫环）</h1><p>1：约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3，1。 </p><p>2：创建环形链表思路</p><p>​    1：先创建第一个节点，让first指向该节点，加入到已有的环形链表中即可</p><p>​    2：后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中</p><p>3：遍历环形链表</p><p>​    1：先让一个辅助指针（变量）curBoy,指向first节点</p><p>​    2：通过while循环遍历该环形链表即可，curBoy.next==first，结束</p><p>4：创建、遍历环形链表代码实现</p><p>5：出圈思路</p><p>​    1：根据用户的输入，生成一个小孩出圈的顺序</p><p>​    2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">package com.it.com.it.linkedlist;</span><br><span class="line"></span><br><span class="line">//约瑟夫问题：环形链表解决</span><br><span class="line">public class Josepfu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(10);</span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line">        //测试小孩出圈</span><br><span class="line">        circleSingleLinkedList.countBoy(1, 2, 10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建环形链表</span><br><span class="line">class CircleSingleLinkedList &#123;</span><br><span class="line">    //创建一个first节点，无编号</span><br><span class="line">    private Boy first = null;</span><br><span class="line"></span><br><span class="line">    //添加节点，构建成环形链表</span><br><span class="line">    public void addBoy(int nums) &#123;</span><br><span class="line">        //nums表示环形链表节点个数</span><br><span class="line">        if (nums &lt; 1) &#123;</span><br><span class="line">            System.out.println(&quot;nums值不正确&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy curBoy = null;//辅助指针，帮助构建环形链表</span><br><span class="line">        //使用for循环创建环形链表</span><br><span class="line">        for (int i = 1; i &lt;= nums; i++) &#123;</span><br><span class="line">            //根据编号创建小孩节点</span><br><span class="line">            Boy boy = new Boy(i);</span><br><span class="line">            //给第一个小孩赋值</span><br><span class="line">            if (i == 1) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);</span><br><span class="line">                //让curBoy指向第一个小孩，因为first不能变动，需要让curBoy辅助</span><br><span class="line">                curBoy = first;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //构建环</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                //curBoy后移</span><br><span class="line">                curBoy = curBoy.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历环形链表</span><br><span class="line">    public void showBoy() &#123;</span><br><span class="line">        //判断链表是否为空</span><br><span class="line">        if (first == null) &#123;</span><br><span class="line">            System.out.println(&quot;没有小孩--&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //使用辅助指针帮助遍历</span><br><span class="line">        Boy curBoy = first;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.printf(&quot;小孩的编号%d:\n&quot;, curBoy.getNo());</span><br><span class="line">            //已经遍历完毕</span><br><span class="line">            if (curBoy.getNext() == first) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">//            curBoy后移</span><br><span class="line">            curBoy = curBoy.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //根据用户的输入，计算出圈的顺序</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param startNo  表示从第几个小孩开始数数</span><br><span class="line">     * @param countNum 表示数几下</span><br><span class="line">     * @param nums     表示最初有几个小孩，作为校验</span><br><span class="line">     */</span><br><span class="line">    public void countBoy(int startNo, int countNum, int nums) &#123;</span><br><span class="line">        if (first == null || startNo &lt; 1 || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(&quot;参数有误，请重新输入&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个辅助指针，帮助小孩出圈</span><br><span class="line">        Boy helper = first;</span><br><span class="line">        //使helper指向最后节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //相等说明helper在最后</span><br><span class="line">            if (helper.getNext() == first) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //helper后移</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //报数前，先让first和helper移动startNo-1次</span><br><span class="line">        for (int i = 0; i &lt; startNo - 1; i++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //当小孩报数时，让first和helper指针同时移动countNum-1次，然后出圈</span><br><span class="line">        //这里是一个循环操作，知道圈中只有一个节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //说明圈中只有一个节点</span><br><span class="line">            if (helper == first) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //让first和helper指针同时移动countNum-1次，然后出圈</span><br><span class="line">            for (int i = 0; i &lt; countNum - 1; i++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            //这时first指向的节点就是要出圈的节点</span><br><span class="line">            System.out.printf(&quot;小孩%d出圈\n&quot;, first.getNo());</span><br><span class="line">            //first指向的节点出圈</span><br><span class="line">            first = first.getNext();//使first后移</span><br><span class="line">            helper.setNext(first);//使helper的next指向first</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;最后留在圈中的小孩编号是%d\n&quot;, first.getNo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建一个boy，表示一个节点</span><br><span class="line">class Boy &#123;</span><br><span class="line">    private int no;</span><br><span class="line">    private Boy next;//指向下一个节点，默认null</span><br><span class="line"></span><br><span class="line">    public Boy(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Boy getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(Boy next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1：数据结构分类https-leetcode-cn-com-interview&quot;&gt;&lt;a href=&quot;#1：数据结构分类https-leetcode-cn-com-interview&quot; class=&quot;headerlink&quot; title=&quot;1：数据结构分类https:
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>怎么搭建自己的博客</title>
    <link href="https://yanyubing.xyz/2019/11/26/%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://yanyubing.xyz/2019/11/26/%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-11-26T04:32:14.553Z</published>
    <updated>2019-11-26T05:26:19.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h1><p>node.js</p><p>git</p><p>hexo</p><p>github账号</p><p>自己购买的域名</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>网上有很多基于hexo搭建github的博客可供参考：<a href="http://rosesnow.top/" target="_blank" rel="noopener">http://rosesnow.top</a> </p><p>这里主要描述流程和理解，方便遇到问题能够快速找到办法：</p><p>1：node.js是用于npm安装</p><p>2：hexo是本地博客servece</p><p>3：需要把hexo部署到github pages上</p><p>4：通过CNAME文件实现域名的重定向操作，最终实现自己的域名与hexo同步</p><p>5：直接在github上添加CANME文件可以实现一次转发，需要在blog/source目录下创建CNAME文件保证每次有效</p><p>6：最后在更新blog之后hexo  g ; hexo d 同步</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工具准备&quot;&gt;&lt;a href=&quot;#工具准备&quot; class=&quot;headerlink&quot; title=&quot;工具准备&quot;&gt;&lt;/a&gt;工具准备&lt;/h1&gt;&lt;p&gt;node.js&lt;/p&gt;
&lt;p&gt;git&lt;/p&gt;
&lt;p&gt;hexo&lt;/p&gt;
&lt;p&gt;github账号&lt;/p&gt;
&lt;p&gt;自己购买的域名&lt;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>

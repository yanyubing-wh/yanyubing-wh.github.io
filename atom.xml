<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鄢玉兵的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yanyubing.xyz/"/>
  <updated>2019-12-06T01:22:32.994Z</updated>
  <id>https://yanyubing.xyz/</id>
  
  <author>
    <name>鄢玉兵</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java数据结构和算法（10）10种算法</title>
    <link href="https://yanyubing.xyz/2018/08/10/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%8910%E7%A7%8D%E7%AE%97%E6%B3%95/"/>
    <id>https://yanyubing.xyz/2018/08/10/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%8910%E7%A7%8D%E7%AE%97%E6%B3%95/</id>
    <published>2018-08-10T13:46:12.000Z</published>
    <updated>2019-12-06T01:22:32.994Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：算法"><a href="#1：算法" class="headerlink" title="1：算法"></a>1：算法</h1><h3 id="1：二分查找：非递归"><a href="#1：二分查找：非递归" class="headerlink" title="1：二分查找：非递归"></a>1：二分查找：非递归</h3><p>1：二分查找简介</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x&lt;a[n/2],则只要在数组a的左半部分继续搜索x,如果x&gt;a[n/2],则只要在数组a的右半部搜索x.</span><br><span class="line">时间复杂度无非就是while循环的次数！</span><br><span class="line">总共有n个元素，</span><br><span class="line">渐渐跟下去就是n,n/2,n/4,....n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数</span><br><span class="line">由于你n/2^k取整后&gt;=1</span><br><span class="line">即令n/2^k=1</span><br><span class="line">可得k=log2n,（是以2为底，n的对数）</span><br><span class="line">所以时间复杂度可以表示O(h)=O(log2n)</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.it.binarysearchnorecursion;</span><br><span class="line"></span><br><span class="line">//二分查找，非递归</span><br><span class="line">public class BinarySearchNoRecur &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;1, 2, 5, 8, 12, 34, 56, 234&#125;;</span><br><span class="line">        int index=binarySearch(arr, 1);</span><br><span class="line">        System.out.println(&quot;index=&quot;+index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //二分查找非递归实现,arr升序</span><br><span class="line">    public static int binarySearch(int[] arr, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = arr.length - 1;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            if (arr[mid] == target) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (arr[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2：分治算法-汉诺塔"><a href="#2：分治算法-汉诺塔" class="headerlink" title="2：分治算法-汉诺塔"></a>2：分治算法-汉诺塔</h3><p>1：汉诺塔介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</span><br></pre></td></tr></table></figure><p>2：实现思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：A柱，B柱,C柱，n为盘子的个数</span><br><span class="line">2：当n=1时，A-C</span><br><span class="line">2：当n=2时，A-B，A-C,B-C</span><br><span class="line">3：当n=3时，A→C,A→B,C→B,A→C,B→A,B→C,A→C</span><br><span class="line">n个盘子的时候，移动次数s=2^n – 1</span><br><span class="line"></span><br><span class="line">规律当N个盘子的时候，可以当成两个盘子，把上面n-1当一个整体，把n-1个盘子先移动到B（A-B），然后再把最底下盘子移动到C，即A-C，最终把n-1个盘子移动到C，即B-C</span><br></pre></td></tr></table></figure><p>3：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.it.dac;</span><br><span class="line"></span><br><span class="line">//汉诺塔</span><br><span class="line">public class HanoiTower &#123;</span><br><span class="line">    private static int sum = 0;//记录移动的次数</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int num=10;</span><br><span class="line">        hanoiTower(num, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;);</span><br><span class="line">        System.out.println(&quot;当&quot; + num + &quot;个盘的时候，一起移动了&quot; + sum + &quot;次&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param num 汉诺塔盘的个数</span><br><span class="line">     * @param A   柱A</span><br><span class="line">     * @param B   柱B</span><br><span class="line">     * @param C   柱C</span><br><span class="line">     */</span><br><span class="line">    public static void hanoiTower(int num, char A, char B, char C) &#123;</span><br><span class="line">        //如果只有一个盘</span><br><span class="line">        if (num == 1) &#123;</span><br><span class="line">            System.out.println(&quot;第&quot; + num + &quot;个盘&quot; + A + &quot;-&quot; + C);</span><br><span class="line">            sum++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //当n&gt;2时，先把最上面的盘（所有盘）和最下面的一个盘</span><br><span class="line">            //先把最上面的所有盘，A-B</span><br><span class="line">            hanoiTower(num - 1, A, C, B);</span><br><span class="line">            //最后移动最后一个盘A-C</span><br><span class="line">            System.out.println(&quot;第&quot; + num + &quot;个盘&quot; + A + &quot;-&quot; + C);</span><br><span class="line">            sum++;</span><br><span class="line">            //把B塔所有盘移动到C</span><br><span class="line">            hanoiTower(num - 1, B, A, C);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3：动态规划算法-背包问题"><a href="#3：动态规划算法-背包问题" class="headerlink" title="3：动态规划算法-背包问题"></a>3：动态规划算法-背包问题</h3><p>1：01背包问题概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V？它是在1978年由Merkel和Hellman提出的。</span><br></pre></td></tr></table></figure><p>2：实现思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义：有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</span><br><span class="line">f[i][v]=max&#123; f[i-1][v], f[i-1][v-w[i]]+v[i] &#125;。</span><br><span class="line">可以压缩空间，f[v]=max&#123;f[v],f[v-w[i]]+v[i]&#125;</span><br><span class="line">f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值</span><br><span class="line">f[i-1][v]表示前i-1件物品恰放入一个容量为v的背包可以获得的最大价值</span><br><span class="line">f[i-1][v-w[i]]+v[i]表示前i-1件物品放入到容量为（v-第i件物品的重量）的空间产生的最大价值+第i件物品的价值</span><br></pre></td></tr></table></figure><p>3：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">核心代码：</span><br><span class="line"></span><br><span class="line">//开始动态规划,i代表物品个数，j代表背包容量</span><br><span class="line">        for (int i = 1; i &lt; v.length; i++) &#123;//不处理第一行，</span><br><span class="line">            for (int j = 1; j &lt; v[0].length; j++) &#123;//不处理第一列</span><br><span class="line">                if (w[i - 1] &gt; j) &#123;//说明第i个物品的重量大于背包重量,无法加入进去</span><br><span class="line">                    v[i][j] = v[i - 1][j];</span><br><span class="line">                &#125; else &#123;//说明第i个物品的重量小于背包的重量，则可以进行比较</span><br><span class="line">                    //因为i从1开始，索引需要-1</span><br><span class="line">                    //v[i][j] = Math.max(v[i - 1][j], (val[i - 1] + v[i - 1][j - w[i - 1]]));</span><br><span class="line">                    //为了记录商品的存放情况，不能用max</span><br><span class="line">                    if (v[i - 1][j] &gt; (val[i - 1] + v[i - 1][j - w[i - 1]])) &#123;</span><br><span class="line">                        v[i][j] = v[i - 1][j];</span><br><span class="line">                    &#125; else if (v[i - 1][j] &lt; (val[i - 1] + v[i - 1][j - w[i - 1]])) &#123;</span><br><span class="line">                        v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];</span><br><span class="line">                        path[i][j] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        v[i][j] = v[i - 1][j];</span><br><span class="line">                        System.out.println(&quot;且存在多种分配方案&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package com.it.knapsackproblem;</span><br><span class="line"></span><br><span class="line">//01背包问题</span><br><span class="line">public class KnapsackProblem &#123;</span><br><span class="line">    private static int sumW = 0;//记录总使用重量</span><br><span class="line">    private static int sumVal = 0;//记录总使用价值</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] w = &#123;1, 4, 3, 6, 10, 2, 5&#125;;//物品的重量</span><br><span class="line">        int[] val = &#123;1500, 3000, 2000, 2444, 4000, 2333, 2000&#125;;//物品的价值</span><br><span class="line">        int m = 10;//背包的重量</span><br><span class="line">        int n = val.length;//物品的个数</span><br><span class="line">        //v[i][j]表示前i个物品放到容量为j的背包中的最大价值</span><br><span class="line">        int[][] v = new int[n + 1][m + 1];</span><br><span class="line">        //定义二维数组用于记录存放情况</span><br><span class="line">        int[][] path = new int[n + 1][m + 1];</span><br><span class="line">        //初始化，</span><br><span class="line">        for (int i = 0; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[i][0] = 0;//当背包容量为0时，最大价值为0</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; v[0].length; j++) &#123;</span><br><span class="line">            v[0][j] = 0;//当物品为0个时，最大价值为0</span><br><span class="line">        &#125;</span><br><span class="line">        //开始动态规划,i代表物品个数，j代表背包容量</span><br><span class="line">        for (int i = 1; i &lt; v.length; i++) &#123;//不处理第一行，</span><br><span class="line">            for (int j = 1; j &lt; v[0].length; j++) &#123;//不处理第一列</span><br><span class="line">                if (w[i - 1] &gt; j) &#123;//说明第i个物品的重量大于背包重量,无法加入进去</span><br><span class="line">                    v[i][j] = v[i - 1][j];</span><br><span class="line">                &#125; else &#123;//说明第i个物品的重量小于背包的重量，则可以进行比较</span><br><span class="line">                    //因为i从1开始，索引需要-1</span><br><span class="line">                    //v[i][j] = Math.max(v[i - 1][j], (val[i - 1] + v[i - 1][j - w[i - 1]]));</span><br><span class="line">                    //为了记录商品的存放情况，不能用max</span><br><span class="line">                    if (v[i - 1][j] &gt; (val[i - 1] + v[i - 1][j - w[i - 1]])) &#123;</span><br><span class="line">                        v[i][j] = v[i - 1][j];</span><br><span class="line">                    &#125; else if (v[i - 1][j] &lt; (val[i - 1] + v[i - 1][j - w[i - 1]])) &#123;</span><br><span class="line">                        v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];</span><br><span class="line">                        path[i][j] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        v[i][j] = v[i - 1][j];</span><br><span class="line">                        System.out.println(&quot;且存在多种分配方案&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; v.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; v[i].length; j++) &#123;</span><br><span class="line">                System.out.print(v[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;路径为&quot;);</span><br><span class="line">        //得从后往前遍历</span><br><span class="line">        int i = path.length - 1;//行得最大下标</span><br><span class="line">        int j = path[0].length - 1;//列得最大下标</span><br><span class="line">        //从path数组得最后开始找，得到最优路径</span><br><span class="line">        while (i &gt; 0 &amp;&amp; j &gt; 0) &#123;</span><br><span class="line">            if (path[i][j] == 1) &#123;</span><br><span class="line">                //说明放置过数据</span><br><span class="line">                System.out.printf(&quot;第%d个商品放入背包&quot;, i);</span><br><span class="line">                sumW += w[i - 1];</span><br><span class="line">                sumVal += val[i - 1];</span><br><span class="line">                j -= w[i - 1];//最大重量得减去最后一个物品得重量</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            i--;//物品个数减少</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;背包可以使用的重量为&quot;+m);</span><br><span class="line">        System.out.println(&quot;总计使用重量为&quot;+sumW);</span><br><span class="line">        System.out.println(&quot;总计产生价值为&quot;+sumVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4：KMP算法-字符串匹配问题"><a href="#4：KMP算法-字符串匹配问题" class="headerlink" title="4：KMP算法-字符串匹配问题"></a>4：KMP算法-字符串匹配问题</h3><p>1：暴力匹配简介</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？</span><br><span class="line">首先，先理清楚了暴力匹配算法的流程及内在的逻辑：</span><br><span class="line">如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</span><br><span class="line">如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；</span><br><span class="line">如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</span><br></pre></td></tr></table></figure><p>2：暴力匹配代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假定：母串长度为N，字串长度为M，字串首字母在N中出现的次数为n次</span><br><span class="line">那么算法实际复杂度为：O(N)+O(n)*(M-)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.it.kmp;</span><br><span class="line"></span><br><span class="line">public class ViolenceMatch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 = &quot;wrfemwlrerw&quot;;</span><br><span class="line">        String str2 = &quot;lr&quot;;</span><br><span class="line">        System.out.println(violenceMatch(str1,str2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param str1 母串</span><br><span class="line">     * @param str2 子串</span><br><span class="line">     * @return 返回第一个索引值</span><br><span class="line">     */</span><br><span class="line">    //暴力匹配算法实现</span><br><span class="line">    public static int violenceMatch(String str1, String str2) &#123;</span><br><span class="line">        char[] s1 = str1.toCharArray();//是s1为母串</span><br><span class="line">        char[] s2 = str2.toCharArray();//说s2为字串</span><br><span class="line">        int s1Len = s1.length;</span><br><span class="line">        int s2Len = s2.length;</span><br><span class="line">        int i = 0;//i指向s1</span><br><span class="line">        int j = 0;//j指向s2</span><br><span class="line">        while (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;//保证匹配不越界</span><br><span class="line">            if (s1[i] == s2[j]) &#123;//说明匹配成功</span><br><span class="line">                i++;</span><br><span class="line">                j++;//如果全部都相等，则j会越界，即退出循环,此时的头索引即为i-j</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //如果不想等，则字串j继续置为0开始，</span><br><span class="line">                // 母串i的索引从第i-(j-1)个开始：即为前面一步和字串已经匹配到了j个元素，i需要回退j且+1开始</span><br><span class="line">                i = i - (j - 1);</span><br><span class="line">                j = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j == s2Len) &#123;</span><br><span class="line">            return i - j;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3：yanyubing算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">1：先遍历母串str1，找到字串str[0]在母串中的位子index，创建集合arr用于存放index；</span><br><span class="line">2：遍历集合arr取出arr.get(index)，循环字串长度，然后依次匹配，如果全部匹配成功，记录index</span><br><span class="line">3:将所有index存放到集合arr2中返回</span><br><span class="line"></span><br><span class="line">假定：母串长度为N，字串长度为M，字串首字母在N中出现的次数为n次</span><br><span class="line">那么算法实际复杂度为：O(N)+O(n)*(M-)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.it.minStr;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">//求最小子串</span><br><span class="line">public class M inStr &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = &quot;abcdefghijk&quot;;</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        for (int i = 0; i &lt; 80000000; i++) &#123;</span><br><span class="line">            int index = r.nextInt(s1.length());</span><br><span class="line">            stringBuilder.append(s1.charAt(index));</span><br><span class="line">        &#125;</span><br><span class="line">        s1 = stringBuilder.toString();</span><br><span class="line">//        System.out.println(s1);</span><br><span class="line">        //测试时间</span><br><span class="line">        String s2 = &quot;abd&quot;;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        ArrayList arrayList = minStr(s1, s2);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;8千万个母串查找字串耗时/ms；&quot;+(end - start));</span><br><span class="line">        System.out.println(&quot;头索引个数为&quot;+ arrayList.size());</span><br><span class="line">        System.out.println(&quot;头索引为&quot;+ arrayList.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //方法,返回满足条件的字串在母串中的索引的集合</span><br><span class="line">    public static ArrayList minStr(String s1, String s2) &#123;</span><br><span class="line">        //母串s1   字串s2</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();//创建一个集合，用来存放字串首字符在母串中出现的索引</span><br><span class="line">        char[] chars1 = s1.toCharArray();//转换为字符数组</span><br><span class="line">        char[] chars2 = s2.toCharArray();//转换为字符数组</span><br><span class="line">        for (int i = 0; i &lt; chars1.length - chars2.length + 1; i++) &#123;</span><br><span class="line">            if (chars2[0] == chars1[i]) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList2 = new ArrayList&lt;&gt;();//创建第二个集合，用来存放所有满足条件，当字串首字符在母串中出现的首字符索引</span><br><span class="line">        //拿到了首字母索引的集合，循环s2.length-2次，从s1索引为1开始和s2索引从每个i开始比较比较</span><br><span class="line">        if (chars2.length == 1) &#123;</span><br><span class="line">            return arrayList;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int j = 0; j &lt; arrayList.size(); j++) &#123;</span><br><span class="line">                boolean flag = true;</span><br><span class="line">                for (int i = 1; i &lt; s2.length(); i++) &#123;//每次比较循环s2.length-2次,制定flag标志为true，如果循环完成还为true，则表示该索引满足条件</span><br><span class="line">                    if (chars1[arrayList.get(j) + i] != chars2[i]) &#123;</span><br><span class="line">                        flag = false;//不满足条件时，把flag置为false,并且推出内层循环</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //一次循环完成之后flag还是true则证明字串满足条件，记录当前的索引</span><br><span class="line">                if (flag) &#123;</span><br><span class="line">                    arrayList2.add(arrayList.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return arrayList2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4：KMP算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：KMP算法实际思路就是尽可能减少已经被匹配过了的母串中的字符串</span><br><span class="line">2：需要借助与字串的部分匹配值表</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">部分匹配值表举例：如字串abcdabd</span><br><span class="line">   头元素 尾元素  共有元素长度</span><br><span class="line">当1个元素时：a   null              0</span><br><span class="line">当2个元素时：a  b     0</span><br><span class="line">当3个元素时：(a，ab)  (bc,c)   0</span><br><span class="line">当4个元素时：(a，ab,abc)  (bcd,cd,d)   0</span><br><span class="line">当5个元素时：(a，ab,abc,abcd)  (bcda,cda,da,a)      1</span><br><span class="line">当6个元素时：(a，ab,abc,abcd,abcda)  (bcdab,cdab,dab,ab,b)  2</span><br><span class="line">当7个元素时：(a，ab,abc,abcd,abcda,abcdab)  (bcdabd,cdabd,dabd,abd,bd,d)0</span><br><span class="line"></span><br><span class="line">即得到的字串abcdabd部分匹配值表为</span><br><span class="line">abcdabd</span><br><span class="line">0000120</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">package com.it.kmp;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Array;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class KMPAlgorithm &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 = &quot;BBC ABCDAB ABCDABCDABDE&quot;;</span><br><span class="line">        String str2 = &quot;ABCDABD&quot;;</span><br><span class="line">        int[] next = kmpNext(str2);//</span><br><span class="line">        System.out.println(Arrays.toString(next));//打印字串的部分匹配表的数组</span><br><span class="line">        int num = kmpSearch(str1, str2, next);</span><br><span class="line">        System.out.println(&quot;字串中找到的索引为：&quot;+num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param str1 母串</span><br><span class="line">     * @param str2 字串</span><br><span class="line">     * @param next 字串的部分匹配表</span><br><span class="line">     * @return 返回首字母索引的集合</span><br><span class="line">     */</span><br><span class="line">    //kmp算法</span><br><span class="line">    public static int kmpSearch(String str1, String str2, int[] next) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        //遍历</span><br><span class="line">        for (int i = 0, j = 0; i &lt; str1.length(); i++) &#123;//i指向母串str1,j指向str2</span><br><span class="line">            //还需要处理str2.charAt(j) ！= str1.charAt(i)的情况，调整j的大小</span><br><span class="line">            while (j &gt; 0 &amp;&amp; str2.charAt(j) != str1.charAt(i)) &#123;</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (str2.charAt(j) == str1.charAt(i)) &#123;//说明首字符相等</span><br><span class="line">                j++;//继续判断第二个字符，第三个...</span><br><span class="line">            &#125;</span><br><span class="line">            if (j == str2.length()) &#123;//如果j的长度==字串的长度了，那么就说明找到</span><br><span class="line">                return i - j + 1;//首字符索引添加到集合</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param dest 字串</span><br><span class="line">     * @return 部分匹配值表的数组</span><br><span class="line">     */</span><br><span class="line">    public static int[] kmpNext(String dest) &#123;</span><br><span class="line">        //创建一个next数组保存部分匹配值表</span><br><span class="line">        int[] next = new int[dest.length()];</span><br><span class="line">        next[0] = 0;//字符串长度为1的时候，部分匹配值为0</span><br><span class="line">        ArrayList&lt;String&gt; s1 = new ArrayList&lt;String&gt;();//用于存放前缀元素的字符串</span><br><span class="line">        ArrayList&lt;String&gt; s2 = new ArrayList&lt;String&gt;();//用于存放后缀元素</span><br><span class="line">        //我的思路是循环</span><br><span class="line">        for (int i = 1; i &lt; dest.length(); i++) &#123;//i表示第几个元素加入</span><br><span class="line">            /*     * 部分匹配值表举例：如字串abcdabd   头元素 尾元素  共有元素长度</span><br><span class="line">当1个元素时：a   null              0</span><br><span class="line">当2个元素时：a  b     0</span><br><span class="line">当3个元素时：(a，ab)  (bc,c)   0</span><br><span class="line">当4个元素时：(a，ab,abc)  (bcd,cd,d)   0</span><br><span class="line">当5个元素时：(a，ab,abc,abcd)  (bcda,cda,da,a)      1</span><br><span class="line">当6个元素时：(a，ab,abc,abcd,abcda)  (bcdab,cdab,dab,ab,b)  2</span><br><span class="line">当7个元素时：(a，ab,abc,abcd,abcda,abcdab)  (bcdabd,cdabd,dabd,abd,bd,d)0</span><br><span class="line">*/</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;//当i=3时，</span><br><span class="line">                s1.add(dest.substring(0, j));</span><br><span class="line">                s2.add(dest.substring(j, i + 1));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;当i为&quot; + i + &quot;时&quot;);</span><br><span class="line">            System.out.println(&quot;集合s1为&quot; + s1.toString());</span><br><span class="line">            System.out.println(&quot;集合s2为&quot; + s2.toString());</span><br><span class="line">            System.out.println();</span><br><span class="line">            //循环结束表示添加元素完成，开始比较</span><br><span class="line">            //比较s1与s2</span><br><span class="line">            for (int j = 0; j &lt; s1.size(); j++) &#123;</span><br><span class="line">                for (int k = 0; k &lt; s2.size(); k++) &#123;</span><br><span class="line">                    if (s1.get(j).equals(s2.get(k))) &#123;//说明存在相同元素</span><br><span class="line">                        next[i] = s1.get(j).length();//把相同元素的长度赋值给next[i]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;//比较完成之后需要重置s1与s2</span><br><span class="line">            s1.clear();</span><br><span class="line">            s2.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五：贪心算法-集合覆盖问题"><a href="#五：贪心算法-集合覆盖问题" class="headerlink" title="五：贪心算法-集合覆盖问题"></a>五：贪心算法-集合覆盖问题</h3><p>1：贪心算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">假设存在下面需要付费的广播台，以及广播台覆盖可以覆盖的地区，如何选择最少的广播台，让所有的地区都可以接收到信号</span><br><span class="line">广播台覆盖地区</span><br><span class="line">k1&quot;北京&quot;上海&quot;&quot;天津&quot;</span><br><span class="line">k2&quot;广州&quot;&quot;北京&quot;&quot;深圳&quot;</span><br><span class="line">k3&quot;成都&quot;&quot;上海&quot;&quot;杭州&quot;</span><br><span class="line">k4&quot;上海&quot;&quot;天津&quot;</span><br><span class="line">k5&quot;杭州&quot;&quot;大连&quot;</span><br><span class="line"></span><br><span class="line">贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</span><br><span class="line">贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 </span><br><span class="line"></span><br><span class="line">实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</span><br></pre></td></tr></table></figure><p>2：贪心算法思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：覆盖问题，遍历所有广播台，找到一个覆盖了最多未覆盖地区的电台（此电台可能包含一些已经覆盖的地区，但是没关系）</span><br><span class="line">2：将这些电台加入到集合，去掉已经加入的电台</span><br><span class="line">3：重复第1步，直到覆盖完全部地区</span><br></pre></td></tr></table></figure><p>3：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思路清晰，主要就是对于集合的操作</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package com.it.greedy;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">//贪心算法</span><br><span class="line">public class GreedyAlgorithm &#123;</span><br><span class="line">    //存放所有地区,所有地区为全局变量，并且随时需要改变</span><br><span class="line">    static HashSet&lt;String&gt; allAreas = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建广播电台</span><br><span class="line">        HashMap&lt;String, HashSet&gt; broadcasts = new HashMap&lt;&gt;();</span><br><span class="line">        //将各个电台放入</span><br><span class="line">        HashSet&lt;String&gt; hashSet1 = new HashSet();</span><br><span class="line">        hashSet1.add(&quot;北京&quot;);</span><br><span class="line">        hashSet1.add(&quot;上海&quot;);</span><br><span class="line">        hashSet1.add(&quot;天津&quot;);</span><br><span class="line">        HashSet&lt;String&gt; hashSet2 = new HashSet();</span><br><span class="line">        hashSet2.add(&quot;广州&quot;);</span><br><span class="line">        hashSet2.add(&quot;北京&quot;);</span><br><span class="line">        hashSet2.add(&quot;深圳&quot;);</span><br><span class="line">        HashSet&lt;String&gt; hashSet3 = new HashSet();</span><br><span class="line">        hashSet3.add(&quot;成都&quot;);</span><br><span class="line">        hashSet3.add(&quot;上海&quot;);</span><br><span class="line">        hashSet3.add(&quot;杭州&quot;);</span><br><span class="line">        HashSet&lt;String&gt; hashSet4 = new HashSet();</span><br><span class="line">        hashSet4.add(&quot;上海&quot;);</span><br><span class="line">        hashSet4.add(&quot;天津&quot;);</span><br><span class="line">        HashSet&lt;String&gt; hashSet5 = new HashSet();</span><br><span class="line">        hashSet5.add(&quot;杭州&quot;);</span><br><span class="line">        hashSet5.add(&quot;大连&quot;);</span><br><span class="line">        //加入到map</span><br><span class="line">        broadcasts.put(&quot;k1&quot;, hashSet1);</span><br><span class="line">        broadcasts.put(&quot;k2&quot;, hashSet2);</span><br><span class="line">        broadcasts.put(&quot;k3&quot;, hashSet3);</span><br><span class="line">        broadcasts.put(&quot;k4&quot;, hashSet4);</span><br><span class="line">        broadcasts.put(&quot;k5&quot;, hashSet5);</span><br><span class="line">        for (Map.Entry&lt;String, HashSet&gt; Entry : broadcasts.entrySet()) &#123;</span><br><span class="line">            HashSet&lt;String&gt; value = Entry.getValue();//得到value</span><br><span class="line">            for (String s : value) &#123;</span><br><span class="line">                allAreas.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //添加完所有地区</span><br><span class="line">        System.out.println(&quot;需要覆盖的地区&quot;);</span><br><span class="line">        System.out.println(allAreas.toString());</span><br><span class="line">        System.out.println();</span><br><span class="line">        //创建ArrayList集合，存放选择的电台集合。</span><br><span class="line">        // 选择的条件为：遍历电台，将最多的未覆盖的地区的电台加入到选择的集合中</span><br><span class="line">        ArrayList&lt;String&gt; selects = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //定义一个数组,用于存放每个电台与还未覆盖地区的交集的个数</span><br><span class="line">        int arr[] = new int[broadcasts.size()];//长度为电台总个数</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();//存放电台集合</span><br><span class="line">        arrayList.add(&quot;k1&quot;);</span><br><span class="line">        arrayList.add(&quot;k2&quot;);</span><br><span class="line">        arrayList.add(&quot;k3&quot;);</span><br><span class="line">        arrayList.add(&quot;k4&quot;);</span><br><span class="line">        arrayList.add(&quot;k5&quot;);</span><br><span class="line"></span><br><span class="line">        while (allAreas.size() &gt; 0) &#123;</span><br><span class="line">            System.out.println(&quot;需要覆盖的地区&quot;);</span><br><span class="line">            System.out.println(allAreas.toString());</span><br><span class="line">            System.out.println();</span><br><span class="line">            int index = 0;//手动创建索引</span><br><span class="line">            //遍历广播电台</span><br><span class="line">            for (Map.Entry&lt;String, HashSet&gt; stringHashSetEntry : broadcasts.entrySet()) &#123;</span><br><span class="line">                String key = stringHashSetEntry.getKey();//得到电台名称</span><br><span class="line">                HashSet&lt;String&gt; value = stringHashSetEntry.getValue();//得到每个电台对应的覆盖地区</span><br><span class="line">                int count = 0;</span><br><span class="line">                for (String s : value) &#123;</span><br><span class="line">                    if (allAreas.contains(s)) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[index] = count;</span><br><span class="line">                index++;</span><br><span class="line">                //每次循环完成之后count为当前k1电台与allAreas的交集的个数</span><br><span class="line">            &#125;</span><br><span class="line">            //所有的循环完成之后即得到了存放交集的arr，遍历数组取出最大值</span><br><span class="line">            // 将对应的电台加入selects电台集合</span><br><span class="line">            // 并且将该电台所覆盖的地区从需要覆盖的地区中去除</span><br><span class="line">            int max = 0;</span><br><span class="line">            int index2 = 0;//记录最大值所在的索引</span><br><span class="line">            for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                if (arr[i] &gt; max) &#123;</span><br><span class="line">                    max = arr[i];</span><br><span class="line">                    index2 = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //循环结束即得到了最大值的索引，添加对应的电台到电台集合</span><br><span class="line">            selects.add(arrayList.get(index2));//&quot;k1&quot;</span><br><span class="line">            System.out.println(&quot;得到的电台为：&quot; + arrayList.get(index2));</span><br><span class="line">            //移除对应电台所覆盖的地区</span><br><span class="line">            HashSet&lt;String&gt; hashSet = broadcasts.get(arrayList.get(index2));//得到&quot;k1&quot;电台对应覆盖地区的集合</span><br><span class="line">            for (String s : hashSet) &#123;</span><br><span class="line">                allAreas.remove(s);</span><br><span class="line">            &#125;//移除了地区</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;得到的电台为：&quot; + selects.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六：普利姆算法-修路问题"><a href="#六：普利姆算法-修路问题" class="headerlink" title="六：普利姆算法-修路问题"></a>六：普利姆算法-修路问题</h3><p>1：普里姆算法（Prim算法）简介-最小生成树MST</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）发现；并在1957年由美国计算机科学家罗伯特·普里姆（英语：Robert C. Prim）独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。</span><br></pre></td></tr></table></figure><p>2：算法描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1).输入：一个加权连通图，其中顶点集合为V，边集合为E；</span><br><span class="line">2).初始化：Vnew = &#123;x&#125;，其中x为集合V中的任一节点（起始点），Enew = &#123;&#125;,为空；</span><br><span class="line">3).重复下列操作，直到Vnew = V：</span><br><span class="line">a.在集合E中选取权值最小的边&lt;u, v&gt;，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</span><br><span class="line">b.将v加入集合Vnew中，将&lt;u, v&gt;边加入集合Enew中；</span><br><span class="line">4).输出：使用集合Vnew和Enew来描述所得到的最小生成树。</span><br><span class="line"></span><br><span class="line">图解见：https://baike.baidu.com/item/Prim/10242166?fr=aladdin#1</span><br></pre></td></tr></table></figure><p>3：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">package com.it.prim;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">//普利姆算法</span><br><span class="line">public class PrimAlgorithm &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//测试图是否创建成功</span><br><span class="line">        char[] data = new char[]&#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</span><br><span class="line">        int verxs = data.length;</span><br><span class="line">        //邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通</span><br><span class="line">        int[][] weight = new int[][]&#123;</span><br><span class="line">                &#123;10000, 5, 7, 10000, 10000, 10000, 2&#125;,</span><br><span class="line">                &#123;5, 10000, 10000, 9, 10000, 10000, 3&#125;,</span><br><span class="line">                &#123;7, 10000, 10000, 10000, 8, 10000, 10000&#125;,</span><br><span class="line">                &#123;10000, 9, 10000, 10000, 10000, 4, 10000&#125;,</span><br><span class="line">                &#123;10000, 10000, 8, 10000, 10000, 5, 4&#125;,</span><br><span class="line">                &#123;10000, 10000, 10000, 4, 5, 10000, 6&#125;,</span><br><span class="line">                &#123;2, 3, 10000, 10000, 4, 6, 10000&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        //创建MGraph对象</span><br><span class="line">        MGraph graph = new MGraph(verxs);</span><br><span class="line">        //创建一个MinTree对象</span><br><span class="line">        MinTree minTree = new MinTree();</span><br><span class="line">        minTree.createGraph(graph, verxs, data, weight);</span><br><span class="line">        //输出</span><br><span class="line">        minTree.showGraph(graph);</span><br><span class="line">        //测试普利姆算法</span><br><span class="line">        minTree.prim(graph, 1);//</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//构建最小生成树--&gt;村庄的图</span><br><span class="line">class MinTree &#123;</span><br><span class="line">    //创建图的临接矩阵</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param graph  图对象</span><br><span class="line">     * @param verxs  图对应的顶点的个数</span><br><span class="line">     * @param data   图的各个顶点的值</span><br><span class="line">     * @param weight 图的临接矩阵</span><br><span class="line">     *               初始化图对象</span><br><span class="line">     */</span><br><span class="line">    public void createGraph(MGraph graph, int verxs, char data[], int[][] weight) &#123;</span><br><span class="line">        int i, j;</span><br><span class="line">        for (i = 0; i &lt; verxs; i++) &#123;//顶点</span><br><span class="line">            graph.data[i] = data[i];</span><br><span class="line">            for (j = 0; j &lt; verxs; j++) &#123;</span><br><span class="line">                graph.weight[i][j] = weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历图，显示图的临接矩阵</span><br><span class="line">    public void showGraph(MGraph graph) &#123;</span><br><span class="line">        for (int[] link : graph.weight) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//编写prim算法，得到最小生成树</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param graph 图</span><br><span class="line">     * @param v     表示从图的第几个顶点开始生成&apos;A&apos;-&gt;0 &apos;B&apos;-&gt;1...</span><br><span class="line">     */</span><br><span class="line">    public void prim(MGraph graph, int v) &#123;</span><br><span class="line">        //visited[] 标记结点(顶点)是否被访问过</span><br><span class="line">        int visited[] = new int[graph.verxs];</span><br><span class="line">        //visited[] 默认元素的值都是0, 表示没有访问过</span><br><span class="line">//for(int i =0; i &lt;graph.verxs; i++) &#123;</span><br><span class="line">//visited[i] = 0;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">        //把当前这个结点标记为已访问</span><br><span class="line">        visited[v] = 1;</span><br><span class="line">        //h1 和 h2 记录两个顶点的下标</span><br><span class="line">        int h1 = -1;</span><br><span class="line">        int h2 = -1;</span><br><span class="line">        int minWeight = 10000; //将 minWeight 初始成一个大数，后面在遍历过程中，会被替换</span><br><span class="line">        for (int k = 1; k &lt; graph.verxs; k++) &#123;//因为有 graph.verxs顶点，普利姆算法结束后，有 graph.verxs-1边</span><br><span class="line"></span><br><span class="line">            //这个是确定每一次生成的子图 ，和哪个结点的距离最近</span><br><span class="line">            for (int i = 0; i &lt; graph.verxs; i++) &#123;// i结点表示被访问过的结点</span><br><span class="line">                for (int j = 0; j &lt; graph.verxs; j++) &#123;//j结点表示还没有访问过的结点</span><br><span class="line">                    if (visited[i] == 1 &amp;&amp; visited[j] == 0 &amp;&amp; graph.weight[i][j] &lt; minWeight) &#123;</span><br><span class="line">                        //替换minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边)</span><br><span class="line">                        minWeight = graph.weight[i][j];</span><br><span class="line">                        h1 = i;</span><br><span class="line">                        h2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //找到一条边是最小</span><br><span class="line">            System.out.println(&quot;边&lt;&quot; + graph.data[h1] + &quot;,&quot; + graph.data[h2] + &quot;&gt; 权值:&quot; + minWeight);</span><br><span class="line">            //将当前这个结点标记为已经访问</span><br><span class="line">            visited[h2] = 1;</span><br><span class="line">            //minWeight 重新设置为最大值 10000</span><br><span class="line">            minWeight = 10000;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//图</span><br><span class="line">class MGraph &#123;</span><br><span class="line">    int verxs;//表示图的节点个数</span><br><span class="line">    char[] data;//存放节点的数据</span><br><span class="line">    int[][] weight;//存放边，临接矩阵</span><br><span class="line"></span><br><span class="line">    public MGraph(int verxs) &#123;//构造器</span><br><span class="line">        this.verxs = verxs;</span><br><span class="line">        data = new char[verxs];</span><br><span class="line">        weight = new int[verxs][verxs];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七：克鲁斯卡尔算法-公交站问题"><a href="#七：克鲁斯卡尔算法-公交站问题" class="headerlink" title="七：克鲁斯卡尔算法-公交站问题"></a>七：克鲁斯卡尔算法-公交站问题</h3><p>1：Kruskal算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Kruskal算法是一种用来查找最小生成树的算法，由Joseph Kruskal在1956年发表。用来解决同样问题的还有Prim算法和Boruvka算法等。三种算法都是贪心算法的应用。和Boruvka算法不同的地方是，Kruskal算法在图中存在相同权值的边时也有效。 </span><br><span class="line"> </span><br><span class="line">1：新建图G，G中拥有原图中相同的节点，但没有边；</span><br><span class="line">2：将原图中所有的边按权值从小到大排序；</span><br><span class="line">3：从权值最小的边开始，如果这条边连接的两个节点于图G中不会形成回路，则添加这条边到图G中；</span><br><span class="line">4：重复3，直至图G中所有的节点都在同一个连通分量中。</span><br><span class="line"></span><br><span class="line">核心思想是不要形成回路，如何判断如何形成了回路！需要加入边的两个顶点不能指向同一个终点。</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">核心代码：获取终点的方法</span><br><span class="line">/**</span><br><span class="line">    * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同</span><br><span class="line">    * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成</span><br><span class="line">    * @param i : 表示传入的顶点对应的下标</span><br><span class="line">    * @return 返回的就是 下标为i的这个顶点对应的终点的下标, 一会回头还有来理解</span><br><span class="line">    */</span><br><span class="line">   private int getEnd(int[] ends, int i) &#123; // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]</span><br><span class="line">       while(ends[i] != 0) &#123;</span><br><span class="line">           i = ends[i];</span><br><span class="line">       &#125;</span><br><span class="line">       return i;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">package com.it.kruskalCase;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class KruskalCase &#123;</span><br><span class="line"></span><br><span class="line">    private int edgeNum; //边的个数</span><br><span class="line">    private char[] vertexs; //顶点数组</span><br><span class="line">    private int[][] matrix; //邻接矩阵</span><br><span class="line">    //使用 INF 表示两个顶点不能连通</span><br><span class="line">    private static final int INF = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char[] vertexs = &#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</span><br><span class="line">        //克鲁斯卡尔算法的邻接矩阵</span><br><span class="line">        int matrix[][] = &#123;</span><br><span class="line">                /*A*//*B*//*C*//*D*//*E*//*F*//*G*/</span><br><span class="line">                /*A*/ &#123;   0,  12, INF, INF, INF,  16,  14&#125;,</span><br><span class="line">                /*B*/ &#123;  12,   0,  10, INF, INF,   7, INF&#125;,</span><br><span class="line">                /*C*/ &#123; INF,  10,   0,   3,   5,   6, INF&#125;,</span><br><span class="line">                /*D*/ &#123; INF, INF,   3,   0,   4, INF, INF&#125;,</span><br><span class="line">                /*E*/ &#123; INF, INF,   5,   4,   0,   2,   8&#125;,</span><br><span class="line">                /*F*/ &#123;  16,   7,   6, INF,   2,   0,   9&#125;,</span><br><span class="line">                /*G*/ &#123;  14, INF, INF, INF,   8,   9,   0&#125;&#125;;</span><br><span class="line">        //大家可以在去测试其它的邻接矩阵，结果都可以得到最小生成树.</span><br><span class="line"></span><br><span class="line">        //创建KruskalCase 对象实例</span><br><span class="line">        KruskalCase kruskalCase = new KruskalCase(vertexs, matrix);</span><br><span class="line">        //输出构建的</span><br><span class="line">        kruskalCase.print();</span><br><span class="line">        kruskalCase.kruskal();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public KruskalCase(char[] vertexs, int[][] matrix) &#123;</span><br><span class="line">        //初始化顶点数和边的个数</span><br><span class="line">        int vlen = vertexs.length;</span><br><span class="line"></span><br><span class="line">        //初始化顶点, 复制拷贝的方式</span><br><span class="line">        this.vertexs = new char[vlen];</span><br><span class="line">        for(int i = 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            this.vertexs[i] = vertexs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //初始化边, 使用的是复制拷贝的方式</span><br><span class="line">        this.matrix = new int[vlen][vlen];</span><br><span class="line">        for(int i = 0; i &lt; vlen; i++) &#123;</span><br><span class="line">            for(int j= 0; j &lt; vlen; j++) &#123;</span><br><span class="line">                this.matrix[i][j] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //统计边的条数</span><br><span class="line">        for(int i =0; i &lt; vlen; i++) &#123;</span><br><span class="line">            for(int j = i+1; j &lt; vlen; j++) &#123;</span><br><span class="line">                if(this.matrix[i][j] != INF) &#123;</span><br><span class="line">                    edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void kruskal() &#123;</span><br><span class="line">        int index = 0; //表示最后结果数组的索引</span><br><span class="line">        int[] ends = new int[edgeNum]; //用于保存&quot;已有最小生成树&quot; 中的每个顶点在最小生成树中的终点</span><br><span class="line">        //创建结果数组, 保存最后的最小生成树</span><br><span class="line">        EData[] rets = new EData[edgeNum];</span><br><span class="line"></span><br><span class="line">        //获取图中 所有的边的集合 ， 一共有12边</span><br><span class="line">        EData[] edges = getEdges();</span><br><span class="line">        System.out.println(&quot;图的边的集合=&quot; + Arrays.toString(edges) + &quot; 共&quot;+ edges.length); //12</span><br><span class="line"></span><br><span class="line">        //按照边的权值大小进行排序(从小到大)</span><br><span class="line">        sortEdges(edges);</span><br><span class="line"></span><br><span class="line">        //遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入 rets, 否则不能加入</span><br><span class="line">        for(int i=0; i &lt; edgeNum; i++) &#123;</span><br><span class="line">            //获取到第i条边的第一个顶点(起点)</span><br><span class="line">            int p1 = getPosition(edges[i].start); //p1=4</span><br><span class="line">            //获取到第i条边的第2个顶点</span><br><span class="line">            int p2 = getPosition(edges[i].end); //p2 = 5</span><br><span class="line"></span><br><span class="line">            //获取p1这个顶点在已有最小生成树中的终点</span><br><span class="line">            int m = getEnd(ends, p1); //m = 4</span><br><span class="line">            //获取p2这个顶点在已有最小生成树中的终点</span><br><span class="line">            int n = getEnd(ends, p2); // n = 5</span><br><span class="line">            //是否构成回路</span><br><span class="line">            if(m != n) &#123; //没有构成回路</span><br><span class="line">                ends[m] = n; // 设置m 在&quot;已有最小生成树&quot;中的终点 &lt;E,F&gt; [0,0,0,0,5,0,0,0,0,0,0,0]</span><br><span class="line">                rets[index++] = edges[i]; //有一条边加入到rets数组</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。</span><br><span class="line">        //统计并打印 &quot;最小生成树&quot;, 输出  rets</span><br><span class="line">        System.out.println(&quot;最小生成树为&quot;);</span><br><span class="line">        for(int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            System.out.println(rets[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印邻接矩阵</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;邻接矩阵为: \n&quot;);</span><br><span class="line">        for(int i = 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            for(int j=0; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                System.out.printf(&quot;%12d&quot;, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();//换行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 功能：对边进行排序处理, 冒泡排序</span><br><span class="line">     * @param edges 边的集合</span><br><span class="line">     */</span><br><span class="line">    private void sortEdges(EData[] edges) &#123;</span><br><span class="line">        for(int i = 0; i &lt; edges.length - 1; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; edges.length - 1 - i; j++) &#123;</span><br><span class="line">                if(edges[j].weight &gt; edges[j+1].weight) &#123;//交换</span><br><span class="line">                    EData tmp = edges[j];</span><br><span class="line">                    edges[j] = edges[j+1];</span><br><span class="line">                    edges[j+1] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param ch 顶点的值，比如&apos;A&apos;,&apos;B&apos;</span><br><span class="line">     * @return 返回ch顶点对应的下标，如果找不到，返回-1</span><br><span class="line">     */</span><br><span class="line">    private int getPosition(char ch) &#123;</span><br><span class="line">        for(int i = 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            if(vertexs[i] == ch) &#123;//找到</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //找不到,返回-1</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 功能: 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组</span><br><span class="line">     * 是通过matrix 邻接矩阵来获取</span><br><span class="line">     * EData[] 形式 [[&apos;A&apos;,&apos;B&apos;, 12], [&apos;B&apos;,&apos;F&apos;,7], .....]</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private EData[] getEdges() &#123;</span><br><span class="line">        int index = 0;</span><br><span class="line">        EData[] edges = new EData[edgeNum];</span><br><span class="line">        for(int i = 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            for(int j=i+1; j &lt;vertexs.length; j++) &#123;</span><br><span class="line">                if(matrix[i][j] != INF) &#123;</span><br><span class="line">                    edges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return edges;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同</span><br><span class="line">     * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成</span><br><span class="line">     * @param i : 表示传入的顶点对应的下标</span><br><span class="line">     * @return 返回的就是 下标为i的这个顶点对应的终点的下标, 一会回头还有来理解</span><br><span class="line">     */</span><br><span class="line">    private int getEnd(int[] ends, int i) &#123; // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]</span><br><span class="line">        while(ends[i] != 0) &#123;</span><br><span class="line">            i = ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建一个类EData ，它的对象实例就表示一条边</span><br><span class="line">class EData &#123;</span><br><span class="line">    char start; //边的一个点</span><br><span class="line">    char end; //边的另外一个点</span><br><span class="line">    int weight; //边的权值</span><br><span class="line">    //构造器</span><br><span class="line">    public EData(char start, char end, int weight) &#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    //重写toString, 便于输出边信息</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;EData [&lt;&quot; + start + &quot;, &quot; + end + &quot;&gt;= &quot; + weight + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八：迪杰斯特拉算法-最短路径问题"><a href="#八：迪杰斯特拉算法-最短路径问题" class="headerlink" title="八：迪杰斯特拉算法-最短路径问题"></a>八：迪杰斯特拉算法-最短路径问题</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：算法&quot;&gt;&lt;a href=&quot;#1：算法&quot; class=&quot;headerlink&quot; title=&quot;1：算法&quot;&gt;&lt;/a&gt;1：算法&lt;/h1&gt;&lt;h3 id=&quot;1：二分查找：非递归&quot;&gt;&lt;a href=&quot;#1：二分查找：非递归&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（9）图</title>
    <link href="https://yanyubing.xyz/2018/07/24/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E5%9B%BE/"/>
    <id>https://yanyubing.xyz/2018/07/24/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E5%9B%BE/</id>
    <published>2018-07-24T13:46:12.000Z</published>
    <updated>2019-12-06T01:22:18.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：图"><a href="#1：图" class="headerlink" title="1：图"></a>1：图</h1><p>1：图的常用概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1：顶点</span><br><span class="line">2：边</span><br><span class="line">3：路径</span><br><span class="line">4：无向图</span><br><span class="line">5：有向图</span><br><span class="line">6：带权图</span><br><span class="line"></span><br><span class="line">为什么要有图？</span><br><span class="line">数据结构：线性表和树</span><br><span class="line">线性表局限于一个直接前驱和一个直接后继的关系</span><br><span class="line">树也只有一个直接前驱也就是父节点</span><br><span class="line">当我们需要表示多对多关系时，这里我们就用到了图</span><br></pre></td></tr></table></figure><p>2：图的表示方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：邻接矩阵：二维数组</span><br><span class="line">2：邻接表：数组+链表</span><br></pre></td></tr></table></figure><p>3：图的遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1：深度优先</span><br><span class="line">DFS：深度优先搜索法是树的先根遍历的推广，它的基本思想是：从图G的某个顶点v0出发，访问v0，然后选择一个与v0相邻且没被访问过的顶点vi访问，再从vi出发选择一个与vi相邻且未被访问的顶点vj进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点w，从w出发按同样的方法向前遍历，直到图中所有顶点都被访问</span><br><span class="line"></span><br><span class="line">例如：A-(B,C,D)相邻，B-（A,C,F）相邻，C-（A,B,D,E）相邻，D-（A,C）相邻 E-(C)相邻...</span><br><span class="line">则访问顺序为：A --B--C--D--E--F(先访问A，然后A的相邻的B，然后与B相邻的C，然后与C相邻的D，因为与D相邻的都已经被访问，则回退访问与C相邻的E；因为与E相邻的都已经访问过了，则回退访问与C相邻的，而与C相邻的也已经全部访问过了，则回退访问与B相邻的F)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2：广度优先</span><br><span class="line">图的广度优先搜索是树的按层次遍历的推广，它的基本思想是：首先访问初始点vi，并将其标记为已访问过，接着访问vi的所有未被访问过的邻接点vi1,vi2,…, vi t，并均标记已访问过，然后再按照vi1,vi2,…, vi t的次序，访问每一个顶点的所有未被访问过的邻接点，并均标记为已访问过，依次类推，直到图中所有和初始点vi有路径相通的顶点都被访问过为止。</span><br><span class="line"></span><br><span class="line">例如：A-(B,C,D)相邻，B-（A,C,F）相邻，C-（A,B,D,E）相邻，D-（A,C）相邻 E-(C)相邻...</span><br><span class="line">则访问顺序为 A-B-C-D-F-E，先把本节点的相邻节点全部访问完成再访问扩展访问</span><br></pre></td></tr></table></figure><p>4：遍历代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">深度优先遍历核心代码：</span><br><span class="line">while (w != -1) &#123;//说明存在临接节点</span><br><span class="line">            if (!isVisited[w]) &#123;</span><br><span class="line">                dfs(isVisited, w);//这里保证了递归的访问临接节点</span><br><span class="line">            &#125;</span><br><span class="line">            //临接节点都已经访问完开始弹栈，回溯</span><br><span class="line">            //如果w已经被访问，查找下一个临接节点</span><br><span class="line">            while ((w = getNextNeighbor(i, w)) != -1 &amp;&amp; !isVisited[w]) &#123;</span><br><span class="line">                //这时的临接节点存在且没有被访问的情况下继续访问下个临接节点</span><br><span class="line">                dfs(isVisited, w);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">广度优先遍历核心代码：</span><br><span class="line"> //所有访问的节点入队列，如果当前节点的所有临接节点都已经访问完，则出队列，进行下一个的所有临接节点的访问</span><br><span class="line">        LinkedList queue = new LinkedList();</span><br><span class="line">        //首先访问该节点</span><br><span class="line">        System.out.print(getValueByIndex(i) + &quot;→&quot;);</span><br><span class="line">        queue.addLast(i);//访问的节点入队列</span><br><span class="line">        //将该节点设置为已经访问</span><br><span class="line">        isVisited[i] = true;</span><br><span class="line">        while (!queue.isEmpty()) &#123;//队列不为空</span><br><span class="line">            //取出队列的头结点，并且移除</span><br><span class="line">            i = (int) queue.removeFirst();</span><br><span class="line">            //然后访问所有该节点的临接节点</span><br><span class="line">            int w = getFirstNeighbor(i);//访问第一个临接节点</span><br><span class="line">            if (!isVisited[w]) &#123;</span><br><span class="line">                System.out.print(getValueByIndex(w) + &quot;→&quot;);</span><br><span class="line">                queue.addLast(w);</span><br><span class="line">                isVisited[w]=true;</span><br><span class="line">            &#125;</span><br><span class="line">            while (getNextNeighbor(i, w) != -1) &#123;//进入循环证明有下一个临接节点</span><br><span class="line">                int x = getNextNeighbor(i, w);</span><br><span class="line">                if (!isVisited[x]) &#123;</span><br><span class="line">                    System.out.print(getValueByIndex(x) + &quot;→&quot;);</span><br><span class="line">                    queue.addLast(x);//x入队列</span><br><span class="line">                    isVisited[x]=true;</span><br><span class="line">                &#125;</span><br><span class="line">                w = x;//后移</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">package com.it.graph;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">//用二维数组构建图</span><br><span class="line">public class Graph &#123;</span><br><span class="line">    private ArrayList&lt;String&gt; vertexList;   //存储顶点集合</span><br><span class="line">    private int[][] edges;                  //存储图的邻接矩阵，二维数组的大小是n*n</span><br><span class="line">    private int numOfEdges;                 //表示边的数目</span><br><span class="line">    private boolean[] isVisited;    //定义一个数组,表示当前节点是否被访问</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试图是否创建成功</span><br><span class="line">        int n = 8;//节点的个数</span><br><span class="line">        String vertexs[] = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;&#125;;</span><br><span class="line">        //创建图对象</span><br><span class="line">        Graph graph = new Graph(8);</span><br><span class="line">        //循环添加顶点</span><br><span class="line">        for (String vertex : vertexs) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        //添加边</span><br><span class="line">        //A-B  A-C A-G  B-C  B-D  B-E  C-F C-H D-H</span><br><span class="line">        graph.insertEdge(0, 1, 1);</span><br><span class="line">        graph.insertEdge(0, 2, 1);</span><br><span class="line">        graph.insertEdge(0, 6, 1);</span><br><span class="line">        graph.insertEdge(1, 2, 1);</span><br><span class="line">        graph.insertEdge(1, 3, 1);</span><br><span class="line">        graph.insertEdge(1, 4, 1);</span><br><span class="line">        graph.insertEdge(2, 5, 1);</span><br><span class="line">        graph.insertEdge(2, 7, 1);</span><br><span class="line">        graph.insertEdge(3, 7, 1);</span><br><span class="line">        //显示邻接矩阵</span><br><span class="line">        graph.showGraph();</span><br><span class="line">        //测试深度遍历</span><br><span class="line">        boolean[] isVisited1 = new boolean[n];</span><br><span class="line">        boolean[] isVisited2 = new boolean[n];</span><br><span class="line">        System.out.println(&quot;深度遍历&quot;);</span><br><span class="line">        graph.dfs(isVisited1, 0);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;广度遍历&quot;);</span><br><span class="line">        graph.bfs(isVisited2, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param n //n表示顶点的个数</span><br><span class="line">     */</span><br><span class="line">    public Graph(int n) &#123;</span><br><span class="line">        //初始化矩阵和vertexList</span><br><span class="line">        edges = new int[n][n];</span><br><span class="line">        vertexList = new ArrayList&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = 0;//边的数目初始化为0；</span><br><span class="line">        isVisited = new boolean[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param index 传入当前节点的下标</span><br><span class="line">     * @return 返回临接节点的下标，如果没有则返回-1</span><br><span class="line">     */</span><br><span class="line">    //根据当前节点的索引得到一个临接节点的下标</span><br><span class="line">    public int getFirstNeighbor(int index) &#123;</span><br><span class="line">        for (int i = 0; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            if (edges[index][i] &gt; 0) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param v1 当前节点下标</span><br><span class="line">     * @param v2 v1前一个临接节点的下标</span><br><span class="line">     * @return 返回的是v1的除去v2的下一个临接节点</span><br><span class="line">     */</span><br><span class="line">    //根据前一个临接节点的下标来获取下一个临接节点</span><br><span class="line">    public int getNextNeighbor(int v1, int v2) &#123;</span><br><span class="line">        for (int i = v2 + 1; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            if (edges[v1][i] &gt; 0) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //深度优先遍历算法,i第一次就是0</span><br><span class="line">    public void dfs(boolean[] isVisited, int i) &#123;</span><br><span class="line">        //首先访问该节点</span><br><span class="line">        System.out.print(getValueByIndex(i) + &quot;→&quot;);</span><br><span class="line">        //将该节点设置为已经访问</span><br><span class="line">        isVisited[i] = true;</span><br><span class="line">        //获取i的第一个临接节点w</span><br><span class="line">        int w = getFirstNeighbor(i);</span><br><span class="line">        while (w != -1) &#123;//说明存在临接节点</span><br><span class="line">            if (!isVisited[w]) &#123;</span><br><span class="line">                dfs(isVisited, w);//这里保证了递归的访问临接节点</span><br><span class="line">            &#125;//临接节点都已经访问完开始弹栈，回溯</span><br><span class="line">            //如果w已经被访问，查找下一个临接节点</span><br><span class="line">            while ((w = getNextNeighbor(i, w)) != -1 &amp;&amp; !isVisited[w]) &#123;</span><br><span class="line">                //这时的临接节点存在且没有被访问的情况下继续访问下个临接节点</span><br><span class="line">                dfs(isVisited, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //广度优先遍历</span><br><span class="line">    public void bfs(boolean[] isVisited, int i) &#123;</span><br><span class="line">        //所有访问的节点入队列，如果当前节点的所有临接节点都已经访问完，则出队列，进行下一个的所有临接节点的访问</span><br><span class="line">        LinkedList queue = new LinkedList();</span><br><span class="line">        //首先访问该节点</span><br><span class="line">        System.out.print(getValueByIndex(i) + &quot;→&quot;);</span><br><span class="line">        queue.addLast(i);//访问的节点入队列</span><br><span class="line">        //将该节点设置为已经访问</span><br><span class="line">        isVisited[i] = true;</span><br><span class="line">        while (!queue.isEmpty()) &#123;//队列不为空</span><br><span class="line">            //取出队列的头结点，并且移除</span><br><span class="line">            i = (int) queue.removeFirst();</span><br><span class="line">            //然后访问所有该节点的临接节点</span><br><span class="line">            int w = getFirstNeighbor(i);//访问第一个临接节点</span><br><span class="line">            if (!isVisited[w]) &#123;</span><br><span class="line">                System.out.print(getValueByIndex(w) + &quot;→&quot;);</span><br><span class="line">                queue.addLast(w);</span><br><span class="line">                isVisited[w]=true;</span><br><span class="line">            &#125;</span><br><span class="line">            while (getNextNeighbor(i, w) != -1) &#123;//进入循环证明有下一个临接节点</span><br><span class="line">                int x = getNextNeighbor(i, w);</span><br><span class="line">                if (!isVisited[x]) &#123;</span><br><span class="line">                    System.out.print(getValueByIndex(x) + &quot;→&quot;);</span><br><span class="line">                    queue.addLast(x);//x入队列</span><br><span class="line">                    isVisited[x]=true;</span><br><span class="line">                &#125;</span><br><span class="line">                w = x;//后移</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //图中常用的方法</span><br><span class="line">    //1:返回节点的个数</span><br><span class="line">    public int getNumOfVertex() &#123;</span><br><span class="line">        return vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2:得到边的数目</span><br><span class="line">    public int getNumOfEdges() &#123;</span><br><span class="line">        return numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3:返回节点i（下标）对应的数据 0-“A”  1-“B”</span><br><span class="line">    public String getValueByIndex(int i) &#123;</span><br><span class="line">        return vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4:返回v1,v2对应的权值</span><br><span class="line">    public int getWeight(int v1, int v2) &#123;</span><br><span class="line">        return edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5:显示图对应的矩阵（二维数组）</span><br><span class="line">    public void showGraph() &#123;</span><br><span class="line">        for (int[] edge : edges) &#123;</span><br><span class="line">            for (int i : edge) &#123;</span><br><span class="line">                System.out.print(i + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入顶点,vertex：顶点的名称</span><br><span class="line">    public void insertVertex(String vertex) &#123;</span><br><span class="line">        //将顶点加入集合</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param v1     表示点的下标，即第几个顶点。“A”-“B”  “A”-0 “B”-1</span><br><span class="line">     * @param v2     表示点的下标，即第几个顶点。“A”-“B”  “A”-0 “B”-1</span><br><span class="line">     *               举例：要描述A和B的关系，则v1表示A的下标，v2表示B的下标</span><br><span class="line">     * @param weight 表示权值，即A,B两点之间的关系</span><br><span class="line">     */</span><br><span class="line">    //添加边</span><br><span class="line">    public void insertEdge(int v1, int v2, int weight) &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：图&quot;&gt;&lt;a href=&quot;#1：图&quot; class=&quot;headerlink&quot; title=&quot;1：图&quot;&gt;&lt;/a&gt;1：图&lt;/h1&gt;&lt;p&gt;1：图的常用概念&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（8）树</title>
    <link href="https://yanyubing.xyz/2018/07/10/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%91/"/>
    <id>https://yanyubing.xyz/2018/07/10/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%91/</id>
    <published>2018-07-10T13:46:12.000Z</published>
    <updated>2019-12-06T01:22:03.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：树"><a href="#1：树" class="headerlink" title="1：树"></a>1：树</h1><h3 id="1：二叉排序树"><a href="#1：二叉排序树" class="headerlink" title="1：二叉排序树"></a>1：二叉排序树</h3><p>1：二叉排序树概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一棵空树，或者是具有下列性质的二叉树：</span><br><span class="line">（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</span><br><span class="line">（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</span><br><span class="line">（3）左、右子树也分别为二叉排序树；</span><br><span class="line">（4）没有键值相等的结点。</span><br></pre></td></tr></table></figure><p>2：功能实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：二叉排序树的创建，遍历</span><br><span class="line">2；二叉排序树的删除分三种情况：①删除叶子节点 ②删除只有一颗子树的节点 ③删除有两颗子树的节点</span><br></pre></td></tr></table></figure><p>3：二叉排序树删除节点的三种情况具体思路分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：删除叶子节点思路</span><br><span class="line">①定位要删除的节点</span><br><span class="line">②找到目标节点的父节点parent</span><br><span class="line">③确定目标节点和父节点的关系</span><br><span class="line">④删除，即为置空</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2：删除只有一颗子树的节点</span><br><span class="line">①定位要删除的节点</span><br><span class="line">②找到目标节点的父节点parent</span><br><span class="line">③确定目标节点的子节点是左子节点还是右子节点</span><br><span class="line">④确定目标节点是parent的左子节点还是右子节点</span><br><span class="line">③④两步实际上都是为了把目标节点替换成它的子节点</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3：删除有两颗子树的节点</span><br><span class="line">①定位要删除的节点</span><br><span class="line">②找到目标节点的父节点parent</span><br><span class="line">③储存目标节点的右子树的最小节点temp</span><br><span class="line">④删除该节点，把目标节点的值替换为temp</span><br><span class="line">注意：此处③这里也可以找左子树中的所有节点的最大值为temp</span><br><span class="line"></span><br><span class="line">注意：其实最重要的就是把每种情况都列举完全，不漏不累赘！</span><br></pre></td></tr></table></figure><p>4：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">package com.it.binarysorttree;</span><br><span class="line"></span><br><span class="line">//二叉排序树</span><br><span class="line">public class BinarySortTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;7, 3, 10, 12, 5, 1, 9, 2&#125;;</span><br><span class="line">        //创建二叉排序树</span><br><span class="line">        BinarySortTree binarySortTree = new BinarySortTree();</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySortTree.add(new Node(arr[i]));//迭代添加节点</span><br><span class="line">        &#125;</span><br><span class="line">        //中序遍历</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">        //测试情况一：删除叶子节点</span><br><span class="line">        binarySortTree.delNode(2);</span><br><span class="line">        System.out.println(&quot;删除叶子节点之后&quot;);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">        //测试所有情况：</span><br><span class="line">        System.out.println(&quot;删除root节点之后&quot;);</span><br><span class="line">        binarySortTree.delNode(7);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">        System.out.println(&quot;----------------&quot;);</span><br><span class="line">        binarySortTree.delNode(10);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建</span><br><span class="line">class BinarySortTree &#123;</span><br><span class="line">    private Node root;</span><br><span class="line"></span><br><span class="line">    //查找要删除的节点</span><br><span class="line">    public Node search(int value) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else return root.search(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找父节点</span><br><span class="line">    public Node searchParent(int value) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param node 传入的节点（当做二叉排序树的根节点）</span><br><span class="line">     * @return 返回的以node为根节点的二叉排序树的最小节点的值，同时完成删除最小节点</span><br><span class="line">     */</span><br><span class="line">    public int delRightTreeMin(Node node) &#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        //循环查找左边节点，就会找到最小值</span><br><span class="line">        while (target.left != null) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;//循环结束target就指向了最小节点</span><br><span class="line">        delNode(target.value);//删除最小节点</span><br><span class="line">        return target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除节点</span><br><span class="line">    public void delNode(int value) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //1：需要先去找到要删除的节点，targetNode</span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            //如果没有找到要删除的值</span><br><span class="line">            if (targetNode == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果我们发现当前这颗二叉排序树只有一个节点，到这里说明root就是要删除的节点</span><br><span class="line">            if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">                root = null;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //去找target的父节点</span><br><span class="line">            Node parentNode = searchParent(value);</span><br><span class="line">            //特殊情况，如果删除的节点是root节点，但是root节点有子节点的情况</span><br><span class="line">            //分两种情况，一种是只有一颗子树的情况</span><br><span class="line">            if (parentNode == null) &#123;</span><br><span class="line">                System.out.println(&quot;你要删除根节点且根节点底下有子树&quot;);</span><br><span class="line">                //只有一个左子树</span><br><span class="line">                if (targetNode.left != null &amp;&amp; targetNode.right == null) &#123;</span><br><span class="line">                    targetNode = targetNode.left;</span><br><span class="line">                &#125; else if (targetNode.left == null &amp;&amp; targetNode.right != null) &#123;</span><br><span class="line">                    targetNode = targetNode.right;</span><br><span class="line">                &#125; else &#123;//说明根节点有两个子树</span><br><span class="line">                    int minVal = delRightTreeMin(targetNode.right);//minVal就就是右子树的最小值</span><br><span class="line">                    targetNode.value = minVal;//该节点的值重置为minVal</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //情况一：如果要删除的节点是叶子节点</span><br><span class="line">                if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123;</span><br><span class="line">                    //判断targetNode是父节点的左子节点还是右子节点</span><br><span class="line">                    if (parentNode.left != null &amp;&amp; parentNode.left.value == value) &#123;</span><br><span class="line">                        parentNode.left = null;</span><br><span class="line">                    &#125; else if (parentNode.right != null &amp;&amp; parentNode.right.value == value) &#123;//说明是右子节点</span><br><span class="line">                        parentNode.right = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (targetNode.left != null &amp;&amp; targetNode.right != null) &#123;</span><br><span class="line">                    //情况三：删除有两个叶子节点的节点</span><br><span class="line">                    //③储存目标节点的右子树的最小节点temp</span><br><span class="line">                    int minVal = delRightTreeMin(targetNode.right);//minVal就就是最小值</span><br><span class="line">                    targetNode.value = minVal;//该节点的值重置为minVal</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //情况二：删除只有一颗子树的节点（此时放在最后写，是不用去判断条件）</span><br><span class="line">                    //如果要删除的节点有左子节点</span><br><span class="line">                    if (targetNode.left != null) &#123;//说明此时的目标节点存在的是左子树</span><br><span class="line">                        if (parentNode.left == targetNode) &#123;//如果目标节点是父节点的左子节点</span><br><span class="line">                            parentNode.left = targetNode.left;//重置</span><br><span class="line">                        &#125; else &#123;//如果目标节点是父节点的右子节点</span><br><span class="line">                            parentNode.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;//如果要删除的节点存在的是右子节点</span><br><span class="line">                        if (parentNode.left == targetNode) &#123;//如果目标节点是父节点的左子节点</span><br><span class="line">                            parentNode.left = targetNode.right;</span><br><span class="line">                        &#125; else &#123;//如果目标节点是父节点的右子节点</span><br><span class="line">                            parentNode.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点的方法</span><br><span class="line">    public void add(Node node) &#123;</span><br><span class="line">        if (root == null) &#123;//说明现在是空树</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉排序树是空的，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//节点</span><br><span class="line">class Node &#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    public Node(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param value 想要查找节点的值</span><br><span class="line">     * @return 如果找到，则返回节点，如果没找到，则返回null</span><br><span class="line">     */</span><br><span class="line">    public Node search(int value) &#123;</span><br><span class="line">        if (value == this.value) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else if (value &lt; this.value) &#123;//如果查找的值小于当前节点，则需要在左子树递归查找，</span><br><span class="line">            if (this.left == null) &#123;//说明没找到</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.left.search(value);</span><br><span class="line">        &#125; else &#123;//如果查找的值大于当前节点，则向右子树查找</span><br><span class="line">            if (this.right == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param value 要查找节点的值</span><br><span class="line">     * @return 返回值为该节点的父节点，没有就null</span><br><span class="line">     */</span><br><span class="line">    //查找要删除节点的父节点</span><br><span class="line">    public Node searchParent(int value) &#123;</span><br><span class="line">        //说明this就为要删除节点的父节点</span><br><span class="line">        if ((this.left != null &amp;&amp; this.left.value == value) ||</span><br><span class="line">                this.right != null &amp;&amp; this.right.value == value) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果要查找的值小于当前节点的值，并且当前节点的子节点不为空</span><br><span class="line">            if (value &lt; this.value &amp;&amp; this.left != null) &#123;</span><br><span class="line">                return this.left.searchParent(value);//向左子树递归</span><br><span class="line">            &#125; else if (value &gt;= this.value &amp;&amp; this.right != null) &#123;//实际使用需要避免有相同值</span><br><span class="line">                return this.right.searchParent(value);//向右子树递归查找</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点的方法</span><br><span class="line">    //递归添加节点，注意需要满足二叉排序树的要求</span><br><span class="line">    public void add(Node node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断当前节点的值和当前子树根节点的关系</span><br><span class="line">        if (node.value &lt; this.value) &#123;</span><br><span class="line">            //当前节点的左子节点为空，直接挂上</span><br><span class="line">            if (this.left == null) &#123;</span><br><span class="line">                this.left = node;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果当前节点的左子节点不为空，递归</span><br><span class="line">            else &#123;</span><br><span class="line">                this.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;//node.value &gt;= this.value</span><br><span class="line">            if (this.right == null) &#123;</span><br><span class="line">                this.right = node;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node [value=&quot; + value + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2：平衡二叉树"><a href="#2：平衡二叉树" class="headerlink" title="2：平衡二叉树"></a>2：平衡二叉树</h3><p>1：平衡二叉树（AVL树）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">分析：给你一个数列&#123;1,2,3,4,5,6&#125;，要求创建一个二叉排序树</span><br><span class="line">问题：这个时候的二叉排序树相当于是单链表（左链表为空），插入和删除没问题，但是查询慢</span><br><span class="line">1：平衡二叉树又被叫做平衡二叉搜索树，又被称为AVL树</span><br><span class="line">2：首先得是二叉排序树</span><br><span class="line">3：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法（算法）有红黑树、AVL、替罪羊树、Treap、伸展树等。 </span><br><span class="line">4：最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci（斐波那契）数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。</span><br></pre></td></tr></table></figure><p>2：左旋转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二叉左旋</span><br><span class="line">一棵二叉平衡树的子树，根是Root，左子树是x，右子树的根为RootR，右子树的两个孩子树分别为RLeftChild和RRightChild。则左旋后，该子树的根为RootR，右子树为RRightChild，左子树的根为Root，Root的两个孩子树分别为x（左）和RLeftChild（右）。</span><br></pre></td></tr></table></figure><p>3：右旋转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一棵二叉平衡树的子树，根是Root，右子树是x，左子树的根为RootL，左子树的两个孩子树分别为LLeftChild和LRightChild。则右旋后，该子树的根为RootL，左子树为LLeftChild，右子树的根为Root，Root的两个孩子树分别为LRightChild（左）和x（右）。</span><br></pre></td></tr></table></figure><p>4：双旋转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">问题：int []arr=&#123;10,11,7,6,8,9&#125;;使用右旋转无法得到AVL树</span><br><span class="line">双旋转处理步骤：</span><br><span class="line">1：当满足右旋转时</span><br><span class="line">2：触发条件：如果当前节点的左子树的右子树的高度大于当前点的左子树的左子树的高度</span><br><span class="line">3：先对当前节点的左节点进行左旋转</span><br><span class="line">4：再对当前节点进行右旋转即可</span><br></pre></td></tr></table></figure><p>5：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line">package com.it.avl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AVLTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        int[] arr = &#123;4, 3, 6, 5, 7, 8&#125;;</span><br><span class="line">//        int [] arr=&#123;10,12,8,9,7,6&#125;;</span><br><span class="line">        int[] arr = &#123;10, 11, 7, 6, 8, 9&#125;;</span><br><span class="line"></span><br><span class="line">        //创建一个AVLTree对象</span><br><span class="line">        AVLTree avlTree = new AVLTree();</span><br><span class="line">        //添加节点</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            avlTree.add(new Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历</span><br><span class="line">        System.out.println(&quot;中序遍历&quot;);</span><br><span class="line">        avlTree.infixOrder();</span><br><span class="line">        //没有做平衡前</span><br><span class="line">        System.out.println(&quot;树的高度=&quot; + avlTree.getRoot().height());</span><br><span class="line">        System.out.println(&quot;左子树的高度=&quot; + avlTree.getRoot().leftHeight());</span><br><span class="line">        System.out.println(&quot;右子树的高度=&quot; + avlTree.getRoot().rightHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建AVL Tree,是平衡二叉树的一种</span><br><span class="line">class AVLTree &#123;</span><br><span class="line">    private Node root;</span><br><span class="line"></span><br><span class="line">    public Node getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找要删除的节点</span><br><span class="line">    public Node search(int value) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else return root.search(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找父节点</span><br><span class="line">    public Node searchParent(int value) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param node 传入的节点（当做二叉排序树的根节点）</span><br><span class="line">     * @return 返回的以node为根节点的二叉排序树的最小节点的值，同时完成删除最小节点</span><br><span class="line">     */</span><br><span class="line">    public int delRightTreeMin(Node node) &#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        //循环查找左边节点，就会找到最小值</span><br><span class="line">        while (target.left != null) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;//循环结束target就指向了最小节点</span><br><span class="line">        delNode(target.value);//删除最小节点</span><br><span class="line">        return target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除节点</span><br><span class="line">    public void delNode(int value) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //1：需要先去找到要删除的节点，targetNode</span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            //如果没有找到要删除的值</span><br><span class="line">            if (targetNode == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果我们发现当前这颗二叉排序树只有一个节点，到这里说明root就是要删除的节点</span><br><span class="line">            if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">                root = null;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //去找target的父节点</span><br><span class="line">            Node parentNode = searchParent(value);</span><br><span class="line">            //特殊情况，如果删除的节点是root节点，但是root节点有子节点的情况</span><br><span class="line">            //分两种情况，一种是只有一颗子树的情况</span><br><span class="line">            if (parentNode == null) &#123;</span><br><span class="line">                System.out.println(&quot;你要删除根节点且根节点底下有子树&quot;);</span><br><span class="line">                //只有一个左子树</span><br><span class="line">                if (targetNode.left != null &amp;&amp; targetNode.right == null) &#123;</span><br><span class="line">                    targetNode = targetNode.left;</span><br><span class="line">                &#125; else if (targetNode.left == null &amp;&amp; targetNode.right != null) &#123;</span><br><span class="line">                    targetNode = targetNode.right;</span><br><span class="line">                &#125; else &#123;//说明根节点有两个子树</span><br><span class="line">                    int minVal = delRightTreeMin(targetNode.right);//minVal就就是右子树的最小值</span><br><span class="line">                    targetNode.value = minVal;//该节点的值重置为minVal</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //情况一：如果要删除的节点是叶子节点</span><br><span class="line">                if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123;</span><br><span class="line">                    //判断targetNode是父节点的左子节点还是右子节点</span><br><span class="line">                    if (parentNode.left != null &amp;&amp; parentNode.left.value == value) &#123;</span><br><span class="line">                        parentNode.left = null;</span><br><span class="line">                    &#125; else if (parentNode.right != null &amp;&amp; parentNode.right.value == value) &#123;//说明是右子节点</span><br><span class="line">                        parentNode.right = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (targetNode.left != null &amp;&amp; targetNode.right != null) &#123;</span><br><span class="line">                    //情况三：删除有两个叶子节点的节点</span><br><span class="line">                    //③储存目标节点的右子树的最小节点temp</span><br><span class="line">                    int minVal = delRightTreeMin(targetNode.right);//minVal就就是最小值</span><br><span class="line">                    targetNode.value = minVal;//该节点的值重置为minVal</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //情况二：删除只有一颗子树的节点（此时放在最后写，是不用去判断条件）</span><br><span class="line">                    //如果要删除的节点有左子节点</span><br><span class="line">                    if (targetNode.left != null) &#123;//说明此时的目标节点存在的是左子树</span><br><span class="line">                        if (parentNode.left == targetNode) &#123;//如果目标节点是父节点的左子节点</span><br><span class="line">                            parentNode.left = targetNode.left;//重置</span><br><span class="line">                        &#125; else &#123;//如果目标节点是父节点的右子节点</span><br><span class="line">                            parentNode.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;//如果要删除的节点存在的是右子节点</span><br><span class="line">                        if (parentNode.left == targetNode) &#123;//如果目标节点是父节点的左子节点</span><br><span class="line">                            parentNode.left = targetNode.right;</span><br><span class="line">                        &#125; else &#123;//如果目标节点是父节点的右子节点</span><br><span class="line">                            parentNode.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点的方法</span><br><span class="line">    public void add(Node node) &#123;</span><br><span class="line">        if (root == null) &#123;//说明现在是空树</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉排序树是空的，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//节点</span><br><span class="line">class Node &#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    public Node(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回左子树的高度</span><br><span class="line">    public int leftHeight() &#123;</span><br><span class="line">        if (left == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return left.height();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回右子树的高度</span><br><span class="line">    public int rightHeight() &#123;</span><br><span class="line">        if (right == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回当前节点的高度，以该节点为根节点的树的高度</span><br><span class="line">    public int height() &#123;</span><br><span class="line">        return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //左旋转</span><br><span class="line">    private void leftRotate() &#123;//在添加节点的时候调用该方法</span><br><span class="line"></span><br><span class="line">        //以当前根节点的值创建新的节点</span><br><span class="line">        Node newNode = new Node(value);</span><br><span class="line">        //把新的节点的左子树设置为当前节点的左子树</span><br><span class="line">        newNode.left = left;</span><br><span class="line">        //把新的节点右子树设置成当前节点的右子树的左子树</span><br><span class="line">        newNode.right = right.left;</span><br><span class="line">        //把当前节点的值替换成右子节点的值</span><br><span class="line">        value = right.value;</span><br><span class="line">        //把当前节点的右子树设置成当前节点的右子节点的右子树</span><br><span class="line">        right = right.right;</span><br><span class="line">        //把当前节点的左子节点设置成新的节点</span><br><span class="line">        left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //右旋转</span><br><span class="line">    private void rightRotate() &#123;</span><br><span class="line">        //以当前根节点的值创建新的节点</span><br><span class="line">        Node newNode = new Node(value);</span><br><span class="line">        newNode.right = right;</span><br><span class="line">        newNode.left = left.right;</span><br><span class="line">        left = left.left;</span><br><span class="line">        value = left.value;</span><br><span class="line">        right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param value 想要查找节点的值</span><br><span class="line">     * @return 如果找到，则返回节点，如果没找到，则返回null</span><br><span class="line">     */</span><br><span class="line">    public Node search(int value) &#123;</span><br><span class="line">        if (value == this.value) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else if (value &lt; this.value) &#123;//如果查找的值小于当前节点，则需要在左子树递归查找，</span><br><span class="line">            if (this.left == null) &#123;//说明没找到</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.left.search(value);</span><br><span class="line">        &#125; else &#123;//如果查找的值大于当前节点，则向右子树查找</span><br><span class="line">            if (this.right == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param value 要查找节点的值</span><br><span class="line">     * @return 返回值为该节点的父节点，没有就null</span><br><span class="line">     */</span><br><span class="line">    //查找要删除节点的父节点</span><br><span class="line">    public Node searchParent(int value) &#123;</span><br><span class="line">        //说明this就为要删除节点的父节点</span><br><span class="line">        if ((this.left != null &amp;&amp; this.left.value == value) ||</span><br><span class="line">                this.right != null &amp;&amp; this.right.value == value) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果要查找的值小于当前节点的值，并且当前节点的子节点不为空</span><br><span class="line">            if (value &lt; this.value &amp;&amp; this.left != null) &#123;</span><br><span class="line">                return this.left.searchParent(value);//向左子树递归</span><br><span class="line">            &#125; else if (value &gt;= this.value &amp;&amp; this.right != null) &#123;//实际使用需要避免有相同值</span><br><span class="line">                return this.right.searchParent(value);//向右子树递归查找</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点的方法</span><br><span class="line">    //递归添加节点，注意需要满足二叉排序树的要求</span><br><span class="line">    public void add(Node node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断当前节点的值和当前子树根节点的关系</span><br><span class="line">        if (node.value &lt; this.value) &#123;</span><br><span class="line">            //当前节点的左子节点为空，直接挂上</span><br><span class="line">            if (this.left == null) &#123;</span><br><span class="line">                this.left = node;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果当前节点的左子节点不为空，递归</span><br><span class="line">            else &#123;</span><br><span class="line">                this.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;//node.value &gt;= this.value</span><br><span class="line">            if (this.right == null) &#123;</span><br><span class="line">                this.right = node;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //当添加完一个节点后，如果（右子树的高度-左子树的高度&gt;1），左旋转</span><br><span class="line">        if (rightHeight() - leftHeight() &gt; 1) &#123;</span><br><span class="line">//            如果当前节点的右子树的左子树的高度大于当前点的右子树的右子树的高度</span><br><span class="line">//            这里进行双旋转</span><br><span class="line">            if (right != null &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;</span><br><span class="line">                //先对当前节点的右子树进行右旋转</span><br><span class="line">                right.rightRotate();</span><br><span class="line">                //再对当前节点进行左旋转</span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //当添加完一个节点后，如果（左子树的高度-右子树的高度&gt;1），右旋转</span><br><span class="line">        if (leftHeight() - rightHeight() &gt; 1) &#123;</span><br><span class="line">//            如果当前节点的左子树的右子树的高度大于当前点的左子树的左子树的高度（根节点表示当前节点）</span><br><span class="line">//            这里进行双旋转</span><br><span class="line">            if (left != null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;</span><br><span class="line">                //先对当前节点的左子树进行左旋转</span><br><span class="line">                left.leftRotate();</span><br><span class="line">                //再对当前节点进行右旋转</span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //直接进行右旋转即可</span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node [value=&quot; + value + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3：N叉树与B树"><a href="#3：N叉树与B树" class="headerlink" title="3：N叉树与B树"></a>3：N叉树与B树</h3><p>1：N叉树介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">树家族是为了实现方便快捷的查找而存在的。树的高度是命中查找的一个不可抗拒的时间下限。在一定的数据条件下，树的高度和宽度是互相制约的。（就像一定面积下，矩形的长和宽是互相制约的）而树家族中最简单的二叉树，尽管易于实现，却不能有实际的价值。其最最令人发指的是二叉树的高度太高。n叉树的提出和实现解决了二叉树的不足，典型的n叉树有：2-3-4树/红黑树和B树。</span><br><span class="line"></span><br><span class="line">需要满足排序树的需求！</span><br></pre></td></tr></table></figure><p>2：B树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">树的度M：对于二叉树而言，每个节点的最多有2个子节点，该节点的度最多为2，所有二叉树的度为2。树的度是指树中节点最多的节点的度。</span><br><span class="line"></span><br><span class="line">举例：将树的度设置为1024，在600亿个元素中最多只需要进行4次I/O就可以读取到想要的元素，1024*1024*1024*1024   即该树只需要4层就可以储存600亿个元素</span><br></pre></td></tr></table></figure><p>3：B树结构之一：2-3树介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：2-3树的所有叶子节点都在同一层（只要是B树都满足这个条件）</span><br><span class="line">2：有两个子节点的节点叫做二节点，二节点要么有2个子节点，要么没有子节点</span><br><span class="line">3：有三个子节点的节点叫做三节点，三节点要么有3个子节点，要么没有子节点</span><br><span class="line">4:2-3树是由二节点和三节点构建的数</span><br><span class="line">5：2-3树与满二叉树相似。高为h的2-3树包含的节点数大于等于高度为h的满二叉树的节点数，即至少有2^h-1个节点。</span><br></pre></td></tr></table></figure><p>4:2-3树的构建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">说明：&#123;&#125;表示树，（）表示节点在同一层形成的3节点的父节点类型 →表示指向右子节点 ←表示指向左子节点</span><br><span class="line">1：首先明白2-3树的父节点形式，父节点可以是1个Node,对应2节点；也可以是2个Node，对应的3节点。</span><br><span class="line">2：构建步骤</span><br><span class="line">1：第一个Node1成为2节点的父节点类型  1形式 &#123;Node1&#125;  </span><br><span class="line">2：第二个Node2与Node1比较，Node2&gt;Node1就把Node放在Node1的右边，Node1与Node2同时在一层，形成了3节点的父节点类型  &#123;(Node1 Node2)&#125; 2形式</span><br><span class="line">3：第三个Node3加入时形成一个2节点的排序树，这里需要变形   1+（1+1）形式  &#123;Node2←Node1→Node3&#125;</span><br><span class="line">4：第四个Node4加入时，如果Node4大于Node1且小于Node3      &#123;Node2←Node1→(Node4 Node3)&#125;</span><br><span class="line">5：第五个Node5加入时，形成一个2节点的子节点全为三节点的父节点类型，这里需要变形，如Node5大于Node1且小于Node4时  1+（2+2）形式 &#123;（Node2 Node1）←Node5→(Node4 Node3)&#125;</span><br><span class="line">6：第6个Node6加入时，也需要变形成2+（1+1+2）形式</span><br><span class="line">7：第7个Node6加入时，   形成2+（2+2+1）形式</span><br><span class="line">....</span><br><span class="line">总结：增加1个节点就需要变形的情况为叶子节点的个数为2，但是需要在该节点上继续添加一个值</span><br></pre></td></tr></table></figure><p>5：B+树介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址（链表储存，且关键字有序），叶子结点以上各层作为索引使用（上层不作为实际存储数据的节点）。一棵m阶的B+树定义如下:</span><br><span class="line">(1)每个结点至多有m个子女； </span><br><span class="line">(2)除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女；</span><br><span class="line">(3)有k个子女的结点必有k个关键字。 </span><br><span class="line">B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。</span><br></pre></td></tr></table></figure><p>6：B*树介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：树&quot;&gt;&lt;a href=&quot;#1：树&quot; class=&quot;headerlink&quot; title=&quot;1：树&quot;&gt;&lt;/a&gt;1：树&lt;/h1&gt;&lt;h3 id=&quot;1：二叉排序树&quot;&gt;&lt;a href=&quot;#1：二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;1：二叉排序树
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（7）树</title>
    <link href="https://yanyubing.xyz/2018/07/02/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%E6%A0%91/"/>
    <id>https://yanyubing.xyz/2018/07/02/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%E6%A0%91/</id>
    <published>2018-07-02T13:46:12.000Z</published>
    <updated>2019-12-06T01:21:47.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：树"><a href="#1：树" class="headerlink" title="1：树"></a>1：树</h1><h3 id="一：普通二叉树"><a href="#一：普通二叉树" class="headerlink" title="一：普通二叉树"></a>一：普通二叉树</h3><p>1：树结构的概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：数组结构的查找快，但是增删慢（数组需要扩容，同时数组索引需要整体移动）；集合的底层也是数组</span><br><span class="line">2：链表结构的增删快，但是查找慢（链表无索引，需要整体遍历）</span><br><span class="line">3：二叉排序树的结构效率都高，最多有左子节点和右子节点</span><br><span class="line">4：满二叉树，节点个数=2^n-1</span><br><span class="line">5：完全二叉树，如果一棵具有n个结点的深度为k的二叉树，它的每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应，这棵二叉树称为完全二叉树。</span><br></pre></td></tr></table></figure><p>2：二叉树遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">① NLR：前序遍历(Preorder Traversal 亦称（先序遍历））</span><br><span class="line">——访问根结点的操作发生在遍历其左右子树之前。</span><br><span class="line">根→左→右</span><br><span class="line">② LNR：中序遍历(Inorder Traversal)</span><br><span class="line">——访问根结点的操作发生在遍历其左右子树之中（间）。</span><br><span class="line">左→根→右</span><br><span class="line">③ LRN：后序遍历(Postorder Traversal)</span><br><span class="line">——访问根结点的操作发生在遍历其左右子树之后。</span><br><span class="line">左→右→根</span><br><span class="line">注意：遍历的实际方法是在节点类中去创建的</span><br></pre></td></tr></table></figure><p>3：二叉树的查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">此时二叉树为无序二叉树，所以比较只有相等和不等</span><br><span class="line">1：前序查找，先与根节点比较，再与左边节点比较，递归前序查找；最后与右边节点比较，再递归前序查找</span><br><span class="line">2：中序查找...</span><br><span class="line">3：后序查找...</span><br></pre></td></tr></table></figure><p>4：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">package com.it.tree;</span><br><span class="line"></span><br><span class="line">public class BinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BinaryTree binaryTree = new BinaryTree();</span><br><span class="line">        HeroNode root = new HeroNode(1, &quot;宋江&quot;);</span><br><span class="line">        HeroNode heroNode2 = new HeroNode(2, &quot;吴用&quot;);</span><br><span class="line">        HeroNode heroNode3 = new HeroNode(3, &quot;卢俊义&quot;);</span><br><span class="line">        HeroNode heroNode4 = new HeroNode(4, &quot;林冲&quot;);</span><br><span class="line">        HeroNode heroNode5 = new HeroNode(5, &quot;关胜&quot;);</span><br><span class="line">        //说明，二叉树应该是递归创建，此处先手动创建</span><br><span class="line">        root.setLeft(heroNode2);</span><br><span class="line">        root.setRight(heroNode3);</span><br><span class="line">        heroNode3.setRight(heroNode4);</span><br><span class="line">        //设置root节点</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line">        //测试：遍历</span><br><span class="line">        //1：前序遍历</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        System.out.println(&quot;--------------&quot;);</span><br><span class="line">        //2:中序遍历</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line">        System.out.println(&quot;--------------&quot;);</span><br><span class="line">        //3：后续遍历</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line">        System.out.println(&quot;--------------&quot;);</span><br><span class="line">        //测试：查找</span><br><span class="line">        System.out.println(binaryTree.preFind(2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建二叉树</span><br><span class="line">class BinaryTree &#123;</span><br><span class="line">    //遍历是由二叉树根节点调用的，但是实际执行的是每个节点的方法</span><br><span class="line">    private HeroNode root;//创建根节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void setRoot(HeroNode root) &#123;</span><br><span class="line">        this.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序查找</span><br><span class="line">    public HeroNode preFind(int no) &#123;</span><br><span class="line">        HeroNode heroNode = null;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            heroNode = this.root.preFind(no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法查找！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序遍历</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            this.root.preOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            this.root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //后续遍历</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            this.root.postOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//hero节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    private int no;</span><br><span class="line">    private String name;</span><br><span class="line">    private HeroNode left;</span><br><span class="line">    private HeroNode right;</span><br><span class="line"></span><br><span class="line">    public HeroNode(int no, String name) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode getLeft() &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeft(HeroNode left) &#123;</span><br><span class="line">        this.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode getRight() &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRight(HeroNode right) &#123;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;no=&quot; + no +</span><br><span class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //节点的前序遍历方法</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this);//先输出父节点</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.preOrder();//递归前序遍历</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        //递归向左子树中序遍历</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        //输出父节点</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //后序遍历</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序查找</span><br><span class="line">    public HeroNode preFind(int no) &#123;</span><br><span class="line">        //先比较当前节点是不是</span><br><span class="line">        if (this.no == no) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode res = null;</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            res = this.left.preFind(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (res != null) &#123;</span><br><span class="line">            return res;//说明左子树找到</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            res = this.right.preFind(no);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二：顺序存储二叉树"><a href="#二：顺序存储二叉树" class="headerlink" title="二：顺序存储二叉树"></a>二：顺序存储二叉树</h3><p>1：顺序存储二叉树概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：从数据结构看，数组存储方式和树的存储方式可以相互转换</span><br><span class="line">2：顺序二叉树通常只考虑完全二叉树</span><br><span class="line">3：第n个元素的左子节点为2*n+1</span><br><span class="line">4：第n个元素的左子节点为2*n+2</span><br><span class="line">5：第n个元素的父节点为（n-1）/2</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">以下代码为：通过二叉树的前序遍历方式遍历数组</span><br><span class="line">package com.it.tree;</span><br><span class="line"></span><br><span class="line">public class ArrBinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //以二叉树的前序遍历方式遍历数组</span><br><span class="line">        int[] arr = &#123;1, 2, 3, 4, 5, 6, 7&#125;;</span><br><span class="line">        //创建一个ArrBinaryTree</span><br><span class="line">        ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);</span><br><span class="line">        arrBinaryTree.preOrder();//从根节点开始遍历</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写一个ArrayBinaryTree,实现顺序存储二叉树遍历</span><br><span class="line">class ArrBinaryTree &#123;</span><br><span class="line">    private int[] arr;//存储二叉树节点的数组</span><br><span class="line"></span><br><span class="line">    public ArrBinaryTree(int[] arr) &#123;</span><br><span class="line">        this.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        this.preOrder(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //编写一个方法，完成顺序存储二叉树前序遍历</span><br><span class="line">    public void preOrder(int index) &#123;//index表示数组的下标</span><br><span class="line">        //如果数组为空，或者arr.length=0;</span><br><span class="line">        if (arr == null || arr.length == 0) &#123;</span><br><span class="line">            System.out.println(&quot;数组为空，不能遍历&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(arr[index]);//输出当前元素</span><br><span class="line">            //向左递归遍历</span><br><span class="line">            if (index * 2 + 1 &lt; arr.length) &#123;//证明有左节点</span><br><span class="line">                preOrder(2 * index + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            //向右递归遍历</span><br><span class="line">            if (index * 2 + 2 &lt; arr.length) &#123;//证明有右节点</span><br><span class="line">                preOrder(index * 2 + 2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三：线索化二叉树"><a href="#三：线索化二叉树" class="headerlink" title="三：线索化二叉树"></a>三：线索化二叉树</h3><p>1：线索化二叉树概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。</span><br><span class="line">运算：一个节点2个指针，n个节点则有2n个指针，而n个节点需要n-1个指针连接，则空指针域的个数为2n-(n-1)=n+1个</span><br><span class="line">2：二叉树的遍历本质上是将一个复杂的非线性结构转换为线性结构，使每个结点都有了唯一前驱和后继（第一个结点无前驱，最后一个结点无后继）。对于二叉树的一个结点，查找其左右子女是方便的，其前驱后继只有在遍历中得到。为了容易找到前驱和后继，有两种方法。一是在结点结构中增加向前和向后的指针，这种方法增加了存储开销，不可取；二是利用二叉树的空链指针。</span><br><span class="line">3：在二叉树的结点上加上线索的二叉树称为线索二叉树，对二叉树以某种遍历方式（如先序、中序、后序或层次等）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。</span><br><span class="line">4：一个节点的前一个节点，称为前驱节点</span><br><span class="line">5：一个节点的后一个节点，称为后继节点</span><br><span class="line">6：线索化的实际意义就是把每个节点都产生关联，把空指针域给填满！</span><br></pre></td></tr></table></figure><p>2：中序线索化二叉树遍历代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：因为线索化二叉树的最后一排节点的前驱和后继节点都已经被填满，所以不能用传统判断是否为空的方式作为递归的结束点</span><br><span class="line">2：继而设置了leftType和rightType是否==1来判断是不是前驱或者后继节点（对应原二叉树的null）</span><br><span class="line">3：用中序线索化的二叉树，就用对应的中序遍历保持一致</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line">package com.it.tree;</span><br><span class="line"></span><br><span class="line">public class ThreadedBinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试中序线索化二叉树功能</span><br><span class="line">        HeroNode2 root = new HeroNode2(1, &quot;tom&quot;);</span><br><span class="line">        HeroNode2 heroNode2 = new HeroNode2(3, &quot;jack&quot;);</span><br><span class="line">        HeroNode2 heroNode3 = new HeroNode2(6, &quot;smith&quot;);</span><br><span class="line">        HeroNode2 heroNode4 = new HeroNode2(8, &quot;mary&quot;);</span><br><span class="line">        HeroNode2 heroNode5 = new HeroNode2(10, &quot;king&quot;);</span><br><span class="line">        HeroNode2 heroNode6 = new HeroNode2(14, &quot;dim&quot;);</span><br><span class="line">        //二叉树后面递归创建，暂时手动创建</span><br><span class="line">        root.setLeft(heroNode2);</span><br><span class="line">        root.setRight(heroNode3);</span><br><span class="line">        heroNode2.setLeft(heroNode4);</span><br><span class="line">        heroNode2.setRight(heroNode5);</span><br><span class="line">        heroNode3.setLeft(heroNode6);</span><br><span class="line">        //测试线索化</span><br><span class="line">        BinaryTree2 binaryTree2 = new BinaryTree2();</span><br><span class="line">        binaryTree2.setRoot(root);</span><br><span class="line">        binaryTree2.threadedNodes();</span><br><span class="line">        //测试</span><br><span class="line">        HeroNode2 left = heroNode5.getLeft();</span><br><span class="line">        HeroNode2 right = heroNode5.getRight();</span><br><span class="line">        System.out.println(&quot;heroNode5的前驱节点为：&quot; + left);</span><br><span class="line">        System.out.println(&quot;heroNode5的后继节点为：&quot; + right);</span><br><span class="line">        //测试遍历</span><br><span class="line">        binaryTree2.threadedList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//当线索化二叉树后，不能使用原来的二叉树遍历方式，因为不能用null来结束递归，用中序线索化的二叉树，就用对应的中序遍历保持一致</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实现线索化功能的二叉树</span><br><span class="line">class BinaryTree2 &#123;</span><br><span class="line">    //遍历是由二叉树根节点调用的，但是实际执行的是每个节点的方法</span><br><span class="line">    private HeroNode2 root;//创建根节点</span><br><span class="line">    //为了实现线索化，需要创建一个指向当前节点前驱节点的指针</span><br><span class="line">    //在递归进行线索化时，pre总是保留一个前驱节点</span><br><span class="line">    private HeroNode2 pre = null;</span><br><span class="line"></span><br><span class="line">    public void setRoot(HeroNode2 root) &#123;</span><br><span class="line">        this.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void threadedNodes() &#123;</span><br><span class="line">        this.threadedNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历线索二叉树的方法</span><br><span class="line">    public void threadedList() &#123;</span><br><span class="line">        //定义变量，存储当前遍历的节点</span><br><span class="line">        HeroNode2 node = root;</span><br><span class="line">        while (node != null) &#123;</span><br><span class="line">            //循环找到leftType==1的节点，第一个找到的是8这个节点，该节点是按照线索化处理后的有效节点</span><br><span class="line">            //后面随着遍历而变化</span><br><span class="line">            while (node.getLeftType() == 0) &#123;//代表有左子树</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            //打印当前节点</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            //如果当前节点的右指针指向的后继节点，就一直输出</span><br><span class="line">            while (node.getRightType() == 1) &#123;</span><br><span class="line">                //获取当前节点的后继节点</span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            //替换这个遍历的节点</span><br><span class="line">            node = node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //编写对二叉树进行中序线索化的方法,heroNode2是需要进行线索化的节点</span><br><span class="line">    public void threadedNodes(HeroNode2 heroNode2) &#123;</span><br><span class="line">        //如果是null,不能线索化</span><br><span class="line">        if (heroNode2 == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //中序线索化</span><br><span class="line">        //1：先线索化左子树</span><br><span class="line">        threadedNodes(heroNode2.getLeft());</span><br><span class="line">        //2：处理当前节点,实际上线索化的操作都是由此方法完成</span><br><span class="line">        //处理当前节点的前驱节点</span><br><span class="line">        if (heroNode2.getLeft() == null) &#123;</span><br><span class="line">            //让当前节点的左指针指向前驱节点</span><br><span class="line">            heroNode2.setLeft(pre);</span><br><span class="line">            //修改当前节点的左指针的类型,指向前驱节点</span><br><span class="line">            heroNode2.setLeftType(1);</span><br><span class="line">        &#125;</span><br><span class="line">        //处理后置节点,注意此时判断条件的顺序，否则会出现空指针异常</span><br><span class="line">        if (pre != null &amp;&amp; pre.getRight() == null) &#123;</span><br><span class="line">            //让前驱节点的右指针指向当前节点</span><br><span class="line">            pre.setRight(heroNode2);</span><br><span class="line">            //修改前驱节点的右指针类型</span><br><span class="line">            pre.setRightType(1);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = heroNode2;</span><br><span class="line">        //3：再处理线索化右子树</span><br><span class="line">        threadedNodes(heroNode2.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序查找</span><br><span class="line">    public HeroNode2 preFind(int no) &#123;</span><br><span class="line">        HeroNode2 heroNode2 = null;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            heroNode2 = this.root.preFind(no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法查找！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return heroNode2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序遍历</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            this.root.preOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            this.root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //后续遍历</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            this.root.postOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//hero2节点</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line">    private int no;</span><br><span class="line">    private String name;</span><br><span class="line">    private HeroNode2 left;</span><br><span class="line">    private HeroNode2 right;</span><br><span class="line">    //如果leftType==0，表示指向的是左子树，如果是1则表示指向的前驱节点</span><br><span class="line">    //如果rightType==0，表示指向的是右子树，如果是1则表示指向的后继节点</span><br><span class="line">    private int leftType;</span><br><span class="line">    private int rightType;</span><br><span class="line"></span><br><span class="line">    public HeroNode2(int no, String name) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getLeftType() &#123;</span><br><span class="line">        return leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeftType(int leftType) &#123;</span><br><span class="line">        this.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getRightType() &#123;</span><br><span class="line">        return rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRightType(int rightType) &#123;</span><br><span class="line">        this.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode2 getLeft() &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeft(HeroNode2 left) &#123;</span><br><span class="line">        this.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode2 getRight() &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRight(HeroNode2 right) &#123;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;no=&quot; + no +</span><br><span class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //节点的前序遍历方法</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this);//先输出父节点</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.preOrder();//递归前序遍历</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        //递归向左子树中序遍历</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        //输出父节点</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //后序遍历</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序查找</span><br><span class="line">    public HeroNode2 preFind(int no) &#123;</span><br><span class="line">        //先比较当前节点是不是</span><br><span class="line">        if (this.no == no) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode2 res = null;</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            res = this.left.preFind(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (res != null) &#123;</span><br><span class="line">            return res;//说明左子树找到</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            res = this.right.preFind(no);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四：树结构的应用一：堆排序"><a href="#四：树结构的应用一：堆排序" class="headerlink" title="四：树结构的应用一：堆排序"></a>四：树结构的应用一：堆排序</h3><p>1：堆排序介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最好，最坏，平均复杂度均为O（nlogn），它也是不稳定的排序</span><br><span class="line">2：堆是具有以下性质的完全二叉树，每个节点的值都大于或等于其左右孩子节点的值，称为大定堆；每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆。对孩子之间值的比较没要求</span><br><span class="line">3：大顶堆特点arr[i]&gt;=arr[2*i+1]&amp;&amp;arr[i]&gt;=arr[2*i+2],i对应的是第几个节点</span><br><span class="line">4：小顶堆特点arr[i]&lt;=arr[2*i+1]&amp;&amp;arr[i]&lt;=arr[2*i+2],i对应的是第几个节点</span><br><span class="line">5：一般升序采用大顶堆，降序采用小顶堆</span><br></pre></td></tr></table></figure><p>2：堆排序实现思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆排序     O(nlog2n)      O(nlog2n)      O(nlog2n)         O(1) 不稳定  较复杂</span><br><span class="line">速度测试：800万数据排序话费时间1.7s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1：将待排序序列构造成一个大顶堆，（实际是用数组实现）</span><br><span class="line">2：此时，整个序列的最大值就是堆顶的根节点</span><br><span class="line">3：将其与末尾元素进行交换，此时末尾成为最大值</span><br><span class="line">4：然后将剩余N-1个元素重新构造成一个堆，这样就会得到n个元素的次小值，如此反复执行，便能得到一个有序序列了</span><br><span class="line">5：可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到了一个有序序列了</span><br><span class="line"></span><br><span class="line">逻辑：逻辑就是非叶子节点与它的子节点之间比较，如果子节点&gt;自己；那么就交换；然后继续进行下一个非叶子节点的比较；比较完成之后可以得到最大元素（即此时的堆顶元素），</span><br><span class="line">注意：非叶子节点的顺序是从右至左，从下至上，依次进行！</span><br></pre></td></tr></table></figure><p>3：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">package com.it.tree;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">//堆排序</span><br><span class="line">public class HeapSort &#123;</span><br><span class="line">    private static int temp = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试冒泡排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[8000000];</span><br><span class="line">        for (int i = 0; i &lt; 8000000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 80000000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start =System.currentTimeMillis();</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        long end =System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot;+(end-start));</span><br><span class="line"></span><br><span class="line">//        //要求将数组升序排列，需要构建大顶堆</span><br><span class="line">//        int arr[] = &#123;0, 1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">////        //分步完成.，这里测试是手动确定i值</span><br><span class="line">////        adjustHeap(arr, 1, arr.length);</span><br><span class="line">////        System.out.println(&quot;第一次调整&quot; + Arrays.toString(arr));</span><br><span class="line">////        //第二次排序</span><br><span class="line">////        adjustHeap(arr, 0, arr.length);</span><br><span class="line">////        System.out.println(&quot;第二次调整&quot;+Arrays.toString(arr));</span><br><span class="line">//        heapSort(arr);</span><br><span class="line">//        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //编写一个堆排序的方法,这里实现从下至上，从右至左</span><br><span class="line">    public static void heapSort(int[] arr) &#123;</span><br><span class="line">        System.out.println(&quot;堆排序！&quot;);</span><br><span class="line">        //这里是确定i来从下至上，从右至左实现方法：int i = arr.length/2-1即为从左下角开始</span><br><span class="line">        for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;//上述for循环结束即实现了一个大顶堆，后面需要交换堆顶与最后一个元素的值</span><br><span class="line">        for (int j = arr.length - 1; j &gt; 0; j--) &#123;</span><br><span class="line">            temp = arr[j];//从最后元素开始</span><br><span class="line">            arr[j] = arr[0];//arr[0]为最大值</span><br><span class="line">            arr[0] = temp;</span><br><span class="line">            adjustHeap(arr, 0, j);</span><br><span class="line">            // 方法中的i = k;//i指向k，</span><br><span class="line">            // 继续循环比较，最主要的是这里，</span><br><span class="line">            // 当i=0时，这里和for循环搭配起来实现了把arr[1]和arr[2]的值替换成了第二大和第三大的值</span><br><span class="line">            //所以每次都可以直接进行替换，而不需要再去从右至左的调用方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 功能：将以i对应的非叶子节点的树调整成大顶堆</span><br><span class="line">     * 例如：当i=1时，原数组为4,6,8,5,9, 调整成4,9,8,5,6</span><br><span class="line">     * 再次调用时，i=0,原数组4,9,8,5,6,调整成了9，6,8,5,4</span><br><span class="line">     *</span><br><span class="line">     * @param arr    待调整的数组</span><br><span class="line">     * @param i      表示非叶子节点在数组中的索引</span><br><span class="line">     * @param length 表示对多少个元素进行调整，length在逐渐减少</span><br><span class="line">     */</span><br><span class="line">    //将一个数组（二叉树），调整成一个大顶堆</span><br><span class="line">    public static void adjustHeap(int arr[], int i, int length) &#123;</span><br><span class="line">        int tmp = arr[i];//先取出当前元素的值，保留在临时变量</span><br><span class="line">        //k表示当前节点的左子叶节点，继续调整就是下一个节点的左子叶节点</span><br><span class="line">        for (int k = 2 * i + 1; k &lt; length; k = 2 * k + 1) &#123;</span><br><span class="line">            if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123;//说明左子节点小于右子节点值</span><br><span class="line">                k++;//k指向右子节点</span><br><span class="line">            &#125;</span><br><span class="line">            if (arr[k] &gt; tmp) &#123;</span><br><span class="line">                arr[i] = arr[k];//把子节点中的最大值赋值给该子叶节点</span><br><span class="line">                i = k;//i指向k，继续循环比较，最主要的是这里，当i=0时，这里和for循环搭配起来实现了把arr[1]和arr[2]的值替换成了第二大和第三大的值</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;//说明当前的i值对应的子叶节点的自己点都比自己小，无序调整。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //for循环结束之后就把当前i值对应的子叶节点调整为了大顶堆，arr[i]在i为父节点时候最大，注意前提条件i从右至左，从上至下扫描</span><br><span class="line">        arr[i] = tmp;//前面已经用temp记录了arr[i]的值，相当于是交换了arr[i]与arr[k]的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五：树结构应用二：赫夫曼树"><a href="#五：树结构应用二：赫夫曼树" class="headerlink" title="五：树结构应用二：赫夫曼树"></a>五：树结构应用二：赫夫曼树</h3><p>1：赫夫曼树介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：赫夫曼树是带权路径长度最小的二叉树，用途是平均查找信息的代价最小。</span><br><span class="line">2：普通二叉树的用途也普通，比较通用，就是信息存储和查找。</span><br><span class="line">3：普通二叉树可能有的只有一个子节点，而哈夫曼树一定有两个。</span><br><span class="line">4：树的带权路径长度规定为所有叶子节点的带权路径长度之和，记为wpl。权值越大的节点离根节点越近的二叉树才是最优二叉树（赫夫曼树）。</span><br><span class="line">5：wpl最小的构建二叉树的方式即为赫夫曼树，注意权值在叶子节点上！</span><br></pre></td></tr></table></figure><p>2：构成赫夫曼树的步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">哈夫曼树的构造：</span><br><span class="line">假设给定的权值如下：3,5,7,8,10,15；</span><br><span class="line">首先取集合中最小的两个数：3+5=8，再删除集合中3和5的值，把8放入原集合,</span><br><span class="line">原集合变成:7,8,8,10,15；</span><br><span class="line"> 8</span><br><span class="line">/ \</span><br><span class="line">3 5</span><br><span class="line">继续取出最小2个数7 8 ，构成15，然后把7 8 删除，依次进行...所有数都使用完毕之后就变成了赫夫曼树。</span><br><span class="line"></span><br><span class="line">原理：最小两个数相累加的过程实际上就是两个子叶节点相加得到它们父节点的过程。所以说赫夫曼树的子节点一定有两个！</span><br></pre></td></tr></table></figure><p> 3：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package com.it.huffmantree;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class HuffmanTree &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;13, 7, 8, 3, 29, 6, 1&#125;;</span><br><span class="line">        Node huffmanTree = createHuffmanTree(arr);</span><br><span class="line">        //前序遍历赫夫曼树</span><br><span class="line">        System.out.println(&quot;前序遍历赫夫曼树&quot;);</span><br><span class="line">        prOrder(huffmanTree);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //编写一个前序遍历的方法</span><br><span class="line">    public static void prOrder(Node root) &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;空树，无法遍历！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param arr 需要创建的赫夫曼树的数组、、</span><br><span class="line">     * @return 返回的是赫夫曼树的root节点</span><br><span class="line">     */</span><br><span class="line">    //创建赫夫曼树的方法</span><br><span class="line">    public static Node createHuffmanTree(int[] arr) &#123;</span><br><span class="line">        //为了操作方便，需要先把arr元素放在Node中，然后实现从小到大排序</span><br><span class="line">        List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;();</span><br><span class="line">        for (int value : arr) &#123;</span><br><span class="line">            nodes.add(new Node(value));</span><br><span class="line">        &#125;//for循环完成之后就实现了所有value放在了Node中</span><br><span class="line"></span><br><span class="line">        while (nodes.size() &gt; 1) &#123;//退出循环条件为nodes中只有一个元素</span><br><span class="line">            Collections.sort(nodes);//实现了排序，前提是Node实现了Comparable接口</span><br><span class="line">            //开始构建赫夫曼树</span><br><span class="line">            //1:取出权值最小的节点（二叉树）</span><br><span class="line">            Node leftNode = nodes.get(0);</span><br><span class="line">            //2：取出权值第二小的节点（二叉树）</span><br><span class="line">            Node rightNode = nodes.get(1);</span><br><span class="line">            //3:构建父节点，形成二叉树</span><br><span class="line">            Node parent = new Node(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            //4：从arr中删除leftNode与rightNode；同时使parent加入</span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">            //测试排序</span><br><span class="line">            System.out.println(&quot;nodes&quot; + nodes);</span><br><span class="line">        &#125;</span><br><span class="line">        //每一次循环就完成了一个二叉树的构建，并且删除了两个子节点，增加了一个父节点</span><br><span class="line">        //返回赫夫曼树的头</span><br><span class="line">        return nodes.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建节点类,为了让Node对象支持value排序，实现comparable接口</span><br><span class="line">class Node implements Comparable&lt;Node&gt; &#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node left;//指向左子节点</span><br><span class="line">    Node right;//指向右子节点</span><br><span class="line"></span><br><span class="line">    //写一个前序遍历</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Node(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node&#123;&quot; +</span><br><span class="line">                &quot;value=&quot; + value +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Node o) &#123;</span><br><span class="line">        return this.value - o.value;//从小到大排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六：算法-赫夫曼编码"><a href="#六：算法-赫夫曼编码" class="headerlink" title="六：算法-赫夫曼编码"></a>六：算法-赫夫曼编码</h3><p>1：赫夫曼编码概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1:哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，哈夫曼编码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就叫做Huffman编码（有时也称为霍夫曼编码）</span><br><span class="line">2:压缩率通常在20%-90%之间</span><br></pre></td></tr></table></figure><p>2：赫夫曼编码实现分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1：传输的字符串 i like like like java do you like a java </span><br><span class="line">2：d 1; y 1;u 1;j 2;v 2;o 2;l 4;k 4;e 4;i 5;a 5;  9;各个字符对应的个数，包括最后是空格出现次数</span><br><span class="line">3：按照上面字符出现的次数构建一颗赫夫曼树，次数作为权值</span><br><span class="line">4：根据赫夫曼树，给各个字符，规定编码（前缀编码），向左的路径为0，向右的路径为1；即每个字符都得到了自己的编码，从根节点到字符的节点</span><br><span class="line">5：前缀编码：没有任何一个字符的编码是另一个字符的前缀；因为叶子节点不可能在另一个叶子节点下。</span><br><span class="line">6：按照上述的每个字符的编码，确定字符串对应的编码</span><br><span class="line"></span><br><span class="line">注意：当有多个权值一样时，赫夫曼树可能会出现多种情况，对应的字符编码也就不一样，但是不影响最终的wpl值</span><br></pre></td></tr></table></figure><p>3：代码实现字符串的压缩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">功能：根据赫夫曼编码数据的原理，需要创建i like like like java do you like a java对应的赫夫曼树</span><br><span class="line">思路：</span><br><span class="line">1：Node&#123;data(储存数据) weigth(权值)，left rigth&#125;</span><br><span class="line">2：得到i like like like java do you like a java对应的字节数组</span><br><span class="line">3：编写一个方法，将准备构建赫夫曼树的Node节点放在List中,[Node&#123;data=97,weight=5&#125;,Node&#123;data=32.weigth=9&#125;...]；体现d 1; y 1;u 1;j 2;v 2;o 2;l 4;k 4;e 4;i 5;a 5;  9</span><br><span class="line">4：通过List构建对应的赫夫曼树</span><br><span class="line">5：遍历赫夫曼树得到对应字符的赫夫曼编码</span><br><span class="line">6：传入字符串，得到字符串对应使用赫夫曼编码编码的数据</span><br><span class="line"></span><br><span class="line">核心代码步骤：</span><br><span class="line">//根据字节数组中字符出现的次数，封装到node中，形成nodes集合</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        //根据nodes创建赫夫曼树</span><br><span class="line">        Node huffmanTree = createHuffmanTree(nodes);</span><br><span class="line">        //根据赫夫曼树创建对应的赫夫曼编码</span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTree);</span><br><span class="line">        //根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span><br><span class="line">        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line">        return huffmanCodeBytes;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">package com.it.huffmancode;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class HuffmanCode &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//i like like like java do you like a java</span><br><span class="line">        String content = &quot;i like like like java do you like a java&quot;;</span><br><span class="line">        byte[] contentBytes = content.getBytes();</span><br><span class="line">     /* 分步：</span><br><span class="line">         System.out.println(Arrays.toString(contentBytes));</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(contentBytes);</span><br><span class="line">        System.out.println(nodes);</span><br><span class="line">        Node huffmanTree = createHuffmanTree(nodes);//huffmanTree为赫夫曼树的根节点</span><br><span class="line">        //遍历</span><br><span class="line">        System.out.println(&quot;前序遍历&quot;);</span><br><span class="line">        prOrder(huffmanTree);</span><br><span class="line">        //测试是否生成对应的赫夫曼编码</span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTree);</span><br><span class="line">        System.out.println(&quot;生成的哈夫曼编码表&quot; + huffmanCodes);</span><br><span class="line">        //测试</span><br><span class="line">        byte[] huffmanCodeBytes = zip(contentBytes, huffmanCodes);</span><br><span class="line">        //huffmanCodeBytes=[-44, -33, -12, -33, -12, -33, -12, -18, -21, -109, 118, 121, 77, -1, 106, 119, 14],已经到达了压缩</span><br><span class="line">        System.out.println(&quot;huffmanCodeBytes=&quot; + Arrays.toString(huffmanCodeBytes));*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //整体测试</span><br><span class="line">        byte[] huffmanCodeBytes = huffmanZip(contentBytes);</span><br><span class="line">        System.out.println(&quot;压缩后的结果是：&quot;+Arrays.toString(huffmanCodeBytes));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param bytes 原始字符串对应的字节数组（contents）</span><br><span class="line">     * @return 经过赫夫曼编码处理后的字节数组（压缩后的数组）</span><br><span class="line">     */</span><br><span class="line">    //使用一个方法，把前面的方法都封装起来，便于调用</span><br><span class="line">    private static byte[] huffmanZip(byte[] bytes) &#123;</span><br><span class="line">        //根据字节数组中字符出现的次数，封装到node中，形成nodes集合</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        //根据nodes创建赫夫曼树</span><br><span class="line">        Node huffmanTree = createHuffmanTree(nodes);</span><br><span class="line">        //根据赫夫曼树创建对应的赫夫曼编码</span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTree);</span><br><span class="line">        //根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span><br><span class="line">        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line">        return huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param bytes        这是原始的字符串对应的byte[]</span><br><span class="line">     * @param huffmanCodes 生成的赫夫曼编码map</span><br><span class="line">     * @return 返回赫夫曼编码处理后的byte[]</span><br><span class="line">     * 举例：传入的String content = &quot;i like like like java do you like a java&quot;;</span><br><span class="line">     * 返回的是字符串&quot;10101000...&quot;对应的byte[] huffmanCodeBytes,即8位对应的一个byte，放入到huffmanCodeBytes中</span><br><span class="line">     * huffmanCodeBytes[0]=10101000（补码）=&gt;byte[推倒10101000-1=&gt;10100111（反码）=&gt;11011000（原码）]</span><br><span class="line">     * 即huffmanCodeBytes[0]=&gt;  -88</span><br><span class="line">     */</span><br><span class="line">    //编写一个方法，传入字符串，得到对应通过赫夫曼编码编码之后的01数据</span><br><span class="line">    private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        for (byte b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));//这里就是得到了字符串&quot;10101000...&quot;，不管哪种方式编码都是133位</span><br><span class="line">        &#125;</span><br><span class="line">        //将字符串&quot;10101000...&quot;转换为byte[]，才能传输</span><br><span class="line">        //统计返回byte[]huffmanCodes长度</span><br><span class="line">        int len;</span><br><span class="line">        if (stringBuilder.length() % 8 == 0) &#123;</span><br><span class="line">            len = stringBuilder.length() / 8;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            len = stringBuilder.length() / 8 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个存储压缩后的byte[]</span><br><span class="line">        byte[] huffmanCodeBytes = new byte[len];</span><br><span class="line">        int index = 0;//记录是第几个byte</span><br><span class="line">        //遍历</span><br><span class="line">        for (int i = 0; i &lt; stringBuilder.length(); i += 8) &#123;//因为每8位对应一个byte,所以步长为8</span><br><span class="line">            String strByte;</span><br><span class="line">            if (i + 8 &gt; stringBuilder.length()) &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + 8);</span><br><span class="line">            &#125;</span><br><span class="line">            //将strByte转成byte，放入huffmanCodeBytes</span><br><span class="line">            huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte, 2);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        //循环结束之后得到赫夫曼得到的字节数组</span><br><span class="line">        return huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //生成赫夫曼树对应的赫夫曼编码</span><br><span class="line">    //思路：</span><br><span class="line">    //1：遍历赫夫曼树，得到路径，形成byte→01这种形式,需要Map集合储存</span><br><span class="line">    //2：路径需要拼接，定义StringBuilder储存叶子节点的路径</span><br><span class="line">    static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;Byte, String&gt;();</span><br><span class="line">    static StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line"></span><br><span class="line">    //重载getCodes()</span><br><span class="line">    private static Map&lt;Byte, String&gt; getCodes(Node root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(root, &quot;0&quot;, stringBuilder);</span><br><span class="line">        getCodes(root, &quot;1&quot;, stringBuilder);</span><br><span class="line">        return huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将传入的node节点所有的赫夫曼编码得到，并放入到集合huffmanCodes</span><br><span class="line">     *</span><br><span class="line">     * @param node          传入节点</span><br><span class="line">     * @param code          代表路径，左代表0，右代表1</span><br><span class="line">     * @param stringBuilder 拼接路径的字符串</span><br><span class="line">     */</span><br><span class="line">    private static void getCodes(Node node, String code, StringBuilder stringBuilder) &#123;</span><br><span class="line">        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);</span><br><span class="line">        //将code加入到stringBuilder2中</span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        if (node != null) &#123;//node==null不处理</span><br><span class="line">            //判断当前node是叶子节点还是非叶子节点</span><br><span class="line">            if (node.data == null) &#123;//说明是非叶子节点</span><br><span class="line">                //递归处理</span><br><span class="line">                //向左递归</span><br><span class="line">                getCodes(node.left, &quot;0&quot;, stringBuilder2);</span><br><span class="line">                //向右递归</span><br><span class="line">                getCodes(node.right, &quot;1&quot;, stringBuilder2);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //说明是叶子节点，表示已经找到</span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序遍历</span><br><span class="line">    private static void prOrder(Node root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            System.out.println(&quot;无节点，无法遍历&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param bytes 接收字节数组</span><br><span class="line">     * @return 返回的是Nodes</span><br><span class="line">     */</span><br><span class="line">    private static List&lt;Node&gt; getNodes(byte[] bytes) &#123;</span><br><span class="line">        //1:创建一个ArrayList</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;();</span><br><span class="line">        //遍历bytes，存储每个byte出现的次数，使用map</span><br><span class="line">        //byte对应的是字符，Integer对应的字符出现的次数</span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = new HashMap&lt;&gt;();</span><br><span class="line">        //循环遍历bytes</span><br><span class="line">        for (Byte b : bytes) &#123;</span><br><span class="line">            Integer count = counts.get(b);//通过key获取对应的Integer</span><br><span class="line">            if (count == null) &#123;//说明map中还没key为b的这个字符</span><br><span class="line">                counts.put(b, 1);//把b放入，记为1次</span><br><span class="line">            &#125; else &#123;//说明map中已经有b</span><br><span class="line">                counts.put(b, count + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//循环结束之后就得到了Map，为每个字符对应的次数的键值对</span><br><span class="line">        //遍历Map,把每个键值对转换为Node对象,并加入nodes</span><br><span class="line">        for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(new Node(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        return nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param nodes 传入的Node集合</span><br><span class="line">     * @return 返回的赫夫曼树的root节点</span><br><span class="line">     */</span><br><span class="line">    //通过list创建赫夫曼树</span><br><span class="line">    private static Node createHuffmanTree(List&lt;Node&gt; nodes) &#123;</span><br><span class="line">        while (nodes.size() &gt; 1) &#123;</span><br><span class="line">            Collections.sort(nodes);//从小到大</span><br><span class="line">            //取出第一颗最小二叉树</span><br><span class="line">            Node leftNode = nodes.get(0);</span><br><span class="line">            //取出第二颗最小二叉树</span><br><span class="line">            Node rightNode = nodes.get(1);</span><br><span class="line">            //创建一颗新的二叉树,根节点没有data,只有权值</span><br><span class="line">            Node parent = new Node(null, leftNode.weight + rightNode.weight);</span><br><span class="line">            //挂起</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            //移除已经处理的两个二叉树</span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            //将新的二叉树加入到nodes</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回的就是最后的节点，即赫夫曼树的根节点</span><br><span class="line">        return nodes.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建Node，存数据合权值</span><br><span class="line">class Node implements Comparable&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;//存放数据本身，比如&apos;a&apos;→97  &apos; &apos;→32</span><br><span class="line">    int weight;//权值，为字符出现的次数</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    public Node(Byte data, int weight) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Node o) &#123;</span><br><span class="line">        return this.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node&#123;&quot; +</span><br><span class="line">                &quot;data=&quot; + data +</span><br><span class="line">                &quot;, weight=&quot; + weight +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序遍历</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七：算法：赫夫曼解压"><a href="#七：算法：赫夫曼解压" class="headerlink" title="七：算法：赫夫曼解压"></a>七：算法：赫夫曼解压</h3><p>1：赫夫曼解码步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目标：完成用赫夫曼编码过后的字节数组解压成字符串</span><br><span class="line">1：压缩后的结果是：[-44, -33, -12, -33, -12, -33, -12, -18, -21, -109, 118, 121, 77, -1, 106, 119, 14]→转换为赫夫曼编码对应的二进制字符串&quot;10101000...&quot;</span><br><span class="line">2:字符串&quot;10101000...&quot;对照赫夫曼编码=&gt;重新转换为String content = &quot;i like like like java do you like a java&quot;;</span><br><span class="line">3：实际就是压缩的逆向过程</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：树&quot;&gt;&lt;a href=&quot;#1：树&quot; class=&quot;headerlink&quot; title=&quot;1：树&quot;&gt;&lt;/a&gt;1：树&lt;/h1&gt;&lt;h3 id=&quot;一：普通二叉树&quot;&gt;&lt;a href=&quot;#一：普通二叉树&quot; class=&quot;headerlink&quot; title=&quot;一：普通二叉树
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（6）哈希表</title>
    <link href="https://yanyubing.xyz/2018/06/26/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://yanyubing.xyz/2018/06/26/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2018-06-26T13:46:12.000Z</published>
    <updated>2019-12-06T01:21:31.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：哈希表"><a href="#1：哈希表" class="headerlink" title="1：哈希表"></a>1：哈希表</h1><p>1：哈希表概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</span><br><span class="line"></span><br><span class="line">给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1：使用哈希表实现对员工信息的增删改查，注意下列代码没有实现删除功能，因为创建的链表是没有头节点的，不适合删除节点信息</span><br><span class="line">2：class Emp 表示员工</span><br><span class="line">3：class HashTabDemo 主类</span><br><span class="line">4：class EmpLinkedList 表示链表</span><br><span class="line">5：哈希表管理多条链表，聊表之间散列</span><br><span class="line">6：直接使用链表查找慢，使用哈希表可以提高查找效率</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">package com.it.hashTable;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class HashTabDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建哈希表</span><br><span class="line">        HashTable hashTable = new HashTable(7);//7条链表</span><br><span class="line">        //菜单</span><br><span class="line">        String key = &quot;&quot;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;-------------&quot;);</span><br><span class="line">            System.out.println(&quot;add：添加雇员&quot;);</span><br><span class="line">            System.out.println(&quot;list：显示雇员&quot;);</span><br><span class="line">            System.out.println(&quot;find：查找雇员&quot;);</span><br><span class="line">            System.out.println(&quot;exit：退出系统&quot;);</span><br><span class="line"></span><br><span class="line">            key = scanner.next();</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &quot;add&quot;:</span><br><span class="line">                    System.out.println(&quot;输入id&quot;);</span><br><span class="line">                    int id = scanner.nextInt();</span><br><span class="line">                    System.out.println(&quot;输入名字&quot;);</span><br><span class="line">                    String name = scanner.next();</span><br><span class="line">                    //创建雇员</span><br><span class="line">                    Emp emp = new Emp(id, name);</span><br><span class="line">                    hashTable.add(emp);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;list&quot;:</span><br><span class="line">                    hashTable.list();</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;find&quot;:</span><br><span class="line">                    System.out.println(&quot;请输入要查找的id&quot;);</span><br><span class="line">                    id = scanner.nextInt();</span><br><span class="line">                    hashTable.findEmpById(id);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;exit&quot;:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(0);</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建哈希表，管理多条链表</span><br><span class="line">class HashTable &#123;</span><br><span class="line">    //size是链表的条数</span><br><span class="line">    private int size;</span><br><span class="line">    private EmpLinkedList[] empLinkedListArray;</span><br><span class="line">    //构造器</span><br><span class="line"></span><br><span class="line">    public HashTable(int size) &#123;//链表的条数</span><br><span class="line">        this.size = size;</span><br><span class="line">        empLinkedListArray = new EmpLinkedList[size];</span><br><span class="line">        //链表需要指向头指针,分别初始化每一条链表</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i] = new EmpLinkedList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //添加雇员</span><br><span class="line">    public void add(Emp emp) &#123;</span><br><span class="line">        //根据员工的id，得到员工应当添加到哪条链表</span><br><span class="line">        int empLinkedListNO = hashFun(emp.id);</span><br><span class="line">        //将emp添加到对应的链表中</span><br><span class="line">        empLinkedListArray[empLinkedListNO].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历所有链表，遍历哈希表</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i].list(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据输入的id查找雇员</span><br><span class="line">    public void findEmpById(int id) &#123;</span><br><span class="line">        //使用散列函数确定在哪条链表查找</span><br><span class="line">        int empLinkedListNO = hashFun(id);</span><br><span class="line">        Emp emp = empLinkedListArray[empLinkedListNO].findEmpByiId(id);</span><br><span class="line">        if (emp != null) &#123;</span><br><span class="line">            //找到</span><br><span class="line">            System.out.printf(&quot;在第%d条链表找到雇员id=%d\t&quot;, (empLinkedListNO + 1), id);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;在哈希表中没有找到雇员&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //编写散列函数，使用简单的取模法</span><br><span class="line">    public int hashFun(int id) &#123;</span><br><span class="line">        return id % size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//表示一个员工</span><br><span class="line">class Emp &#123;</span><br><span class="line">    public int id;</span><br><span class="line">    public String name;</span><br><span class="line">    public Emp next;//next默认为null，下一个节点</span><br><span class="line"></span><br><span class="line">    public Emp(int id, String name) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//表示一个链表</span><br><span class="line">class EmpLinkedList &#123;</span><br><span class="line">    //头指针，执行第一个Emp，直接指向第一个Emp</span><br><span class="line">    private Emp head;</span><br><span class="line"></span><br><span class="line">    //添加雇员到链表哦</span><br><span class="line">    //1：假定当添加雇员时，id是自增长的，id的分配总是从下到大的</span><br><span class="line">    //2：因此直接将雇员加载到本链表的最后即可</span><br><span class="line">    public void add(Emp emp) &#123;</span><br><span class="line">        //如果是添加第一个雇员</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            head = emp;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果不是第一个雇员</span><br><span class="line">        Emp curEmp = head;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (curEmp.next == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curEmp.next = emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历链表雇员信息</span><br><span class="line">    public void list(int no) &#123;//no是打印当前条数</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            System.out.println(&quot;第&quot; + (no + 1) + &quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;第&quot; + (no + 1) + &quot;链表的信息为&quot;);</span><br><span class="line">        Emp curEmp = head;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.printf(&quot;=&gt;id =%d name=%s\t&quot;, curEmp.id, curEmp.name);</span><br><span class="line">            if (curEmp.next == null) &#123;//说明已经到了最后</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;//后移</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据id查找雇员</span><br><span class="line">    //如果查找到，就返回emp,如果没找到，就返回null，这里的查找方法是对应的每一条自己的链表，后面hashtable调用的饿时候可以提前判断在哪一条链表中</span><br><span class="line">    public Emp findEmpByiId(int id) &#123;</span><br><span class="line">        //判断链表是否为空</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //辅助指针</span><br><span class="line">        Emp curEmp = head;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (curEmp.id == id) &#123;//说明找到</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //退出</span><br><span class="line">            if (curEmp.next == null) &#123;</span><br><span class="line">                curEmp = null;</span><br><span class="line">                break;</span><br><span class="line">                //说明链表已经遍历完</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;//后移</span><br><span class="line">        &#125;</span><br><span class="line">        return curEmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：哈希表&quot;&gt;&lt;a href=&quot;#1：哈希表&quot; class=&quot;headerlink&quot; title=&quot;1：哈希表&quot;&gt;&lt;/a&gt;1：哈希表&lt;/h1&gt;&lt;p&gt;1：哈希表概述&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法(4)排序算法</title>
    <link href="https://yanyubing.xyz/2018/06/15/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(4)%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://yanyubing.xyz/2018/06/15/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(4)%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2018-06-15T13:46:12.000Z</published>
    <updated>2019-12-06T01:20:59.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：排序"><a href="#一：排序" class="headerlink" title="一：排序"></a>一：排序</h1><h3 id="1：排序的分类"><a href="#1：排序的分类" class="headerlink" title="1：排序的分类"></a>1：排序的分类</h3><p>1：内部排序（使用内存）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：插入排序：直接插入排序，希尔排序</span><br><span class="line">2：选择排序：简单选择排序，堆排序</span><br><span class="line">3：交换排序：冒泡排序，快速排序</span><br><span class="line">4：归并排序</span><br><span class="line">5：基数排序</span><br></pre></td></tr></table></figure><p>2：外部排序：数据量过大的情况</p><h3 id="2：算法的时间复杂度"><a href="#2：算法的时间复杂度" class="headerlink" title="2：算法的时间复杂度"></a>2：算法的时间复杂度</h3><p>1：事后统计法：比较依赖机器性能</p><p>2：事前估算的方法：分析</p><p>3：时间频度：一个算法话费的时间与算法中语句执行次数成正比，哪个算法中语句执行次数多，它花费的时间就多</p><p>4：时间频度简化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：忽略常数项</span><br><span class="line">2：忽略低次项</span><br></pre></td></tr></table></figure><p>5：时间复杂度(又叫渐进时间复杂度)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：忽略低阶项</span><br><span class="line">2：取出最高阶系数</span><br><span class="line">3：只有常数阶O(1)</span><br></pre></td></tr></table></figure><p>6：常见的时间复杂度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1：常数阶O(1)</span><br><span class="line">2：对数阶O(log2n)</span><br><span class="line">3：线性阶O(n)</span><br><span class="line">4：线性对数阶O(nlog2n)</span><br><span class="line">5：平方阶O(n^2)</span><br><span class="line">6：立方阶O(n^3)</span><br><span class="line">7：k次方阶O(n^k)</span><br><span class="line">8：指数阶O(2^n)</span><br><span class="line">时间复杂度从上到下依次变劣！</span><br></pre></td></tr></table></figure><p>7：对数阶</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">  while (i &lt; n) &#123;</span><br><span class="line">   i = i * 2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>8：平均时间复杂度和最坏时间复杂度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间</span><br><span class="line">2：一般讨论的时间复杂度是最坏时间复杂度</span><br><span class="line">3：平均时间复杂度和最坏时间复杂度是否一致，和算法有关</span><br></pre></td></tr></table></figure><p>9：常见排序算法的时间复杂度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">排序方法时间复杂度（平均）时间复杂度（最坏)时间复杂度（最好)空间复杂度稳定性 复杂性</span><br><span class="line">直接插入排序  O(n2)O(n2)O(n)   O(1)稳定 简单</span><br><span class="line">希尔排序   O(nlog2n) O(n2) O(n)O(1)不稳定 较复杂</span><br><span class="line">直接选择排序  O(n2)    O(n2)O(n2)   O(1)   不稳定简单</span><br><span class="line">堆排序     O(nlog2n)      O(nlog2n)      O(nlog2n)         O(1) 不稳定  较复杂</span><br><span class="line">冒泡排序   O(n2) O(n2) O(n)O(1) 稳定  简单</span><br><span class="line">快速排序   O(nlog2n) O(n2) O(nlog2n)  O(nlog2n) 不稳定 较复杂</span><br><span class="line">归并排序   O(nlog2n)     O(nlog2n)     O(nlog2n)        O(n) 稳定  较复杂</span><br><span class="line">基数排序   O(d(n+r))    O(d(n+r))     O(d(n+r))      O(n+r)   稳定  较复杂</span><br></pre></td></tr></table></figure><h3 id="三：冒泡排序"><a href="#三：冒泡排序" class="headerlink" title="三：冒泡排序"></a>三：冒泡排序</h3><p>1：冒泡排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过对待排序序列从前向后，下标较小的元素开始，依次比较相邻元素的值；若发现逆序则交换，使值较大的元素逐渐向前移动到后部，就像水滴的气泡一样逐渐向上冒。</span><br><span class="line">第一次遍历完成就实现了最后一个元素是最大值，</span><br><span class="line">第二次遍历完成就实现了最后一个元素是倒数第二大值，</span><br><span class="line">...</span><br><span class="line">最多进行数组长度-1次遍历完成</span><br><span class="line">优化：在某趟排序中，没有发生一次排序，则可以提前完成排序。</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序   O(n2) O(n2) O(n)O(1) 稳定  简单</span><br><span class="line">优化之后：80000数据最终花费时间约10s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //      int arr[] = &#123;3, 9, -1, 10, 20&#125;;</span><br><span class="line">        //    bubbleSort(arr);</span><br><span class="line">        //测试冒泡排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[80000];</span><br><span class="line">        for (int i = 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 8000000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start =System.currentTimeMillis();</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        long end =System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot;+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //排序方式</span><br><span class="line">    public static void bubbleSort(int[] arr) &#123;</span><br><span class="line">        boolean flag = false;//优化：定义标志位，判断是否交换过</span><br><span class="line">        int tmp = 0;//临时变量，用于交换</span><br><span class="line">        for (int j = 0; j &lt; arr.length - 1; j++) &#123;</span><br><span class="line">            //一次内层循环完成最后一个数的确定</span><br><span class="line">            for (int i = 0; i &lt; arr.length - j - 1; i++) &#123;</span><br><span class="line">                //满足交换条件</span><br><span class="line">                if (arr[i] &gt; arr[i + 1]) &#123;</span><br><span class="line">                    tmp = arr[i + 1];</span><br><span class="line">                    arr[i + 1] = arr[i];</span><br><span class="line">                    arr[i] = tmp;</span><br><span class="line">                    flag = true;//交换之后就置为true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //一次循环结束，flag如果还是false，证明上次循环未交换，则证明已经有序，提前退出</span><br><span class="line">            if (!flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //重置flag，否则flag变为true之后无法起到再次验证的效果</span><br><span class="line">                flag = false;</span><br><span class="line">            &#125;</span><br><span class="line">//            System.out.printf(&quot;第%d趟排序之后\n&quot;, (j + 1));</span><br><span class="line">//            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">//        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四：选择排序"><a href="#四：选择排序" class="headerlink" title="四：选择排序"></a>四：选择排序</h3><p>1：选择排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：第一次遍历(从arr[0]-arr[n-1])完成之后找到最小值，然后与arr[0]交换</span><br><span class="line">2：第二次遍历(从arr[1]-arr[n-1])完成之后找到这里面的最小值，然后与arr[1]交换</span><br><span class="line">...</span><br><span class="line">3：经过n-1次遍历，最终完成排序</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接选择排序  O(n2)    O(n2)O(n2)   O(1)   不稳定简单</span><br><span class="line">时间花费：80000数据最终花费时间约2s，</span><br><span class="line">时间较冒泡排序短：循环语句少，交换次数少</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class SelectSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        int[] arr = &#123;101, 34, 119, 1&#125;;</span><br><span class="line">//        selectSort(arr);</span><br><span class="line">//        System.out.println(Arrays.toString(arr));</span><br><span class="line">        //测试冒泡排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[80000];</span><br><span class="line">        for (int i = 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 8000000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        selectSort(arr);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //选择排序</span><br><span class="line">    public static void selectSort(int[] arr) &#123;</span><br><span class="line">        //逐步推到</span><br><span class="line">        //原始数组 101，34，119，1</span><br><span class="line">        //第一轮 1，34，119，101</span><br><span class="line">        int min = arr[0];</span><br><span class="line">        int minIndex = 0;</span><br><span class="line">        int temp = 0;//用于交换</span><br><span class="line">        for (int j = 0; j &lt; arr.length; j++) &#123;//外层循环表示第几轮循环</span><br><span class="line">            minIndex = j;//最小值的索引置为j，因为每次内层循环从J开始</span><br><span class="line">            min = arr[j];//最小值置为arr[j]，因为每次内层循环从J开始</span><br><span class="line">            for (int i = j + 1; i &lt; arr.length; i++) &#123;//内层表示当前轮循环的遍历</span><br><span class="line">                if (arr[i] &lt;= min) &#123;//满足条件</span><br><span class="line">                    min = arr[i];//</span><br><span class="line">                    minIndex = i;//记录最小值的索引</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //一次循环之后找到了最小值的所有minIndex,arr[0]交换</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五：插入排序一：直接插入排序"><a href="#五：插入排序一：直接插入排序" class="headerlink" title="五：插入排序一：直接插入排序"></a>五：插入排序一：直接插入排序</h3><p>1：插入排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1：把n个待排序的元素看成一张有序表和一张无序表</span><br><span class="line">2：开始有序表中只包含一个元素，即arr[0]</span><br><span class="line">3:无序表中包含n-1个元素</span><br><span class="line">4：排序过程中，每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序码进行比较，将它插入到有序表的适当位置，使之成为新的有序表</span><br><span class="line">5：具体的比较过程</span><br><span class="line">例如：arr[3]为无序表的第一个元素，则将arr[3]与arr[2]进行比较，如果arr[2]&gt;arr[3]则将arr[2]后移一位；再将arr[3]与arr[1]比较，如果arr[3]&gt;arr[1]，则将arr[3]放在arr[2]的位置</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接插入排序  O(n2)O(n2)O(n)   O(1)稳定 简单</span><br><span class="line">时间花费：80000数据最终花费时间约1s，</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class InsertSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;   //测试冒泡排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[80000];</span><br><span class="line">        for (int i = 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 8000000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start =System.currentTimeMillis();</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        long end =System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot;+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入排序</span><br><span class="line">    public static void insertSort(int[] arr) &#123;</span><br><span class="line">        //逐步推导</span><br><span class="line">        //第一轮&#123;101，34，119，1&#125;=&gt;&#123;34,101,119,1&#125;</span><br><span class="line">        //定义待插入数</span><br><span class="line">        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            //每次待插入的元素往后移</span><br><span class="line">            int insertVal = arr[i];</span><br><span class="line">            //需要一个变量记录待插入的元素，不能使用arr[i]来记录，因为值可能会改变</span><br><span class="line">            //每次循环就把待插入的元素索引n与前n个元素从后往前比较</span><br><span class="line">            for (int j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">                if (insertVal &lt;= arr[j]) &#123;</span><br><span class="line">                    //将arr[j]后移</span><br><span class="line">                    arr[j + 1] = arr[j];</span><br><span class="line">                    if (j == 0) &#123;</span><br><span class="line">                        arr[j] = insertVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (insertVal &gt; arr[j]) &#123;</span><br><span class="line">                    //代表可以插入！直接将insertVal放在arr[j]的后面，注意此时需要结束当前内层循环</span><br><span class="line">                    arr[j + 1] = insertVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六：插入排序二：希尔排序"><a href="#六：插入排序二：希尔排序" class="headerlink" title="六：插入排序二：希尔排序"></a>六：插入排序二：希尔排序</h3><p>1：希尔排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：设待排序元素序列有n个元素，首先取一个整数increment（n/2取整）作为间隔将全部元素分为increment个子序列，所有距离为increment的元素放在同一个子序列中，在每一个子序列中分别实行直接插入排序。然后缩小间隔increment（上述的然后缩小间隔increment/2），重复上述子序列划分和排序工作。直到最后取increment=1，将所有元素放在同一个子序列中排序为止。</span><br><span class="line">2：由于开始时，increment的取值较大，每个子序列中的元素较少，排序速度较快，到排序后期increment取值逐渐变小，子序列中元素个数逐渐增多，但由于前面工作的基础，大多数元素已经基本有序，所以排序速度仍然很快。</span><br><span class="line">3：困难点是：步长x与循环轮数k之间的关系并且和arr.length的关系，以及每次插入排序尽头的判断</span><br><span class="line">4：希尔排序的关键在于提前通过步长把N组数据已经变成有序了，最后当步长=1的时候才是最终的方式，也就是插入排序！</span><br><span class="line">5：可以把希尔排序方式理解成一种化繁为简的思想，具体内部用哪种排序方式自己定（例如冒泡：交换，或者插入）</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">希尔排序   O(nlog2n) O(n2) O(n)O(1)不稳定 较复杂</span><br><span class="line">测试80000条数据花费60ms左右</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import sun.rmi.runtime.Log;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class ShellSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        int[] arr = &#123;6, 2314, 314, 234134, 3145132, 8, 9, 1, 7, 2, 1273, 4, 5&#125;;</span><br><span class="line">//        System.out.println(&quot;原始数据是：&quot; + Arrays.toString(arr));</span><br><span class="line">//        shellSort(arr);</span><br><span class="line">//        System.out.println(Arrays.toString(arr));</span><br><span class="line">        //测试希尔排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[80000];</span><br><span class="line">        for (int i = 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 800000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot; + (end - start));</span><br><span class="line">//        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用逐步推导</span><br><span class="line">    public static void shellSort(int[] arr) &#123;</span><br><span class="line">        //希尔排序的第一轮排序</span><br><span class="line">        //因为第一轮排序，是将10个数据分成了5组</span><br><span class="line">        //三层，第一层表示一共要进行多少轮的分组  9个数，</span><br><span class="line">        // 则第一轮分组为 1，5，9   2，6   3，7   4，8</span><br><span class="line">        //k为插入排序的轮数，</span><br><span class="line">        int kMax = (int) (Math.log(arr.length)/Math.log(2));//表示需要进行插入排序的轮数</span><br><span class="line">        //每轮的步长为1- arr.length/2   2-arr.length/2/2  3-arr.length/2/2/2</span><br><span class="line">        System.out.println(&quot;插入排序的轮数：&quot;+kMax);</span><br><span class="line">        for (int k = 1; k &lt;= kMax; k++) &#123;</span><br><span class="line">            int x = (int) (arr.length / Math.pow(2, k));//步长</span><br><span class="line">            System.out.printf(&quot;第%d轮的步长:%d\n&quot;,k,x);</span><br><span class="line">                for (int i = x; i &lt; arr.length; i++) &#123;//从步长x开始</span><br><span class="line">                    //每次待插入的元素往后移</span><br><span class="line">                    int insertVal = arr[i];</span><br><span class="line">                    //需要一个变量记录待插入的元素，不能使用arr[i]来记录，因为值可能会改变</span><br><span class="line">                    //每次循环就把待插入的元素索引n与前n/x个元素从后往前比较</span><br><span class="line">                    for (int j = i - x; j &gt;= i % x; j -= x) &#123;</span><br><span class="line">                        //每次只与前面步长差为x的比较，注意此时的左边尽头是i对步长取模</span><br><span class="line">                        if (insertVal &lt;= arr[j]) &#123;</span><br><span class="line">                            //将arr[j]后移</span><br><span class="line">                            arr[j + x] = arr[j];</span><br><span class="line">                            if (j == i % x) &#123;//判断已经到头了</span><br><span class="line">                                arr[j] = insertVal;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (insertVal &gt; arr[j]) &#123;</span><br><span class="line">//代表可以插入！直接将insertVal放在arr[j]的后面，注意此时需要结束当前内层循环</span><br><span class="line">                            arr[j + x] = insertVal;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">//                System.out.printf(&quot;第%d轮的步长是%d：&quot;, k, x);</span><br><span class="line">//                System.out.printf(&quot;第%d轮的排序是：&quot;, k);</span><br><span class="line">//                System.out.println(Arrays.toString(arr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="七：快速排序"><a href="#七：快速排序" class="headerlink" title="七：快速排序"></a>七：快速排序</h3><p>1：快速排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：通过一趟排序将要排序的数据分割成独立的两部分，基准值M=arr[(indexStart+indexEnd)/2]自己确定，其中一部分的所有数据都比另外一部分的所有数据小</span><br><span class="line">2：然后再按照此方法对这两部分数据分别进行快速排序</span><br><span class="line">3：整个排序过程可以递归进行，以此达到整个数据变成有序序列，递归的尽头是每个部分中只有一个元素</span><br><span class="line">4：具体的交换过程是一个方法（），左边索引indexStart向右移动，右边所有indexEnd向左移动；当arr[indexStart]&gt;M(基准值)&amp;&amp;arr[indexEnd]&lt;M时，进行交换；这样左边的所有元素就小于了基准值，右边的所有元素大于基准值,方法的参参数是数组，左索引值，右索引值</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class QuickSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//int[] arr = &#123;-9,78,0,23,-567,70, -1,900, 4561&#125;;</span><br><span class="line"></span><br><span class="line">//测试快排的执行速度</span><br><span class="line">// 创建要给80000个的随机的数组</span><br><span class="line">int[] arr = new int[8000000];</span><br><span class="line">for (int i = 0; i &lt; 8000000; i++) &#123;</span><br><span class="line">arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;排序前&quot;);</span><br><span class="line">Date data1 = new Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(&quot;排序前的时间是=&quot; + date1Str);</span><br><span class="line"></span><br><span class="line">quickSort(arr, 0, arr.length-1);</span><br><span class="line"></span><br><span class="line">Date data2 = new Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(&quot;排序前的时间是=&quot; + date2Str);</span><br><span class="line">//System.out.println(&quot;arr=&quot; + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void quickSort(int[] arr,int left, int right) &#123;</span><br><span class="line">int l = left; //左下标</span><br><span class="line">int r = right; //右下标</span><br><span class="line">//pivot 中轴值</span><br><span class="line">int pivot = arr[(left + right) / 2];</span><br><span class="line">int temp = 0; //临时变量，作为交换时使用</span><br><span class="line">//while循环的目的是让比pivot 值小放到左边</span><br><span class="line">//比pivot 值大放到右边</span><br><span class="line">while( l &lt; r) &#123;</span><br><span class="line">//在pivot的左边一直找,找到大于等于pivot值,才退出</span><br><span class="line">while( arr[l] &lt; pivot) &#123;</span><br><span class="line">l += 1;</span><br><span class="line">&#125;</span><br><span class="line">//在pivot的右边一直找,找到小于等于pivot值,才退出</span><br><span class="line">while(arr[r] &gt; pivot) &#123;</span><br><span class="line">r -= 1;</span><br><span class="line">&#125;</span><br><span class="line">//如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是</span><br><span class="line">//小于等于pivot值，右边全部是大于等于pivot值</span><br><span class="line">if( l &gt;= r) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//交换</span><br><span class="line">temp = arr[l];</span><br><span class="line">arr[l] = arr[r];</span><br><span class="line">arr[r] = temp;</span><br><span class="line"></span><br><span class="line">//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移</span><br><span class="line">if(arr[l] == pivot) &#123;</span><br><span class="line">r -= 1;</span><br><span class="line">&#125;</span><br><span class="line">//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移</span><br><span class="line">if(arr[r] == pivot) &#123;</span><br><span class="line">l += 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span><br><span class="line">if (l == r) &#123;</span><br><span class="line">l += 1;</span><br><span class="line">r -= 1;</span><br><span class="line">&#125;</span><br><span class="line">//向左递归</span><br><span class="line">if(left &lt; r) &#123;</span><br><span class="line">quickSort(arr, left, r);</span><br><span class="line">&#125;</span><br><span class="line">//向右递归</span><br><span class="line">if(right &gt; l) &#123;</span><br><span class="line">quickSort(arr, l, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八：基数排序：桶排序"><a href="#八：基数排序：桶排序" class="headerlink" title="八：基数排序：桶排序"></a>八：基数排序：桶排序</h3><p>1：基数排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基数排序第i趟将待排数组里的每个数的i位数放到tempj（j=1-10）队列中，然后再从这十个队列中取出数据，重新放到原数组里，直到i大于待排数的最大位数。</span><br><span class="line">1.数组里的数最大位数是n位，就需要排n趟，例如数组里最大的数是3位数，则需要排3趟。</span><br><span class="line">2.若数组里共有m个数，则需要十个长度为m的数组tempj（j=0-9）用来暂存i位上数为j的数，例如，第1趟，各位数为0的会被分配到temp0数组里，各位数为1的会被分配到temp1数组里......</span><br><span class="line">3.分配结束后，再依次从tempj数组中取出数据，遵循先进先进原则，例如对数组&#123;1，11，2，44，4&#125;，进行第1趟分配后，temp1=&#123;1,11&#125;，temp2=&#123;2&#125;，temp4=&#123;44，4&#125;，依次取出元素后&#123;1，11，2，44，4&#125;，第一趟结束</span><br><span class="line">4.循环到n趟后结束，排序完成</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基数排序   O(d(n+r))    O(d(n+r))     O(d(n+r))      O(n+r)   稳定  较复杂</span><br><span class="line">80000数据耗时：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class RadixSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] = &#123; 53, 3, 542, 748, 14, 214&#125;;</span><br><span class="line"></span><br><span class="line">        // 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G </span><br><span class="line">//int[] arr = new int[8000000];</span><br><span class="line">//for (int i = 0; i &lt; 8000000; i++) &#123;</span><br><span class="line">//arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span><br><span class="line">//&#125;</span><br><span class="line">        System.out.println(&quot;排序前&quot;);</span><br><span class="line">        Date data1 = new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">        System.out.println(&quot;排序前的时间是=&quot; + date1Str);</span><br><span class="line"></span><br><span class="line">        radixSort(arr);</span><br><span class="line"></span><br><span class="line">        Date data2 = new Date();</span><br><span class="line">        String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">        System.out.println(&quot;排序前的时间是=&quot; + date2Str);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;基数排序后 &quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //基数排序方法</span><br><span class="line">    public static void radixSort(int[] arr) &#123;</span><br><span class="line"></span><br><span class="line">        //根据前面的推导过程，我们可以得到最终的基数排序代码</span><br><span class="line"></span><br><span class="line">        //1. 得到数组中最大的数的位数</span><br><span class="line">        int max = arr[0]; //假设第一数就是最大数</span><br><span class="line">        for(int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //得到最大数是几位数</span><br><span class="line">        int maxLength = (max + &quot;&quot;).length();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span><br><span class="line">        //说明</span><br><span class="line">        //1. 二维数组包含10个一维数组</span><br><span class="line">        //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span><br><span class="line">        //3. 名明确，基数排序是使用空间换时间的经典算法</span><br><span class="line">        int[][] bucket = new int[10][arr.length];</span><br><span class="line"></span><br><span class="line">        //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span><br><span class="line">        //可以这里理解</span><br><span class="line">        //比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span><br><span class="line">        int[] bucketElementCounts = new int[10];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //这里我们使用循环将代码处理</span><br><span class="line"></span><br><span class="line">        for(int i = 0 , n = 1; i &lt; maxLength; i++, n *= 10) &#123;</span><br><span class="line">            //(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span><br><span class="line">            for(int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">                //取出每个元素的对应位的值</span><br><span class="line">                int digitOfElement = arr[j] / n % 10;</span><br><span class="line">                //放入到对应的桶中</span><br><span class="line">                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">                bucketElementCounts[digitOfElement]++;</span><br><span class="line">            &#125;</span><br><span class="line">            //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">            int index = 0;</span><br><span class="line">            //遍历每一桶，并将桶中是数据，放入到原数组</span><br><span class="line">            for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">                //如果桶中，有数据，我们才放入到原数组</span><br><span class="line">                if(bucketElementCounts[k] != 0) &#123;</span><br><span class="line">                    //循环该桶即第k个桶(即第k个一维数组), 放入</span><br><span class="line">                    for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                        //取出元素放入到arr</span><br><span class="line">                        arr[index++] = bucket[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span><br><span class="line">                bucketElementCounts[k] = 0;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            //System.out.println(&quot;第&quot;+(i+1)+&quot;轮，对个位的排序处理 arr =&quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">//第1轮(针对每个元素的个位进行排序处理)</span><br><span class="line">for(int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">//取出每个元素的个位的值</span><br><span class="line">int digitOfElement = arr[j] / 1 % 10;</span><br><span class="line">//放入到对应的桶中</span><br><span class="line">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">bucketElementCounts[digitOfElement]++;</span><br><span class="line">&#125;</span><br><span class="line">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">int index = 0;</span><br><span class="line">//遍历每一桶，并将桶中是数据，放入到原数组</span><br><span class="line">for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">//如果桶中，有数据，我们才放入到原数组</span><br><span class="line">if(bucketElementCounts[k] != 0) &#123;</span><br><span class="line">//循环该桶即第k个桶(即第k个一维数组), 放入</span><br><span class="line">for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">//取出元素放入到arr</span><br><span class="line">arr[index++] = bucket[k][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//第l轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span><br><span class="line">bucketElementCounts[k] = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;第1轮，对个位的排序处理 arr =&quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//==========================================</span><br><span class="line"></span><br><span class="line">//第2轮(针对每个元素的十位进行排序处理)</span><br><span class="line">for (int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">// 取出每个元素的十位的值</span><br><span class="line">int digitOfElement = arr[j] / 10  % 10; //748 / 10 =&gt; 74 % 10 =&gt; 4</span><br><span class="line">// 放入到对应的桶中</span><br><span class="line">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">bucketElementCounts[digitOfElement]++;</span><br><span class="line">&#125;</span><br><span class="line">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">index = 0;</span><br><span class="line">// 遍历每一桶，并将桶中是数据，放入到原数组</span><br><span class="line">for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">// 如果桶中，有数据，我们才放入到原数组</span><br><span class="line">if (bucketElementCounts[k] != 0) &#123;</span><br><span class="line">// 循环该桶即第k个桶(即第k个一维数组), 放入</span><br><span class="line">for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">// 取出元素放入到arr</span><br><span class="line">arr[index++] = bucket[k][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//第2轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span><br><span class="line">bucketElementCounts[k] = 0;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;第2轮，对个位的排序处理 arr =&quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第3轮(针对每个元素的百位进行排序处理)</span><br><span class="line">for (int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">// 取出每个元素的百位的值</span><br><span class="line">int digitOfElement = arr[j] / 100 % 10; // 748 / 100 =&gt; 7 % 10 = 7</span><br><span class="line">// 放入到对应的桶中</span><br><span class="line">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">bucketElementCounts[digitOfElement]++;</span><br><span class="line">&#125;</span><br><span class="line">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">index = 0;</span><br><span class="line">// 遍历每一桶，并将桶中是数据，放入到原数组</span><br><span class="line">for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">// 如果桶中，有数据，我们才放入到原数组</span><br><span class="line">if (bucketElementCounts[k] != 0) &#123;</span><br><span class="line">// 循环该桶即第k个桶(即第k个一维数组), 放入</span><br><span class="line">for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">// 取出元素放入到arr</span><br><span class="line">arr[index++] = bucket[k][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//第3轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span><br><span class="line">bucketElementCounts[k] = 0;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;第3轮，对个位的排序处理 arr =&quot; + Arrays.toString(arr)); */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九：归并排序"><a href="#九：归并排序" class="headerlink" title="九：归并排序"></a>九：归并排序</h3><p>1：归并排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2</span><br><span class="line">求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1</span><br><span class="line">合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class MergetSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //int arr[] = &#123; 8, 4, 5, 7, 1, 3, 6, 2 &#125;; //</span><br><span class="line"></span><br><span class="line">        //测试快排的执行速度</span><br><span class="line">        // 创建要给80000个的随机的数组</span><br><span class="line">        int[] arr = new int[8000000];</span><br><span class="line">        for (int i = 0; i &lt; 8000000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;排序前&quot;);</span><br><span class="line">        Date data1 = new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">        System.out.println(&quot;排序前的时间是=&quot; + date1Str);</span><br><span class="line"></span><br><span class="line">        int temp[] = new int[arr.length]; //归并排序需要一个额外空间</span><br><span class="line">        mergeSort(arr, 0, arr.length - 1, temp);</span><br><span class="line"></span><br><span class="line">        Date data2 = new Date();</span><br><span class="line">        String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">        System.out.println(&quot;排序前的时间是=&quot; + date2Str);</span><br><span class="line"></span><br><span class="line">        //System.out.println(&quot;归并排序后=&quot; + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //分+合方法</span><br><span class="line">    public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123;</span><br><span class="line">        if(left &lt; right) &#123;</span><br><span class="line">            int mid = (left + right) / 2; //中间索引</span><br><span class="line">            //向左递归进行分解</span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            //向右递归进行分解</span><br><span class="line">            mergeSort(arr, mid + 1, right, temp);</span><br><span class="line">            //合并</span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //合并的方法</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param arr 排序的原始数组</span><br><span class="line">     * @param left 左边有序序列的初始索引</span><br><span class="line">     * @param mid 中间索引</span><br><span class="line">     * @param right 右边索引</span><br><span class="line">     * @param temp 做中转的数组</span><br><span class="line">     */</span><br><span class="line">    public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123;</span><br><span class="line"></span><br><span class="line">        int i = left; // 初始化i, 左边有序序列的初始索引</span><br><span class="line">        int j = mid + 1; //初始化j, 右边有序序列的初始索引</span><br><span class="line">        int t = 0; // 指向temp数组的当前索引</span><br><span class="line"></span><br><span class="line">        //(一)</span><br><span class="line">        //先把左右两边(有序)的数据按照规则填充到temp数组</span><br><span class="line">        //直到左右两边的有序序列，有一边处理完毕为止</span><br><span class="line">        while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;//继续</span><br><span class="line">            //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span><br><span class="line">            //即将左边的当前元素，填充到 temp数组</span><br><span class="line">            //然后 t++, i++</span><br><span class="line">            if(arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t += 1;</span><br><span class="line">                i += 1;</span><br><span class="line">            &#125; else &#123; //反之,将右边有序序列的当前元素，填充到temp数组</span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t += 1;</span><br><span class="line">                j += 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //(二)</span><br><span class="line">        //把有剩余数据的一边的数据依次全部填充到temp</span><br><span class="line">        while( i &lt;= mid) &#123; //左边的有序序列还有剩余的元素，就全部填充到temp</span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += 1;</span><br><span class="line">            i += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while( j &lt;= right) &#123; //右边的有序序列还有剩余的元素，就全部填充到temp</span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += 1;</span><br><span class="line">            j += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //(三)</span><br><span class="line">        //将temp数组的元素拷贝到arr</span><br><span class="line">        //注意，并不是每次都拷贝所有</span><br><span class="line">        t = 0;</span><br><span class="line">        int tempLeft = left; //</span><br><span class="line">        //第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3</span><br><span class="line">        //最后一次 tempLeft = 0  right = 7</span><br><span class="line">        while(tempLeft &lt;= right) &#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            t += 1;</span><br><span class="line">            tempLeft += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：排序&quot;&gt;&lt;a href=&quot;#一：排序&quot; class=&quot;headerlink&quot; title=&quot;一：排序&quot;&gt;&lt;/a&gt;一：排序&lt;/h1&gt;&lt;h3 id=&quot;1：排序的分类&quot;&gt;&lt;a href=&quot;#1：排序的分类&quot; class=&quot;headerlink&quot; title=&quot;1：排
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（3）递归</title>
    <link href="https://yanyubing.xyz/2018/06/05/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E9%80%92%E5%BD%92/"/>
    <id>https://yanyubing.xyz/2018/06/05/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E9%80%92%E5%BD%92/</id>
    <published>2018-06-05T13:46:12.000Z</published>
    <updated>2019-12-06T01:20:43.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：递归"><a href="#一：递归" class="headerlink" title="一：递归"></a>一：递归</h1><h3 id="1：递归介绍"><a href="#1：递归介绍" class="headerlink" title="1：递归介绍"></a>1：递归介绍</h3><p>1：递归的应用场景，迷宫问题（回溯），递归</p><p>2：概念，递归就是自己调用自己，每次传入一个不一样的参数</p><p>3：递归可以解决的问题：8皇后，汉若塔，阶乘问题，迷宫问题，球和篮子</p><p>4：各种算法，快排，归并，二分查找，分治算法等</p><p>5：将用栈解决的问题使用递归解决</p><p>6：递归使用遵守规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：执行一个方法时，就春季了一个新的受保护的独立空间（栈空间）</span><br><span class="line">2：方法的局部变量是独立的，不会相互影响</span><br><span class="line">3：如果方法中使用的是引用类型的变量，例如迷宫问题是的数组，就会共享该类型的数据</span><br><span class="line">4：递归必须向退出递归的条件逼近，否则就是无线递归，栈溢出stackOverflowError</span><br><span class="line">5：当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用就把结果返回给谁；同时当方法执行完毕或者返回时，该方法也就执行完毕</span><br></pre></td></tr></table></figure><h3 id="2：递归-迷宫问题"><a href="#2：递归-迷宫问题" class="headerlink" title="2：递归-迷宫问题"></a>2：递归-迷宫问题</h3><p>1：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">package com.it.rescursion;</span><br><span class="line"></span><br><span class="line">public class MiGong &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //二维数组创建一个迷宫</span><br><span class="line">        int[][] map = new int[8][7];</span><br><span class="line">        //使用1表示墙</span><br><span class="line">        // 上下全置为1</span><br><span class="line">        for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">            map[0][i] = 1;</span><br><span class="line">            map[7][i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        //左右置为1</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            map[i][0] = 1;</span><br><span class="line">            map[i][6] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        //设置相应挡板，1</span><br><span class="line">        map[3][1] = 1;</span><br><span class="line">        map[3][2] = 1;</span><br><span class="line">        //输出地图</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 7; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;迷宫问题&quot;);</span><br><span class="line">        //使用递归回溯给小球找路</span><br><span class="line">        setWay(map, 1, 1);</span><br><span class="line">        //使用新的地图，小球走过，并表示过得地图</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 7; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*说明：</span><br><span class="line">        map表示地图，i，j 表示从地图哪个位置开始出发（1,1）</span><br><span class="line">     *如果小球能到map[6][5]位置，则说明通路找到</span><br><span class="line">     约定：当map[i][j]为</span><br><span class="line">     0表示没有走过</span><br><span class="line">     1表示墙，</span><br><span class="line">     2表示通路，可以走</span><br><span class="line">     3表示该位置已经走过，但是走不通。</span><br><span class="line">     在走迷宫时先确定一个策略（方法）下→右→上→左；如果该路走不通则回溯</span><br><span class="line">     * */</span><br><span class="line">    //使用递归回溯来给小球找路</span><br><span class="line">    public static boolean setWay(int[][] map, int i, int j) &#123;</span><br><span class="line">        if (map[6][5] == 2) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (map[i][j] == 0) &#123;</span><br><span class="line">                //按照策略开始走   下→右→上→左</span><br><span class="line">                map[i][j] = 2;//假定可以走通</span><br><span class="line">                if (setWay(map, i + 1, j)) &#123;//向下走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (setWay(map, i, j + 1)) &#123;//向右走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (setWay(map, i - 1, j)) &#123;//向上走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (setWay(map, i, j - 1)) &#123;//向左走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //都走不通，说明是死路</span><br><span class="line">                    map[i][j] = 3;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果map[i][j]!=0;可能是1,2,3</span><br><span class="line">            else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3：递归-八皇后问题"><a href="#3：递归-八皇后问题" class="headerlink" title="3：递归-八皇后问题"></a>3：递归-八皇后问题</h3><p>1：思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：第一个皇后放在第一行第一列</span><br><span class="line">2：第二个皇后放在第二行第一列，然后判断是否ok,如果不Ok,继续放在第二列、第三列...依次把所有列放完，找到一个合适的</span><br><span class="line">3：继续第三个皇后，还是第一列，第二列...直到第8个皇后也能放在一个不冲突的位置，算是找到一个正确解</span><br><span class="line">4：当得到一个正确时，在栈回退到上一个栈，就会开始回溯，即将第一个皇后放在第一列的所有正确解全部都得到</span><br><span class="line">5：然后回头继续第一个皇后放在第二列，后面继续执行1,2,3,4的步骤</span><br><span class="line">说明：理论上需要二维数组，但是实际上可以用一位数组的索引（index+1）表示第几行</span><br><span class="line">6：合计92种</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package com.it.rescursion;</span><br><span class="line"></span><br><span class="line">public class Queue8 &#123;</span><br><span class="line">    //先定义一个max表示共有多少个皇后</span><br><span class="line">    int max = 8;</span><br><span class="line">    //定义一个数组，保存皇后防止位置的结果，比如arr=&#123;0,4,7,5,2,6,1,3&#125;</span><br><span class="line">    int array[] = new int[max];</span><br><span class="line">    static int count = 0;</span><br><span class="line">    static int judgeCount = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试</span><br><span class="line">        Queue8 queue8 = new Queue8();</span><br><span class="line">        queue8.check(0);</span><br><span class="line">        System.out.printf(&quot;一共有%d解法&quot;, count);</span><br><span class="line">        System.out.printf(&quot;一共判断冲突的次数%d次&quot;, judgeCount); // 1.5w</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //编写一个方法，放置第n个皇后</span><br><span class="line">    private void check(int n) &#123;</span><br><span class="line">        //n=8代表已经放完了8个皇后</span><br><span class="line">        if (n == max) &#123;</span><br><span class="line">            print();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //依次测试第n个皇后的放入，并判断是否冲突</span><br><span class="line">        for (int i = 0; i &lt; max; i++) &#123;</span><br><span class="line">            //i=0时，表示放置在第一列，i=1表示放置在第二列...</span><br><span class="line">            array[n] = i;</span><br><span class="line">            //判断当放置第N个皇后到i列时是否冲突；</span><br><span class="line">            if (judge(n)) &#123;</span><br><span class="line">                //接着放n+1个皇后</span><br><span class="line">                check(n + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            //如果冲突，则继续执行循环，放置在i+1列</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查看当我们放置第N个皇后时，就去检查该皇后是否和前面已经放置的皇后冲突</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param n 表示第N个皇后</span><br><span class="line">     */</span><br><span class="line">    private boolean judge(int n) &#123;</span><br><span class="line">        judgeCount++;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            //array[i] == array[n]这里表示是不是在同一列</span><br><span class="line">            // Math.abs(n - 1) == Math.abs(array[n] - array[i])表示第n个皇后是不是和第i个皇后在45°线上</span><br><span class="line">            if (array[i] == array[n] || Math.abs(n -i ) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //写一个方法可以将皇后摆放的位置输出</span><br><span class="line">        private void print () &#123;</span><br><span class="line">            count++;</span><br><span class="line">            for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">                System.out.print(array[i] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：递归&quot;&gt;&lt;a href=&quot;#一：递归&quot; class=&quot;headerlink&quot; title=&quot;一：递归&quot;&gt;&lt;/a&gt;一：递归&lt;/h1&gt;&lt;h3 id=&quot;1：递归介绍&quot;&gt;&lt;a href=&quot;#1：递归介绍&quot; class=&quot;headerlink&quot; title=&quot;1：递归介
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法(2)栈</title>
    <link href="https://yanyubing.xyz/2018/06/02/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(2)%E6%A0%88/"/>
    <id>https://yanyubing.xyz/2018/06/02/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(2)%E6%A0%88/</id>
    <published>2018-06-02T12:46:12.000Z</published>
    <updated>2019-12-01T15:07:43.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：栈"><a href="#一：栈" class="headerlink" title="一：栈"></a>一：栈</h1><h3 id="1：栈的应用场景"><a href="#1：栈的应用场景" class="headerlink" title="1：栈的应用场景"></a>1：栈的应用场景</h3><p>1：子程序的调用</p><p>2：处理递归调用</p><p>3：表达式的转换</p><p>4：二叉树的遍历</p><p>5：图形的深度优先搜索法</p><h3 id="2：用数组模拟栈，代码实现出栈与入栈思路"><a href="#2：用数组模拟栈，代码实现出栈与入栈思路" class="headerlink" title="2：用数组模拟栈，代码实现出栈与入栈思路"></a>2：用数组模拟栈，代码实现出栈与入栈思路</h3><p>1：需要栈的大小</p><p>2：需要定义栈顶top,初始化为-1</p><p>3：入栈，当有数据加入栈pop()，top++，加入数据</p><p>4：出栈，当有数据取出时push()，top–，取出数据</p><p>5：注意：出栈之后数组的元素并没有改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">package com.it.stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayStackDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试ArrayStack</span><br><span class="line">        ArrayStack stack = new ArrayStack(4);</span><br><span class="line">        String key = &quot;&quot;;//控制输入字符</span><br><span class="line">        boolean loop = true;//控制退出菜单</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            System.out.println(&quot;----------------&quot;);</span><br><span class="line">            System.out.println(&quot;show:表示显示栈&quot;);</span><br><span class="line">            System.out.println(&quot;exit:退出程序&quot;);</span><br><span class="line">            System.out.println(&quot;push:表示添加数据到栈&quot;);</span><br><span class="line">            System.out.println(&quot;pop:表示从栈取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;请输入你的选择&quot;);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &quot;show&quot;:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;push&quot;:</span><br><span class="line">                    System.out.println(&quot;请输入要加入的数&quot;);</span><br><span class="line">                    int value = scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;pop&quot;:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int pop = stack.pop();</span><br><span class="line">                        System.out.printf(&quot;出栈的数据是%d\n&quot;, pop);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;exit&quot;:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个类表示栈结构</span><br><span class="line">class ArrayStack &#123;</span><br><span class="line">    private int mazSize;//栈的最大大小</span><br><span class="line">    private int[] stack;//数组模拟战，数据放在该数组中</span><br><span class="line">    private int top = -1;//初始化栈顶为-1</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public ArrayStack(int mazSize) &#123;</span><br><span class="line">        this.mazSize = mazSize;</span><br><span class="line">        //初始化数组</span><br><span class="line">        stack = new int[this.mazSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈空</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return top == mazSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return top == -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public void push(int value) &#123;</span><br><span class="line">        //先判断是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;栈满&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;栈空，没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历栈,需要从栈顶开始显示数据</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;栈空，没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = top; i &gt;= 0; i--) &#123;</span><br><span class="line">            System.out.printf(&quot;stack[%d]=%d\n&quot;, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3：栈实现综合计算器：中缀表达式"><a href="#3：栈实现综合计算器：中缀表达式" class="headerlink" title="3：栈实现综合计算器：中缀表达式"></a>3：栈实现综合计算器：中缀表达式</h3><p>1：创建一个数栈numStack，存放数</p><p>2：创建一个符号栈operStack，存放运算符</p><p>3：通过index值（索引），遍历我们的表达式</p><p>4：如果我们发现的是一个数字，就直接放入数栈</p><p>5：如果扫描的是一个符号</p><p>​    1：如果发现目前的符号栈为空，就直接入栈</p><p>​    2：如果符号栈有操作符，就进行比较。如果当前的操作符优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数再从符号栈中pop出一个符号，进行运算，将得到的结构再入数栈，然后再把当前符号入符号栈；如果当前的操作符优先级大于栈中的操作符，就直接入符号栈。</p><p>6：当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并进行运算，最后在数栈中只有一个数字，就是表达式的结果</p><p>7：注意：栈的判断条件，如操作符栈最多只能有两个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">package com.it.stack;</span><br><span class="line"></span><br><span class="line">import javax.jws.soap.SOAPMessageHandlers;</span><br><span class="line"></span><br><span class="line">public class Calculator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //表达式</span><br><span class="line">        String expression = &quot;5+9+297-1&quot;;</span><br><span class="line">        //创建两个栈,这里大小设置为10，实际上应该只能用到2-3左右</span><br><span class="line">        ArrayStack2 numStack = new ArrayStack2(10);</span><br><span class="line">        ArrayStack2 operStack = new ArrayStack2(10);</span><br><span class="line">        //定义相关变量</span><br><span class="line">        int index = 0;//用于扫描</span><br><span class="line">        int num1 = 0;</span><br><span class="line">        int num2 = 0;</span><br><span class="line">        int oper = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        char ch = &apos; &apos;;//将每次扫描的char保存到ch</span><br><span class="line">        String keepNum = &quot;&quot;;//用于拼接多位数</span><br><span class="line">        //        开始while循环扫描expression</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //依次得到expression的每一个字符</span><br><span class="line">            ch = expression.substring(index, index + 1).charAt(0);</span><br><span class="line">            //判断ch，不同处理</span><br><span class="line">            //如果是符号</span><br><span class="line">            if (operStack.isOper(ch)) &#123;</span><br><span class="line">                if (!operStack.isEmpty()) &#123;</span><br><span class="line">                    //满足该条件时运算</span><br><span class="line">                    if (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        res = numStack.cal(num1, num2, oper);</span><br><span class="line">                        //把运算结果入数栈</span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        //然后将当前的操作符入符号栈</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //如果为空，直接入符号栈</span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果是数，则直接入栈，注意此时传入的是字符‘1’；需要对照ascii表转换为数字1， -48</span><br><span class="line">            //注意这里有问题，不能处理多位数</span><br><span class="line">            //需要进行拼接</span><br><span class="line">            else &#123;</span><br><span class="line">                //处理多位数</span><br><span class="line">                keepNum += ch;</span><br><span class="line">                //如果ch已经是expression最后一位，直接入栈</span><br><span class="line">                if (index == expression.length() - 1) &#123;</span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                &#125; else &#123;//判断下一个字符是不是数字，如果是数字，则继续扫描，如果是字符，则入栈</span><br><span class="line">                    if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) &#123;</span><br><span class="line">                        //如果后一位是操作符，则入栈，keepNum=&quot;123&quot;，转为数字</span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        //重要，情况keepNum</span><br><span class="line">                        keepNum = &quot;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //让index+1，并判断是否扫描到expression最后</span><br><span class="line">            index++;</span><br><span class="line">            if (index == expression.length()) &#123;</span><br><span class="line">                //扫描结束</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //开始计算后面的情况</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //如果符号栈为空，则计算到最后的结果，数栈中只有一个数字【结果】</span><br><span class="line">            if (operStack.isEmpty()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            res = numStack.cal(num1, num2, oper);</span><br><span class="line">            //把运算结果入数栈</span><br><span class="line">            numStack.push(res);</span><br><span class="line">        &#125;</span><br><span class="line">        //将最后的数，pop出就是结果</span><br><span class="line">        int res2 = numStack.pop();</span><br><span class="line">        System.out.printf(&quot;表达式%s=%d&quot;, expression, res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个类表示栈结构</span><br><span class="line">class ArrayStack2 &#123;</span><br><span class="line">    private int mazSize;//栈的最大大小</span><br><span class="line">    private int[] stack;//数组模拟战，数据放在该数组中</span><br><span class="line">    private int top = -1;//初始化栈顶为-1</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public ArrayStack2(int mazSize) &#123;</span><br><span class="line">        this.mazSize = mazSize;</span><br><span class="line">        //初始化数组</span><br><span class="line">        stack = new int[this.mazSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈空</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return top == mazSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return top == -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public void push(int value) &#123;</span><br><span class="line">        //先判断是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;栈满&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;栈空，没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历栈,需要从栈顶开始显示数据</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;栈空，没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = top; i &gt;= 0; i--) &#123;</span><br><span class="line">            System.out.printf(&quot;stack[%d]=%d\n&quot;, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回运算符的优先级，优先级使用数字表示，数字越大则优先级越高</span><br><span class="line">    public int priority(int oper) &#123;</span><br><span class="line">        if (oper == &apos;*&apos; || oper == &apos;/&apos;) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (oper == &apos;+&apos; || oper == &apos;-&apos;) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1;//假定目前的表达式只有+，-，*，/</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是不是一个运算符</span><br><span class="line">    public boolean isOper(char val) &#123;</span><br><span class="line">        return val == &apos;+&apos; || val == &apos;-&apos; || val == &apos;*&apos; || val == &apos;/&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算方法</span><br><span class="line">    public int cal(int num1, int num2, int oper) &#123;</span><br><span class="line">        int res = 0;//用于存放计算的结果</span><br><span class="line">        switch (oper) &#123;</span><br><span class="line">            case &apos;+&apos;:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                break;</span><br><span class="line">            case &apos;-&apos;:</span><br><span class="line">                res = num2 - num1;//注意顺序</span><br><span class="line">                break;</span><br><span class="line">            case &apos;*&apos;:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                break;</span><br><span class="line">            case &apos;/&apos;:</span><br><span class="line">                res = num2 / num1;//注意顺序</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //增加返回栈顶值的方法</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        return stack[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4：波兰表达式：前缀表达式"><a href="#4：波兰表达式：前缀表达式" class="headerlink" title="4：波兰表达式：前缀表达式"></a>4：波兰表达式：前缀表达式</h3><p>1：举例：     - * + 3 4 5 8</p><p>2：计算步骤，从右至左扫描，将8 5 4 3 压入栈</p><p>3：遇到+运算符，因此弹出3 和 4 进行运算，计算出3+4的值7，然后入栈</p><p>4：遇到*运算符，弹出7和5 计算得出得出7X5=35，将35入栈</p><p>5：最后-运算符，计算出35-8的值，即27，由此得到最终结果</p><h3 id="5：逆波兰表达式：后缀表达式"><a href="#5：逆波兰表达式：后缀表达式" class="headerlink" title="5：逆波兰表达式：后缀表达式"></a>5：逆波兰表达式：后缀表达式</h3><p>1：举例：    3 4 + 5 * 6 -</p><p>2：计算步骤，从左至右扫描，将3和4压入栈</p><p>3：遇到+运算符，因此弹出4和3 ，计算出3+4的值，得7，将7入栈</p><p>5：将5入栈</p><p>6：接下来是X运算符，因此弹出5和7，计算出7*5=35，将35入栈</p><p>7：将6入栈</p><p>8：弹出6（栈顶）和35（栈顶下一个元素），计算35-6，即29</p><p>9：逆波兰表达式计算器的代码实现</p><p>​    1：需要输入一个逆波兰表达式</p><p>​    2：使用系统提供的栈(stack)</p><p>​    3：支持小括号和多位整数</p><p>​    4：思路如上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.it.stack;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class PolandNotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //定义一个逆波兰表达式</span><br><span class="line">        //(3+4)*5-6 =&gt; 3 4 + 5 * 6 -</span><br><span class="line">        //为了方便，逆波兰表达式的数字和符号用空格隔开</span><br><span class="line">        String suffixExpression = &quot;30 4 + 5 * 6 -&quot;;</span><br><span class="line">        //思路</span><br><span class="line">        //1：先将&quot;3 4 + 5 * 6 -&quot;放入ArrayList中，这里是为了方便根据索引扫描</span><br><span class="line">        //2：将ArrayList传递给一个方法，遍历ArrayList，配合栈，完成计算</span><br><span class="line">        List&lt;String&gt; list = getListString(suffixExpression);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        int res = calculate(list);</span><br><span class="line">        System.out.println(&quot;计算的结果是=&quot; + res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;String&gt; getListString(String suffixExpression) &#123;</span><br><span class="line">        String[] split = suffixExpression.split(&quot; &quot;);</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        for (String s : split) &#123;</span><br><span class="line">            //遍历添加元素到集合</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //运算</span><br><span class="line">    public static int calculate(List&lt;String&gt; ls) &#123;</span><br><span class="line">        //创建栈</span><br><span class="line">        Stack&lt;String&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (String item : ls) &#123;</span><br><span class="line">            //使用正则表达式取出数,匹配的是多位数</span><br><span class="line">            if (item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">                //入栈</span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int pop2 = Integer.parseInt(stack.pop());</span><br><span class="line">                int pop1 = Integer.parseInt(stack.pop());</span><br><span class="line">                int res = 0;</span><br><span class="line">                if (item.equals(&quot;+&quot;)) &#123;</span><br><span class="line">                    res = pop1 + pop2;</span><br><span class="line">                &#125; else if (item.equals(&quot;-&quot;)) &#123;</span><br><span class="line">                    res = pop1 - pop2;//先弹出的是pop2</span><br><span class="line">                &#125; else if (item.equals(&quot;*&quot;)) &#123;</span><br><span class="line">                    res = pop1 * pop2;</span><br><span class="line">                &#125; else if (item.equals(&quot;/&quot;)) &#123;</span><br><span class="line">                    res = pop1 / pop2;//先弹出的是pop2</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;运算符有误！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(&quot;&quot; + res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最后留在栈中的就是运算结果</span><br><span class="line">        return Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六：中缀表达式转换为后缀表达式"><a href="#六：中缀表达式转换为后缀表达式" class="headerlink" title="六：中缀表达式转换为后缀表达式"></a>六：中缀表达式转换为后缀表达式</h3><p>1：中缀表达式适合人的理解</p><p>2：后缀表达式适合计算机的运行</p><p>3：思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.初始化两个栈：运算符栈s1和储存中间结果的栈s2；</span><br><span class="line">2.从左至右扫描中缀表达式；</span><br><span class="line">3.遇到操作数时，将其压s2；</span><br><span class="line">4.遇到运算符时，比较其与s1栈顶运算符的优先级：</span><br><span class="line">　（1）如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</span><br><span class="line">　（2）否则，若优先级比栈顶运算符的高，也将运算符压入s1；</span><br><span class="line">　（3）否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较； </span><br><span class="line">5.遇到括号时：　</span><br><span class="line">（1）如果是左括号&quot;(&quot;，则直接压入s1　</span><br><span class="line">（2）如果是右括号&quot;)&quot;，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span><br><span class="line">6.重复步骤2至5，直到表达式的最右边</span><br><span class="line">7.将s1中剩余的运算符依次弹出并压入s2</span><br><span class="line">8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</span><br></pre></td></tr></table></figure><p>4：算法的层面</p><p>​    理解算法→灵活运用算法→自己设计算法</p><p>5：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">package com.it.stack;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class PolandNotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //定义一个逆波兰表达式</span><br><span class="line">        //(3+4)*5-6 =&gt; 3 4 + 5 * 6 -</span><br><span class="line">        //为了方便，逆波兰表达式的数字和符号用空格隔开</span><br><span class="line">/*        String suffixExpression = &quot;30 4 + 5 * 6 -&quot;;</span><br><span class="line">        //思路</span><br><span class="line">        //1：先将&quot;3 4 + 5 * 6 -&quot;放入ArrayList中，这里是为了方便根据索引扫描</span><br><span class="line">        //2：将ArrayList传递给一个方法，遍历ArrayList，配合栈，完成计算</span><br><span class="line">        List&lt;String&gt; list = getListString(suffixExpression);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        int res = calculate(list);</span><br><span class="line">        System.out.println(&quot;计算的结果是=&quot; + res);*/</span><br><span class="line"></span><br><span class="line">        //测试中缀表达式转换成list</span><br><span class="line">        String expression = &quot;1+((2+3)*4)-5&quot;;</span><br><span class="line">        List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);</span><br><span class="line">        System.out.println(&quot;中缀表达式\n&quot; + expression);</span><br><span class="line">        System.out.println(&quot;中缀表达式对应的list\n&quot; + infixExpressionList);</span><br><span class="line">        //将中缀表达式得到的list转换为逆波兰表达式的字符串</span><br><span class="line">        List&lt;String&gt; suffixExpressionList = parseSuffixExpressionList(infixExpressionList);</span><br><span class="line">        System.out.println(&quot;后缀表达式对应的list\n&quot; + suffixExpressionList);</span><br><span class="line">        //验算逆序表达式的结果</span><br><span class="line">        System.out.printf(&quot;expression=%d&quot;, calculate(suffixExpressionList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;String&gt; getListString(String suffixExpression) &#123;</span><br><span class="line">        String[] split = suffixExpression.split(&quot; &quot;);</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        for (String s : split) &#123;</span><br><span class="line">            //遍历添加元素到集合</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //运算</span><br><span class="line">    public static int calculate(List&lt;String&gt; ls) &#123;</span><br><span class="line">        //创建栈</span><br><span class="line">        Stack&lt;String&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (String item : ls) &#123;</span><br><span class="line">            //使用正则表达式取出数,匹配的是多位数</span><br><span class="line">            if (item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">                //入栈</span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int pop2 = Integer.parseInt(stack.pop());</span><br><span class="line">                int pop1 = Integer.parseInt(stack.pop());</span><br><span class="line">                int res = 0;</span><br><span class="line">                if (item.equals(&quot;+&quot;)) &#123;</span><br><span class="line">                    res = pop1 + pop2;</span><br><span class="line">                &#125; else if (item.equals(&quot;-&quot;)) &#123;</span><br><span class="line">                    res = pop1 - pop2;//先弹出的是pop2</span><br><span class="line">                &#125; else if (item.equals(&quot;*&quot;)) &#123;</span><br><span class="line">                    res = pop1 * pop2;</span><br><span class="line">                &#125; else if (item.equals(&quot;/&quot;)) &#123;</span><br><span class="line">                    res = pop1 / pop2;//先弹出的是pop2</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;运算符有误！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(&quot;&quot; + res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最后留在栈中的就是运算结果</span><br><span class="line">        return Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将中缀表达式转出对应的list</span><br><span class="line">    public static List&lt;String&gt; toInfixExpressionList(String s) &#123;</span><br><span class="line">        //定义一个list，存放中缀表达式的内容</span><br><span class="line">        List&lt;String&gt; ls = new ArrayList&lt;String&gt;();</span><br><span class="line">        int i = 0;//指针，用于遍历s</span><br><span class="line">        String str;//对多位数的拼接工作</span><br><span class="line">        char c;//每遍历一个字符，放在char中</span><br><span class="line">        do &#123;</span><br><span class="line">            //如果c是一个非数字，直接加入到ls</span><br><span class="line">            if ((c = s.charAt(i)) &lt; 48 || (c = s.charAt(i)) &gt; 57) &#123;</span><br><span class="line">                ls.add(&quot;&quot; + c);</span><br><span class="line">                i++;//i 需要后移</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //如果是一个数，需要考虑多位数问题</span><br><span class="line">                str = &quot;&quot;;//先将str置空</span><br><span class="line">                //‘0’ 【48】 ‘9’【57】</span><br><span class="line">                while (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= 48 &amp;&amp; (c = s.charAt(i)) &lt;= 57) &#123;</span><br><span class="line">                    str += c;//拼接</span><br><span class="line">                    i++;</span><br><span class="line">                    //while循环结束之后多位数就拼接完成</span><br><span class="line">                &#125;</span><br><span class="line">                ls.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (i &lt; s.length());</span><br><span class="line">        return ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将得到的中缀表达式转换成为的list=&gt;后缀表达式对应的list</span><br><span class="line">    public static List&lt;String&gt; parseSuffixExpressionList(List&lt;String&gt; ls) &#123;</span><br><span class="line">        //定义两个栈</span><br><span class="line">        Stack&lt;String&gt; s1 = new Stack&lt;String&gt;();//定义符号栈</span><br><span class="line">        //说明：因为S2这个栈，在整个过程中没有pop操作，而且后面我们还需要逆序输出，因此直接用ArrayList操作</span><br><span class="line">        //Stack stack2=new Stack();</span><br><span class="line">        List&lt;String&gt; s2 = new ArrayList&lt;&gt;();//储存中间结果的list</span><br><span class="line">        for (String item : ls) &#123;</span><br><span class="line">            if (item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125; else if (item.equals(&quot;(&quot;)) &#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125; else if (item.equals(&quot;)&quot;)) &#123;</span><br><span class="line">                //（2）如果是右括号&quot;)&quot;</span><br><span class="line">                while (!s1.peek().equals(&quot;(&quot;)) &#123;</span><br><span class="line">//                    则依次弹出s1栈顶的运算符，并压入s2</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                //直到遇到左括号为止，此时将这一对括号丢弃</span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //当item的优先级小于或等于栈顶运算符的优先级，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</span><br><span class="line">                //需要加入优先级高低的方法</span><br><span class="line">                while (s1.size() != 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item)) &#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //for循环完成之后，将item压入栈中</span><br><span class="line">        while (s1.size() != 0) &#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return s2;//因为是存放到list中，按照顺序输出就是后缀表达式对应的list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写一个类，可以返回一个运算符对应的优先级</span><br><span class="line">class Operation &#123;</span><br><span class="line">    private static int ADD = 1;</span><br><span class="line">    private static int SUB = 1;</span><br><span class="line">    private static int MUL = 2;</span><br><span class="line">    private static int DIV = 2;</span><br><span class="line"></span><br><span class="line">    public static int getValue(String operation) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        switch (operation) &#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                result = ADD;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                result = SUB;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                result = MUL;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;/&quot;:</span><br><span class="line">                result = DIV;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">//                System.out.println(&quot;不存在操作符&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：栈&quot;&gt;&lt;a href=&quot;#一：栈&quot; class=&quot;headerlink&quot; title=&quot;一：栈&quot;&gt;&lt;/a&gt;一：栈&lt;/h1&gt;&lt;h3 id=&quot;1：栈的应用场景&quot;&gt;&lt;a href=&quot;#1：栈的应用场景&quot; class=&quot;headerlink&quot; title=&quot;1：栈的应
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法(一）数组，队列，链表</title>
    <link href="https://yanyubing.xyz/2018/05/28/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89%E6%95%B0%E7%BB%84%EF%BC%8C%E9%98%9F%E5%88%97%EF%BC%8C%E9%93%BE%E8%A1%A8/"/>
    <id>https://yanyubing.xyz/2018/05/28/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89%E6%95%B0%E7%BB%84%EF%BC%8C%E9%98%9F%E5%88%97%EF%BC%8C%E9%93%BE%E8%A1%A8/</id>
    <published>2018-05-28T13:46:12.000Z</published>
    <updated>2019-12-01T15:06:19.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1：数据结构分类https-leetcode-cn-com-interview"><a href="#1：数据结构分类https-leetcode-cn-com-interview" class="headerlink" title="1：数据结构分类https://leetcode-cn.com/interview/"></a>1：数据结构分类<a href="https://leetcode-cn.com/interview/" target="_blank" rel="noopener">https://leetcode-cn.com/interview/</a></h2><p>线性结构</p><p>线性结构分类：数组，队列，链表，栈</p><p>储存结构分类：顺序储存结构和链式储存结构</p><p>非线性结构</p><p>非线性结构分类：二维数组，多维数组，广义表，树结构，图结构</p><h2 id="2：稀疏数组"><a href="#2：稀疏数组" class="headerlink" title="2：稀疏数组"></a>2：稀疏数组</h2><p>1：基本介绍博客：<a href="https://www.cnblogs.com/blizzawang/p/11411602.html" target="_blank" rel="noopener">https://www.cnblogs.com/blizzawang/p/11411602.html</a> </p><p>2：逻辑：稀疏数组第一行第一列表示二维数组的行数，第一行第二列表示二维数组的列数，第一行第三列表示二维数组非0的个数，下列每一行的三个数分别表示哪一行，哪一列，对应的数是多少。</p><p>3：转换为稀疏数组主要用于对数据的压缩</p><p>4：二维数组与稀疏数组转换代码实现，核心思想为数据的对应转换！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">1：二维数组转换为稀疏数组思路：</span><br><span class="line">1.遍历原始的二维数组，得到有数据的个数n</span><br><span class="line">2.根据sum就可以创建稀疏数组sparseArr int[n+1][3]</span><br><span class="line">3.将二维数组的有效数据存入到稀疏数组</span><br><span class="line"></span><br><span class="line">2：稀疏数组转换为二维数组：</span><br><span class="line">1：先读取稀疏数组的第一行</span><br><span class="line">2：根据第一行的数据创建原始二位数组</span><br><span class="line">3：在读取稀疏数组后几行的数据，并赋给原始二维数组即可</span><br><span class="line"></span><br><span class="line">package com.it.sparsearray;</span><br><span class="line"></span><br><span class="line">//棋盘二维数组转换为稀疏数组</span><br><span class="line">public class SparseArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //先创建一个原始的二维数组 11*11</span><br><span class="line">        //0表示没有棋子，1表示黑子，2表示白子</span><br><span class="line">        int[][] chessArr1 = new int[11][11];</span><br><span class="line">        chessArr1[1][2] = 1;</span><br><span class="line">        chessArr1[2][3] = 2;</span><br><span class="line">        //原始的二维数组</span><br><span class="line">        for (int[] ints : chessArr1) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        //将二维数组转为稀疏数组的思路</span><br><span class="line">        //1：先遍历二维数组，得到非0的个数</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 11; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 11; j++) &#123;</span><br><span class="line">                if (chessArr1[i][j] != 0) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //2：创建对应的稀疏数组</span><br><span class="line">        int sparseArr[][] = new int[sum + 1][3];</span><br><span class="line">        //给稀疏数字赋值</span><br><span class="line">        sparseArr[0][0] = 11;</span><br><span class="line">        sparseArr[0][1] = 11;</span><br><span class="line">        sparseArr[0][2] = sum;</span><br><span class="line">        //遍历二维数组，将非0的值存放到稀疏数组中</span><br><span class="line">        int count = 0;//count用于记录是第几个非0数字</span><br><span class="line">        for (int i = 0; i &lt; 11; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 11; j++) &#123;</span><br><span class="line">                if (chessArr1[i][j] != 0) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][0] = i;</span><br><span class="line">                    sparseArr[count][1] = j;</span><br><span class="line">                    sparseArr[count][2] = chessArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //输出稀疏数组</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;得到的稀疏数组如下&quot;);</span><br><span class="line">        for (int i = 0; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;%d\t%d\t%d\t\n&quot;, sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);</span><br><span class="line">        &#125;</span><br><span class="line">        //根据稀疏数组的第一行数据，创建元素二维数组</span><br><span class="line">        int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">        //输出恢复后的二维数组</span><br><span class="line">        System.out.println(&quot;转换为二维数组如下&quot;);</span><br><span class="line">        for (int i = 1; i &lt; sparseArr[0][2] + 1; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int[] ints : chessArr2) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3：队列"><a href="#3：队列" class="headerlink" title="3：队列"></a>3：队列</h1><p>1：队列基本介绍</p><p>​    队列是一个有序表，可以用数组或者链表来实现</p><p>​    队列为先入先出原则</p><p>​    队列加数据从尾部开始加，首部不变；取数据从首部开始取，尾部不变</p><p>​    核心思想：普通队列，如队列大小为10，那么只能add10次数据，因为数组索引用过已经无法再次使用；而环形队列判断队列是否满的依据则是队列中是否已经占满数据。</p><p>​    注意：取出数据之后数组元素并未被移除，环形队列也是</p><p>2：普通队列实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">package com.it.queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayQueue queue = new ArrayQueue(5);</span><br><span class="line">        char key = &apos; &apos;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        boolean loop = true;</span><br><span class="line">        //输出一个菜单</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">            System.out.println(&quot;e(exit):退出队列&quot;);</span><br><span class="line">            System.out.println(&quot;a(add):添加数据到队列&quot;);</span><br><span class="line">            System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;h(head):查看队列的数据&quot;);</span><br><span class="line">            key = scanner.next().charAt(0);//接收一个字符</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &apos;s&apos;://显示队列</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;a&apos;://添加数据</span><br><span class="line">                    System.out.println(&quot;请输入一个数&quot;);</span><br><span class="line">                    int value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;g&apos;://取出数据</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = queue.getQueue();</span><br><span class="line">                        System.out.printf(&quot;取出的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;h&apos;://查看队列头的数据是什么</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = queue.headQueue();</span><br><span class="line">                        System.out.printf(&quot;队列头的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;e&apos;://退出</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;--------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用数组模拟队列，编写一个ArrayQueue类</span><br><span class="line">class ArrayQueue &#123;</span><br><span class="line">    private int maxSize;//表示数组最大容量</span><br><span class="line">    private int front;//队列头</span><br><span class="line">    private int rear;//队列尾</span><br><span class="line">    private int[] arr;//该数据用于队列存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    //创建队列的构造器,数组最大容量</span><br><span class="line">    public ArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = -1;//指向队列头部的前一个位置</span><br><span class="line">        rear = -1;//指向队列尾部</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        //当尾部到达了队列最后一个无法添加数据</span><br><span class="line">        return rear == maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        //当队列头与队列尾相等时为空</span><br><span class="line">        return rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;队列满，无法加入数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //未满，可以加入数据</span><br><span class="line">        rear++;//让rear后移</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getQueue() &#123;</span><br><span class="line">        //判断队列是否空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            //通过抛出异常处理</span><br><span class="line">            throw new RuntimeException(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //front后移</span><br><span class="line">        front++;</span><br><span class="line">        //获取数据</span><br><span class="line">        return arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showQueue() &#123;</span><br><span class="line">        //遍历</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;队列空的，没数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d]=%d\n&quot;, i, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int headQueue() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列空的，没数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //front指向数组头部前一位</span><br><span class="line">        return arr[front + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3：环形队列实现思路</p><p>​    1：front变量的含义调整，front指向队列的第一个元素，也就是arr[front]就是队列的第一个元素，front初始值默认为0，rear的初始值为0</p><p>​    2：rear变量的含义做一个调整，rear指向队列最后一个元素的后一个位置，因为希望空出一个空间作为约定</p><p>​    3：当队列满时，条件是（rear+1）%maxSize=front</p><p>​    4：当队列为空的条件：rear=front</p><p>​    5：当我们这样分析，队列中有效的数据个数（rear+maxSize-front)%maxSize</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">//环形队列</span><br><span class="line">package com.it.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class CircleArrayQueue &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CircleArray circleArray = new CircleArray(5);</span><br><span class="line">        char key = &apos; &apos;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        boolean loop = true;</span><br><span class="line">        System.out.println(&quot;测试环形队列！&quot;);</span><br><span class="line">        //输出一个菜单</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">            System.out.println(&quot;e(exit):退出队列&quot;);</span><br><span class="line">            System.out.println(&quot;a(add):添加数据到队列&quot;);</span><br><span class="line">            System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;h(head):查看队列的数据&quot;);</span><br><span class="line">            key = scanner.next().charAt(0);//接收一个字符</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &apos;s&apos;://显示队列</span><br><span class="line">                    circleArray.showQueue();</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;a&apos;://添加数据</span><br><span class="line">                    System.out.println(&quot;请输入一个数&quot;);</span><br><span class="line">                    int value = scanner.nextInt();</span><br><span class="line">                    circleArray.addQueue(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;g&apos;://取出数据</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.getQueue();</span><br><span class="line">                        System.out.printf(&quot;取出的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;h&apos;://查看队列头的数据是什么</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.headQueue();</span><br><span class="line">                        System.out.printf(&quot;队列头的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;e&apos;://退出</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;--------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用数组模拟队列，编写一个ArrayQueue类</span><br><span class="line">class CircleArray &#123;</span><br><span class="line">    private int maxSize;//表示数组最大容量</span><br><span class="line">    //    front变量的含义调整，front指向队列的第一个元素，也就是arr[front]就是队列的第一个元素，front初始值默认为0，rear的初始值为0</span><br><span class="line">    private int front;//队列头</span><br><span class="line">    //    rear变量的含义做一个调整，rear指向队列最后一个元素的后一个位置，因为希望空出一个空间作为约定</span><br><span class="line">    private int rear;//队列尾</span><br><span class="line">    private int[] arr;//该数据用于队列存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    //创建队列的构造器,数组最大容量</span><br><span class="line">    public CircleArray(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = 0;//指向队列头部的前一个位置</span><br><span class="line">        rear = 0;//指向队列尾部</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        //判断是否满</span><br><span class="line">        return (rear + 1) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        //当队列头与队列尾相等时为空</span><br><span class="line">        return rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;队列满，无法加入数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //未满，可以加入数据</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        rear = (rear + 1) % maxSize;//让rear后移，这里必须考虑取模</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getQueue() &#123;</span><br><span class="line">        //判断队列是否空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            //通过抛出异常处理</span><br><span class="line">            throw new RuntimeException(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //这里分析出front对应的值保留到一个临时变量</span><br><span class="line">        //将front后移,考虑取模</span><br><span class="line">        //将临时变量的变量返回</span><br><span class="line">        int value = arr[front];</span><br><span class="line">        front = (front + 1) % maxSize;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showQueue() &#123;</span><br><span class="line">        //遍历</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;队列空的，没数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //思路，从front开始遍历</span><br><span class="line">        for (int i = front; i &lt; (front + size()); i++) &#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d]=%d\n&quot;, i % maxSize, arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //求出当前队列有效数据的个数，为了遍历</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int headQueue() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列空的，没数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //front指向数组头部前一位</span><br><span class="line">        return arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4：单向链表"><a href="#4：单向链表" class="headerlink" title="4：单向链表"></a>4：单向链表</h1><p>1：链表基本介绍</p><p>​    链表是以节点的方式来储存，链式储存</p><p>​    每个节点包含data域，next域：指向下一个节点</p><p>​    链表的各个节点不一定是连续储存</p><p>​    链表分带头节点的链表和没有头节点的链表，根据实际需求来确定</p><p>2：单链表的创建（添加），显示单向链表的分析</p><p>​    head节点：不存放具体的数据，作用就是表示单链表头</p><p>​    先创建一个head头节点，作用就是单链表的头</p><p>​    后面我们每添加一个节点，就直接加入到链表的最后</p><p>​    通过一个辅助的指针，帮助遍历</p><p>3：单链表代码实现</p><p>​    1：直接添加到英雄的尾部</p><p>​    2：考虑节点排名添加（插入）</p><p>​    思路：</p><p>​        1：首先找到新添加的节点位置，通过辅助变量（指针）</p><p>​        2：新的节点.next=temp.next</p><p>​        3：将temp.next=新的节点</p><p>​        4：可以在内存中实现排序</p><p>​    3：修改节点</p><p>​    4：删除节点</p><p>​        1：找到需要删除节点的前一个节点</p><p>​        2：temp.next=temp.next.next</p><p>​        3：被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收</p><p>​    5：求单链表的节点个数</p><p>​        1：遍历（temp后移）并且length++；</p><p>​    6：查找单链表中的倒数第k个节点</p><p>​        1：编写一个方法，接收head节点，同时接收一个index</p><p>​        2：index表示倒数第index的索引</p><p>​        3：先遍历链表，拿到链表所有个数getLength，再获取第n-index节点信息</p><p>​    7：链表的反转</p><p>​        1：创建新的链表（定义一个新的链表头reverse）</p><p>​        2：遍历原链表可以获取顺数每个节点的信息</p><p>​        3：每遍历一个节点就将其取出并放在新链表的最前方</p><p>​        4：原来链表的head.next=reverse.next</p><p>​    8：链表的逆序打印</p><p>​        1：方法一：单链表反转之后打印</p><p>​        2：方法二：利用栈这个数据结构，将各个节点压入栈中，然后利用栈的先进后出的特点，实现逆序打印效果</p><p>​        3：方法三：循环，判断temp是否是尾结点，打印尾结点，把尾结点前一结点.next赋值为null，并且重置temp=head.next；如果最后只有一个节点，即head.next=temp，且temp.next==null，则打印temp然后退出循环</p><p>​        4：方法四：递归</p><p>​        注意：操作链表时，一定要注意链表是否已经改变！</p><p>​    9：多个链表的合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line">package com.it.com.it.linkedlist;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">//链表实现水浒英雄的增删改查</span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试，先创建节点</span><br><span class="line">        HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);</span><br><span class="line">        HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);</span><br><span class="line">        HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line">        //创建链表</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line">        //直接加入</span><br><span class="line">//        singleLinkedList.add(hero1);</span><br><span class="line">//        singleLinkedList.add(hero4);</span><br><span class="line">//        singleLinkedList.add(hero2);</span><br><span class="line">//        singleLinkedList.add(hero3);</span><br><span class="line">        //按照编号添加</span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        //测试修改代码</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        HeroNode heroNode = new HeroNode(2, &quot;小卢&quot;, &quot;玉麒麟~~~&quot;);</span><br><span class="line">        singleLinkedList.update(heroNode);</span><br><span class="line">        //打印</span><br><span class="line">        System.out.println(&quot;修改之后链表的情况&quot;);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        //删除节点</span><br><span class="line">        singleLinkedList.del(1);</span><br><span class="line">//        singleLinkedList.del(4);</span><br><span class="line">//        singleLinkedList.del(2);</span><br><span class="line">//        singleLinkedList.del(3);</span><br><span class="line">        System.out.println(&quot;删除之后链表的情况&quot;);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        //测试链表节点个数</span><br><span class="line">//        System.out.println(&quot;有效节点个数&quot; + getLength(singleLinkedList.getHead()));</span><br><span class="line">        //测试倒数第k个节点</span><br><span class="line">//        int index = 3;</span><br><span class="line">//        HeroNode res = findLastIndexNode(singleLinkedList.getHead(), index);</span><br><span class="line">//        System.out.println(&quot;res=&quot; + res);</span><br><span class="line">        //测试反转链表</span><br><span class="line">//        System.out.println(&quot;反转之后链表是：&quot;);//这个方法改变了链表的结构</span><br><span class="line">//        reverseList(singleLinkedList.getHead());</span><br><span class="line">        //测试反转打印</span><br><span class="line">        System.out.println(&quot;反转打印方式二，栈方法：&quot;);</span><br><span class="line">        singleLinkedList.reversePrint();</span><br><span class="line">        System.out.println(&quot;反转打印方式一：&quot;);//这个方法该表了链表的结构</span><br><span class="line">        singleLinkedList.printReverse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义singleLinkedList管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //初始化一个头结点，头结点不要动,不存放具体数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    public HeroNode getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点到单向链表,这里没考虑排名</span><br><span class="line">    //1:找到最后节点（next域为null），把最后节点的next域指向新的节点</span><br><span class="line">    public void add(HeroNode heroNode) &#123;</span><br><span class="line">//因为head节点不能动，因此我们需要一个辅助遍历temp指针，来移动</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            if (temp.next == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到，就将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //当退出循环时，temp就指向了链表的最后</span><br><span class="line">        //将最后节点的next指向新的节点</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种方式添加英雄，如果有这个排名，则添加失败，并给出提示</span><br><span class="line">    public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">        //因为是单链表，因为我们找到的temp是位于添加位置的前一个节点，否则无法添加</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = false;//标识添加编号是否存在，默认为false</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp.next == null) &#123;//说明temp已经在链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125; else if (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">                //位置找到，该节点添加到temp和temp.next之间插入</span><br><span class="line">                break;</span><br><span class="line">            &#125; else if (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                flag = true;//说明编号存在</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;//后移，遍历链表</span><br><span class="line">        &#125;</span><br><span class="line">        //退出循环之后，判断flag值</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            System.out.printf(&quot;准备插入的英雄的编号%d已经存在\n&quot;, heroNode.no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //插入到链表中，temp的后面</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改节点信息，根据no编号来修改，即no编号不能改</span><br><span class="line">    public void update(HeroNode newHeroNode) &#123;</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //找到需要修改的节点，根据no编号</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        boolean flag = false;//表示是否找到该节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;//链表已经遍历结束</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                //找到节点</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //退出循环之后，根据flag判断是否找到要修改的节点</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;没找到编号为%d的节点，不能修改\n&quot;, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除节点</span><br><span class="line">//说明：是temp.next.no和需要删除的节点的no比较</span><br><span class="line">    public void del(int no) &#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = false;//标志是否找到待删除的节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp.next == null) &#123;</span><br><span class="line">                break;//到达链表尾部</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.next.no == no) &#123;</span><br><span class="line">                //找到待删除节点的前一个节点temp</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断flag</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            //可以删除</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;要删除的%d节点不存在\n&quot;, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //统计链表节点个数：去除头结点</span><br><span class="line">    public static int getLength(HeroNode head) &#123;</span><br><span class="line">        int length = 0;</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            HeroNode temp = head.next;</span><br><span class="line">            while (temp != null) &#123;</span><br><span class="line">                length++;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取单链表的倒数第K个节点</span><br><span class="line">    public static HeroNode findLastIndexNode(HeroNode hero, int index) &#123;</span><br><span class="line">        if (hero.next == null) &#123;</span><br><span class="line">            //链表为空</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //第一次遍历得到链表的长度（节点个数）</span><br><span class="line">        int size = getLength(hero);</span><br><span class="line">        //第二次遍历，先做index校验，是否合理</span><br><span class="line">        if (index &lt;= 0 || index &gt; size) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义一个辅助遍历temp</span><br><span class="line">        HeroNode temp = hero.next;</span><br><span class="line">        //往后数size-index个</span><br><span class="line">        for (int i = 0; i &lt; size - index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历链表，使用辅助变量遍历，因为head不能动</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //因为头结点不能动，所以我们需要一个辅助遍历来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //判断是否到链表的最后</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //输出节点信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            //temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //单链表反转</span><br><span class="line">    public static void reverseList(HeroNode head) &#123;</span><br><span class="line">        //如果当前链表为空，或者只有一个节点，无需反转，直接返回</span><br><span class="line">        if (head.next == null || head.next.next == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义一个辅助指针，帮助我们遍历原来链表</span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        HeroNode next = null;//指向当前节点cur的下一个节点，作为中间变量</span><br><span class="line">        int sum = getLength(head);</span><br><span class="line">        //定义反转链表,注意此时的head在改变，所以提前获取到固定长度</span><br><span class="line">        HeroNode reverserHead = new HeroNode(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line">        for (int i = 0; i &lt; sum; i++) &#123;</span><br><span class="line">            //给原链表下个节点赋值,后续把next赋值给cur，达到移动的效果</span><br><span class="line">            next = cur.next;</span><br><span class="line">            //拼接操作，把reverserHead.next给cur.next,再把cur节点作为reverserHead.next</span><br><span class="line">            cur.next = reverserHead.next;</span><br><span class="line">            reverserHead.next = cur;</span><br><span class="line">            //next赋值给cur，达到移动的效果</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历反转链表，这里也可以直接把反转链表的next赋值给原来的head.next，直接用用来的list（）方法遍历</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (reverserHead.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //因为头结点不能动，所以我们需要一个辅助遍历来遍历</span><br><span class="line">        HeroNode temp = reverserHead.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //判断是否到链表的最后</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //输出节点信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            //temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printReverse() &#123;</span><br><span class="line">        HeroNode temp = head;//temp</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == head &amp;&amp; temp.next.next == null) &#123;</span><br><span class="line">                System.out.println(temp.next);</span><br><span class="line">                break;</span><br><span class="line">            &#125;//temp代表倒数第二个节点</span><br><span class="line">            if (temp.next.next == null) &#123;</span><br><span class="line">                System.out.println(temp.next);</span><br><span class="line">                temp.next = null;</span><br><span class="line">                temp = head;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //方式二</span><br><span class="line">    public void reversePrint() &#123;</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个栈，将各个节点压入栈中</span><br><span class="line">        Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;//cur后移</span><br><span class="line">        &#125;</span><br><span class="line">        //将栈中的节点进行打印，pop出栈,先进后出</span><br><span class="line">        while (stack.size() &gt; 0) &#123;</span><br><span class="line">            System.out.println(stack.pop());//后进先出</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建heroNode节点,每个heroNode对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode next;//指向下一个节点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int hNo, String hName, String hNickname) &#123;</span><br><span class="line">        this.no = hNo;</span><br><span class="line">        this.name = hName;</span><br><span class="line">        this.nickname = hNickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写tostring</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode[no=&quot; + no + &quot;,name=&quot; + name + &quot;,nickname=&quot; + nickname + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五：双向链表"><a href="#五：双向链表" class="headerlink" title="五：双向链表"></a>五：双向链表</h1><p>1：单向链表，查找只能一个方向next，而双休链表可以双向</p><p>2：单向链表不能自我删除，需要靠辅助节点temp</p><p>3：双向链表的遍历，添加，修改，删除的操作思路</p><p>​    添加步骤（默认添加到双向链表的最后）：</p><p>​    1：先找到双向链表的最后节点</p><p>​    2：temp.next=newHoroNode</p><p>​    3：newHoroNode.pre=temp</p><p>​    删除步骤：</p><p>​    1: 直接找到要删除的节点，比如temp</p><p>​    2：temp.pre.next=temp.next</p><p>​    3：temp.next.pre=temp.pre</p><p>4：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">package com.it.com.it.linkedlist;</span><br><span class="line"></span><br><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 测试</span><br><span class="line">        System.out.println(&quot;双向链表的测试&quot;);</span><br><span class="line">        // 先创建节点</span><br><span class="line">        HeroNode2 hero1 = new HeroNode2(1, &quot;宋江&quot;, &quot;及时雨&quot;);</span><br><span class="line">        HeroNode2 hero2 = new HeroNode2(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode2 hero3 = new HeroNode2(3, &quot;吴用&quot;, &quot;智多星&quot;);</span><br><span class="line">        HeroNode2 hero4 = new HeroNode2(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line">        // 创建一个双向链表</span><br><span class="line">        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();</span><br><span class="line">        // 添加数据</span><br><span class="line">        doubleLinkedList.add(hero1);</span><br><span class="line">        doubleLinkedList.add(hero2);</span><br><span class="line">        doubleLinkedList.add(hero3);</span><br><span class="line">        doubleLinkedList.add(hero4);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        // 修改</span><br><span class="line">        HeroNode2 newHeroNode = new HeroNode2(4, &quot;公孙胜&quot;, &quot;入云龙&quot;);</span><br><span class="line">        doubleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(&quot;修改后的链表情况&quot;);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        // 删除</span><br><span class="line">        doubleLinkedList.del(3);</span><br><span class="line">        System.out.println(&quot;删除后的链表情况~~&quot;);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个双向链表的类</span><br><span class="line">class DoubleLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    // 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">    private HeroNode2 head = new HeroNode2(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    // 返回头节点</span><br><span class="line">    public HeroNode2 getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历双向链表的方法</span><br><span class="line">    // 显示链表[遍历]</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        // 判断链表是否为空</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 判断是否到链表最后</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 输出节点的信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            // 将temp后移， 一定小心</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加一个节点到双向链表的最后.</span><br><span class="line">    public void add(HeroNode2 heroNode) &#123;</span><br><span class="line"></span><br><span class="line">        // 因为head节点不能动，因此我们需要一个辅助遍历 temp</span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        // 遍历链表，找到最后</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 找到链表的最后</span><br><span class="line">            if (temp.next == null) &#123;//</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果没有找到最后, 将将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当退出while循环时，temp就指向了链表的最后</span><br><span class="line">        // 形成一个双向链表</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样</span><br><span class="line">    // 只是 节点类型改成 HeroNode2</span><br><span class="line">    public void update(HeroNode2 newHeroNode) &#123;</span><br><span class="line">        // 判断是否空</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空~&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到需要修改的节点, 根据no编号</span><br><span class="line">        // 定义一个辅助变量</span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        boolean flag = false; // 表示是否找到该节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break; // 已经遍历完链表</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                // 找到</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 根据flag 判断是否找到要修改的节点</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; else &#123; // 没有找到</span><br><span class="line">            System.out.printf(&quot;没有找到 编号 %d 的节点，不能修改\n&quot;, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从双向链表中删除一个节点,</span><br><span class="line">    // 说明</span><br><span class="line">    // 1 对于双向链表，我们可以直接找到要删除的这个节点</span><br><span class="line">    // 2 找到后，自我删除即可</span><br><span class="line">    public void del(int no) &#123;</span><br><span class="line"></span><br><span class="line">        // 判断当前链表是否为空</span><br><span class="line">        if (head.next == null) &#123;// 空链表</span><br><span class="line">            System.out.println(&quot;链表为空，无法删除&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode2 temp = head.next; // 辅助变量(指针)</span><br><span class="line">        boolean flag = false; // 标志是否找到待删除节点的</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == null) &#123; // 已经到链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no == no) &#123;</span><br><span class="line">                // 找到的待删除节点的前一个节点temp</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next; // temp后移，遍历</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断flag</span><br><span class="line">        if (flag) &#123; // 找到</span><br><span class="line">            // 可以删除</span><br><span class="line">            // temp.next = temp.next.next;[单向链表]</span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            // 这里我们的代码有问题?</span><br><span class="line">            // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span><br><span class="line">            if (temp.next != null) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;要删除的 %d 节点不存在\n&quot;, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义HeroNode2 ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode2 next; // 指向下一个节点, 默认为null</span><br><span class="line">    public HeroNode2 pre; // 指向前一个节点, 默认为null</span><br><span class="line">    // 构造器</span><br><span class="line"></span><br><span class="line">    public HeroNode2(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为了显示方法，我们重新toString</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickname=&quot; + nickname + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六：单向环形链表（约瑟夫环）"><a href="#六：单向环形链表（约瑟夫环）" class="headerlink" title="六：单向环形链表（约瑟夫环）"></a>六：单向环形链表（约瑟夫环）</h1><p>1：约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3，1。 </p><p>2：创建环形链表思路</p><p>​    1：先创建第一个节点，让first指向该节点，加入到已有的环形链表中即可</p><p>​    2：后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中</p><p>3：遍历环形链表</p><p>​    1：先让一个辅助指针（变量）curBoy,指向first节点</p><p>​    2：通过while循环遍历该环形链表即可，curBoy.next==first，结束</p><p>4：创建、遍历环形链表代码实现</p><p>5：出圈思路</p><p>​    1：根据用户的输入，生成一个小孩出圈的顺序</p><p>​    2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">package com.it.com.it.linkedlist;</span><br><span class="line"></span><br><span class="line">//约瑟夫问题：环形链表解决</span><br><span class="line">public class Josepfu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(10);</span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line">        //测试小孩出圈</span><br><span class="line">        circleSingleLinkedList.countBoy(1, 2, 10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建环形链表</span><br><span class="line">class CircleSingleLinkedList &#123;</span><br><span class="line">    //创建一个first节点，无编号</span><br><span class="line">    private Boy first = null;</span><br><span class="line"></span><br><span class="line">    //添加节点，构建成环形链表</span><br><span class="line">    public void addBoy(int nums) &#123;</span><br><span class="line">        //nums表示环形链表节点个数</span><br><span class="line">        if (nums &lt; 1) &#123;</span><br><span class="line">            System.out.println(&quot;nums值不正确&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy curBoy = null;//辅助指针，帮助构建环形链表</span><br><span class="line">        //使用for循环创建环形链表</span><br><span class="line">        for (int i = 1; i &lt;= nums; i++) &#123;</span><br><span class="line">            //根据编号创建小孩节点</span><br><span class="line">            Boy boy = new Boy(i);</span><br><span class="line">            //给第一个小孩赋值</span><br><span class="line">            if (i == 1) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);</span><br><span class="line">                //让curBoy指向第一个小孩，因为first不能变动，需要让curBoy辅助</span><br><span class="line">                curBoy = first;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //构建环</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                //curBoy后移</span><br><span class="line">                curBoy = curBoy.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历环形链表</span><br><span class="line">    public void showBoy() &#123;</span><br><span class="line">        //判断链表是否为空</span><br><span class="line">        if (first == null) &#123;</span><br><span class="line">            System.out.println(&quot;没有小孩--&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //使用辅助指针帮助遍历</span><br><span class="line">        Boy curBoy = first;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.printf(&quot;小孩的编号%d:\n&quot;, curBoy.getNo());</span><br><span class="line">            //已经遍历完毕</span><br><span class="line">            if (curBoy.getNext() == first) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">//            curBoy后移</span><br><span class="line">            curBoy = curBoy.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //根据用户的输入，计算出圈的顺序</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param startNo  表示从第几个小孩开始数数</span><br><span class="line">     * @param countNum 表示数几下</span><br><span class="line">     * @param nums     表示最初有几个小孩，作为校验</span><br><span class="line">     */</span><br><span class="line">    public void countBoy(int startNo, int countNum, int nums) &#123;</span><br><span class="line">        if (first == null || startNo &lt; 1 || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(&quot;参数有误，请重新输入&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个辅助指针，帮助小孩出圈</span><br><span class="line">        Boy helper = first;</span><br><span class="line">        //使helper指向最后节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //相等说明helper在最后</span><br><span class="line">            if (helper.getNext() == first) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //helper后移</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //报数前，先让first和helper移动startNo-1次</span><br><span class="line">        for (int i = 0; i &lt; startNo - 1; i++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //当小孩报数时，让first和helper指针同时移动countNum-1次，然后出圈</span><br><span class="line">        //这里是一个循环操作，知道圈中只有一个节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //说明圈中只有一个节点</span><br><span class="line">            if (helper == first) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //让first和helper指针同时移动countNum-1次，然后出圈</span><br><span class="line">            for (int i = 0; i &lt; countNum - 1; i++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            //这时first指向的节点就是要出圈的节点</span><br><span class="line">            System.out.printf(&quot;小孩%d出圈\n&quot;, first.getNo());</span><br><span class="line">            //first指向的节点出圈</span><br><span class="line">            first = first.getNext();//使first后移</span><br><span class="line">            helper.setNext(first);//使helper的next指向first</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;最后留在圈中的小孩编号是%d\n&quot;, first.getNo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建一个boy，表示一个节点</span><br><span class="line">class Boy &#123;</span><br><span class="line">    private int no;</span><br><span class="line">    private Boy next;//指向下一个节点，默认null</span><br><span class="line"></span><br><span class="line">    public Boy(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Boy getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(Boy next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1：数据结构分类https-leetcode-cn-com-interview&quot;&gt;&lt;a href=&quot;#1：数据结构分类https-leetcode-cn-com-interview&quot; class=&quot;headerlink&quot; title=&quot;1：数据结构分类https:
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（5）查找</title>
    <link href="https://yanyubing.xyz/2018/05/22/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E6%9F%A5%E6%89%BE/"/>
    <id>https://yanyubing.xyz/2018/05/22/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E6%9F%A5%E6%89%BE/</id>
    <published>2018-05-22T13:46:12.000Z</published>
    <updated>2019-12-06T01:21:14.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：线性查找"><a href="#1：线性查找" class="headerlink" title="1：线性查找"></a>1：线性查找</h1><p>1：线性查找思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1：遍历数组，逐一匹配，相等即返回</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">public class SeqSearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] = &#123;1, 9, 11, -1, 34, 89&#125;;</span><br><span class="line">        int value = 9;</span><br><span class="line">        System.out.println(seqSearch(arr, value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int seqSearch(int[] arr, int value) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (value == arr[i]) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2：二分查找"><a href="#2：二分查找" class="headerlink" title="2：二分查找"></a>2：二分查找</h3><p>1：二分查找思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：要求数组有序（假设从下到大排序）</span><br><span class="line">2：首先确定该数组的中间的下标 mid=(left+right)/2</span><br><span class="line">3：arr[mid]与要查找的数val比较</span><br><span class="line">4：如果arr[mid]&gt;val，则表示val在arr[mid]左边，再次移动left和rigth继续查找</span><br><span class="line">5：相反arr[mid]&lt;val，同理</span><br><span class="line">6：arr[mid]==val则直接返回</span><br><span class="line">7：递归结束条件，rigth-left==1</span><br></pre></td></tr></table></figure><p>2：代码实现（1）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//该代码只能找到只有一个匹配的值的索引</span><br><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">public class BinarySearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] = &#123;1, 8, 10, 89, 1000, 1234&#125;;</span><br><span class="line">        int res = binarySearch(arr, 0, arr.length - 1, 10);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int binarySearch(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line">        if (right - left == 0) &#123;</span><br><span class="line">            return -1;//说明递归已经完成，没找到</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        if (arr[mid] &gt; findVal) &#123;//说明该值在左标</span><br><span class="line">            return binarySearch(arr, left, mid - 1, findVal);</span><br><span class="line">        &#125;</span><br><span class="line">        if (arr[mid] &lt; findVal) &#123;//说明该值在右标</span><br><span class="line">            return binarySearch(arr, mid + 1, right, findVal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mid;//最终找到的结果数据是这句话</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3：代码实现（二）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">//注意：使用二分查找的前提是 该数组是有序的.</span><br><span class="line">public class BinarySearch &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;;</span><br><span class="line">int arr[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 , 11, 12, 13,14,15,16,17,18,19,20 &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//int resIndex = binarySearch(arr, 0, arr.length - 1, 1000);</span><br><span class="line">//System.out.println(&quot;resIndex=&quot; + resIndex);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; resIndexList = binarySearch2(arr, 0, arr.length - 1, 1);</span><br><span class="line">System.out.println(&quot;resIndexList=&quot; + resIndexList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 二分查找算法</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param arr</span><br><span class="line"> *            数组</span><br><span class="line"> * @param left</span><br><span class="line"> *            左边的索引</span><br><span class="line"> * @param right</span><br><span class="line"> *            右边的索引</span><br><span class="line"> * @param findVal</span><br><span class="line"> *            要查找的值</span><br><span class="line"> * @return 如果找到就返回下标，如果没有找到，就返回 -1</span><br><span class="line"> */</span><br><span class="line">public static int binarySearch(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span><br><span class="line">if (left &gt; right) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (left + right) / 2;</span><br><span class="line">int midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">if (findVal &gt; midVal) &#123; // 向 右递归</span><br><span class="line">return binarySearch(arr, mid + 1, right, findVal);</span><br><span class="line">&#125; else if (findVal &lt; midVal) &#123; // 向左递归</span><br><span class="line">return binarySearch(arr, left, mid - 1, findVal);</span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//思考题:</span><br><span class="line">/*</span><br><span class="line"> *  &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中，</span><br><span class="line"> * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</span><br><span class="line"> * </span><br><span class="line"> * 思路分析</span><br><span class="line"> * 1. 在找到mid 索引值，不要马上返回</span><br><span class="line"> * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line"> * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line"> * 4. 将Arraylist返回</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public static List&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;hello~&quot;);</span><br><span class="line">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span><br><span class="line">if (left &gt; right) &#123;</span><br><span class="line">return new ArrayList&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line">int mid = (left + right) / 2;</span><br><span class="line">int midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">if (findVal &gt; midVal) &#123; // 向 右递归</span><br><span class="line">return binarySearch2(arr, mid + 1, right, findVal);</span><br><span class="line">&#125; else if (findVal &lt; midVal) &#123; // 向左递归</span><br><span class="line">return binarySearch2(arr, left, mid - 1, findVal);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// * 思路分析</span><br><span class="line">// * 1. 在找到mid 索引值，不要马上返回</span><br><span class="line">// * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line">// * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line">// * 4. 将Arraylist返回</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; resIndexlist = new ArrayList&lt;Integer&gt;();</span><br><span class="line">//向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line">int temp = mid - 1;</span><br><span class="line">while(true) &#123;</span><br><span class="line">if (temp &lt; 0 || arr[temp] != findVal) &#123;//退出</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//否则，就temp 放入到 resIndexlist</span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp -= 1; //temp左移</span><br><span class="line">&#125;</span><br><span class="line">resIndexlist.add(mid);  //</span><br><span class="line"></span><br><span class="line">//向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line">temp = mid + 1;</span><br><span class="line">while(true) &#123;</span><br><span class="line">if (temp &gt; arr.length - 1 || arr[temp] != findVal) &#123;//退出</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//否则，就temp 放入到 resIndexlist</span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp += 1; //temp右移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return resIndexlist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三：插值查找"><a href="#三：插值查找" class="headerlink" title="三：插值查找"></a>三：插值查找</h3><p>1：插值查找思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：插值查找和二分查找思想是一样，只是中值的确定由原来的二等分改变成了等比值，</span><br><span class="line">例如：mid(索引)=left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left])</span><br><span class="line">2:相当于更加适合线性的数组</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class InsertValueSearch &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">//int [] arr = new int[100];</span><br><span class="line">//for(int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">//arr[i] = i + 1;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;;</span><br><span class="line"></span><br><span class="line">int index = insertValueSearch(arr, 0, arr.length - 1, 1234);</span><br><span class="line">//int index = binarySearch(arr, 0, arr.length, 1);</span><br><span class="line">System.out.println(&quot;index = &quot; + index);</span><br><span class="line"></span><br><span class="line">//System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int binarySearch(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line">System.out.println(&quot;二分查找被调用~&quot;);</span><br><span class="line">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span><br><span class="line">if (left &gt; right) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (left + right) / 2;</span><br><span class="line">int midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">if (findVal &gt; midVal) &#123; // 向 右递归</span><br><span class="line">return binarySearch(arr, mid + 1, right, findVal);</span><br><span class="line">&#125; else if (findVal &lt; midVal) &#123; // 向左递归</span><br><span class="line">return binarySearch(arr, left, mid - 1, findVal);</span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写插值查找算法</span><br><span class="line">//说明：插值查找算法，也要求数组是有序的</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param arr 数组</span><br><span class="line"> * @param left 左边索引</span><br><span class="line"> * @param right 右边索引</span><br><span class="line"> * @param findVal 查找值</span><br><span class="line"> * @return 如果找到，就返回对应的下标，如果没有找到，返回-1</span><br><span class="line"> */</span><br><span class="line">public static int insertValueSearch(int[] arr, int left, int right, int findVal) &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(&quot;插值查找次数~~&quot;);</span><br><span class="line"></span><br><span class="line">//注意：findVal &lt; arr[0]  和  findVal &gt; arr[arr.length - 1] 必须需要</span><br><span class="line">//否则我们得到的 mid 可能越界</span><br><span class="line">if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1]) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 求出mid, 自适应</span><br><span class="line">int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">int midVal = arr[mid];</span><br><span class="line">if (findVal &gt; midVal) &#123; // 说明应该向右边递归</span><br><span class="line">return insertValueSearch(arr, mid + 1, right, findVal);</span><br><span class="line">&#125; else if (findVal &lt; midVal) &#123; // 说明向左递归查找</span><br><span class="line">return insertValueSearch(arr, left, mid - 1, findVal);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四：斐波那契查找"><a href="#四：斐波那契查找" class="headerlink" title="四：斐波那契查找"></a>四：斐波那契查找</h3><p>1：斐波那契查找思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：斐波那契查找和二分查找也类似，也是在于中值的mid的确定，mid依赖斐波那契数组来实现</span><br><span class="line">2：斐波那契数列1,1,2,3,5,8,13,21,34,55,89...，对应的是取索引需求</span><br><span class="line">3：例如元素组元素个数为10个，因为斐波那契中只有8,13，所有需要创建临时数组长度为13，拷贝原数组，剩余元素用arr[9]填充。</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class FibonacciSearch &#123;</span><br><span class="line"></span><br><span class="line">public static int maxSize = 20;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int [] arr = &#123;1,8, 10, 89, 1000, 1234&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;index=&quot; + fibSearch(arr, 189));// 0</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span><br><span class="line">//非递归方法得到一个斐波那契数列</span><br><span class="line">public static int[] fib() &#123;</span><br><span class="line">int[] f = new int[maxSize];</span><br><span class="line">f[0] = 1;</span><br><span class="line">f[1] = 1;</span><br><span class="line">for (int i = 2; i &lt; maxSize; i++) &#123;</span><br><span class="line">f[i] = f[i - 1] + f[i - 2];</span><br><span class="line">&#125;</span><br><span class="line">return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写斐波那契查找算法</span><br><span class="line">//使用非递归的方式编写算法</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param a  数组</span><br><span class="line"> * @param key 我们需要查找的关键码(值)</span><br><span class="line"> * @return 返回对应的下标，如果没有-1</span><br><span class="line"> */</span><br><span class="line">public static int fibSearch(int[] a, int key) &#123;</span><br><span class="line">int low = 0;</span><br><span class="line">int high = a.length - 1;</span><br><span class="line">int k = 0; //表示斐波那契分割数值的下标</span><br><span class="line">int mid = 0; //存放mid值</span><br><span class="line">int f[] = fib(); //获取到斐波那契数列</span><br><span class="line">//获取到斐波那契分割数值的下标</span><br><span class="line">while(high &gt; f[k] - 1) &#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span><br><span class="line">//不足的部分会使用0填充</span><br><span class="line">int[] temp = Arrays.copyOf(a, f[k]);</span><br><span class="line">//实际上需求使用a数组最后的数填充 temp</span><br><span class="line">//举例:</span><br><span class="line">//temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125;  =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125;</span><br><span class="line">for(int i = high + 1; i &lt; temp.length; i++) &#123;</span><br><span class="line">temp[i] = a[high];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用while来循环处理，找到我们的数 key</span><br><span class="line">while (low &lt;= high) &#123; // 只要这个条件满足，就可以找</span><br><span class="line">mid = low + f[k - 1] - 1;</span><br><span class="line">if(key &lt; temp[mid]) &#123; //我们应该继续向数组的前面查找(左边)</span><br><span class="line">high = mid - 1;</span><br><span class="line">//为甚是 k--</span><br><span class="line">//说明</span><br><span class="line">//1. 全部元素 = 前面的元素 + 后边元素</span><br><span class="line">//2. f[k] = f[k-1] + f[k-2]</span><br><span class="line">//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]</span><br><span class="line">//即 在 f[k-1] 的前面继续查找 k--</span><br><span class="line">//即下次循环 mid = f[k-1-1]-1</span><br><span class="line">k--;</span><br><span class="line">&#125; else if ( key &gt; temp[mid]) &#123; // 我们应该继续向数组的后面查找(右边)</span><br><span class="line">low = mid + 1;</span><br><span class="line">//为什么是k -=2</span><br><span class="line">//说明</span><br><span class="line">//1. 全部元素 = 前面的元素 + 后边元素</span><br><span class="line">//2. f[k] = f[k-1] + f[k-2]</span><br><span class="line">//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]</span><br><span class="line">//4. 即在f[k-2] 的前面进行查找 k -=2</span><br><span class="line">//5. 即下次循环 mid = f[k - 1 - 2] - 1</span><br><span class="line">k -= 2;</span><br><span class="line">&#125; else &#123; //找到</span><br><span class="line">//需要确定，返回的是哪个下标</span><br><span class="line">if(mid &lt;= high) &#123;</span><br><span class="line">return mid;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return high;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：线性查找&quot;&gt;&lt;a href=&quot;#1：线性查找&quot; class=&quot;headerlink&quot; title=&quot;1：线性查找&quot;&gt;&lt;/a&gt;1：线性查找&lt;/h1&gt;&lt;p&gt;1：线性查找思路&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>怎么搭建自己的博客</title>
    <link href="https://yanyubing.xyz/2018/05/20/%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://yanyubing.xyz/2018/05/20/%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2018-05-20T13:46:12.000Z</published>
    <updated>2019-12-01T15:07:10.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h1><p>node.js</p><p>git</p><p>hexo</p><p>github账号</p><p>自己购买的域名</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>网上有很多基于hexo搭建github的博客可供参考：<a href="http://rosesnow.top/" target="_blank" rel="noopener">http://rosesnow.top</a> </p><p>这里主要描述流程和理解，方便遇到问题能够快速找到办法：</p><p>1：node.js是用于npm安装</p><p>2：hexo是本地博客servece</p><p>3：需要把hexo部署到github pages上</p><p>4：通过CNAME文件实现域名的重定向操作，最终实现自己的域名与hexo同步</p><p>5：直接在github上添加CANME文件可以实现一次转发，需要在blog/source目录下创建CNAME文件保证每次有效</p><p>6：最后在更新blog之后hexo  g ; hexo d 同步</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工具准备&quot;&gt;&lt;a href=&quot;#工具准备&quot; class=&quot;headerlink&quot; title=&quot;工具准备&quot;&gt;&lt;/a&gt;工具准备&lt;/h1&gt;&lt;p&gt;node.js&lt;/p&gt;
&lt;p&gt;git&lt;/p&gt;
&lt;p&gt;hexo&lt;/p&gt;
&lt;p&gt;github账号&lt;/p&gt;
&lt;p&gt;自己购买的域名&lt;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>

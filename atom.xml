<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鄢玉兵的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yanyubing.xyz/"/>
  <updated>2019-12-24T10:39:40.476Z</updated>
  <id>https://yanyubing.xyz/</id>
  
  <author>
    <name>鄢玉兵</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AI学习（吴恩达）01—深度学习和神经网络</title>
    <link href="https://yanyubing.xyz/2019/12/24/AI%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%90%B4%E6%81%A9%E8%BE%BE%EF%BC%8901%E2%80%94%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://yanyubing.xyz/2019/12/24/AI%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%90%B4%E6%81%A9%E8%BE%BE%EF%BC%8901%E2%80%94%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2019-12-24T01:25:43.480Z</published>
    <updated>2019-12-24T10:39:40.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度学习和神经网络"><a href="#深度学习和神经网络" class="headerlink" title="深度学习和神经网络"></a>深度学习和神经网络</h1><h3 id="一：深度学习概论"><a href="#一：深度学习概论" class="headerlink" title="一：深度学习概论"></a>一：深度学习概论</h3><p>1：吴恩达简介</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">吴恩达（1976-，英文名：Andrew Ng），华裔美国人，是斯坦福大学计算机科学系和电子工程系副教授，人工智能实验室主任。吴恩达是人工智能和机器学习领域国际上最权威的学者之一。吴恩达也是在线教育平台Coursera的联合创始人（with Daphne Koller）。</span><br><span class="line">网站：https://www.deeplearning.ai</span><br><span class="line">邮箱：feedback@deeplearning.ai</span><br></pre></td></tr></table></figure><p>2：神经网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">神经网路简单看来就是一个函数，通过给定的输入得到&apos;预测&apos;的输出。</span><br><span class="line">例如：拿到了房屋面积和房价的数据集，可以得到房屋面积和放假的拟合曲线，即为一个神经元。</span><br><span class="line">最简单的神经元：Relu，修正线性单元</span><br><span class="line"></span><br><span class="line">多个神经元组成了神经网络。</span><br><span class="line">例如：影响放假的因数可能还有地址，附件学校数量等等...</span><br><span class="line">所有这些因数都会影响最终的房屋价格，即输入x有多个值</span><br><span class="line"></span><br><span class="line">神经网络的工作的工作就是当你完成对应输入时，会给你一个输出结果。中间可能会有隐藏层，即你的输入可能会经过多层才得到最终的输出。只要你给足够多的输入和输出的数据集，神经网络就能足够准确。</span><br></pre></td></tr></table></figure><p>3：深度学习</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">深度学习指的是训练神经网络，有时候规模很大</span><br></pre></td></tr></table></figure><p>4：机器学习应用-监督学习</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目前为止，基本上所有由神经网络创造的经济价值都基于机器学习中的一种，监督学习。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">房价预测：输出价格   标准神经网络</span><br><span class="line">在线广告：输出是否点击广告 标准神经网络</span><br><span class="line">图片识别：输出对象 图像领域CNN（卷积神经网络）</span><br><span class="line">音频识别：输出文本  序列领域RNN（循环神经网络）</span><br><span class="line">在线翻译：输出语言序列领域RNNs（更复杂的循环神经网络）</span><br><span class="line">自动驾驶：其他车辆的位置  混合神经网络（最复杂）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据源分类</span><br><span class="line">结构化数据：数据库</span><br><span class="line">非结构化数据：音频，视频，图片，文本</span><br></pre></td></tr></table></figure><p>5：一个问题，为什么深度学习和人工智能在近几年才兴起？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1：数据量爆炸性增长，传统的分析工具已经无法满足需求</span><br><span class="line">2：需要更大的神经网络来得到更加优秀的模型</span><br><span class="line">3：数据量大和神经网络的性能高是相辅相成</span><br><span class="line">4：神经网络的大不仅仅指的是输入的参数和输入的数据大量（带有标签），还有一点就是中间隐藏层的连接数多</span><br><span class="line">5：想要得到一个优秀的神经网络，在一定程度构建一个大的神经网络和喂食多的输入数据是很好的，同时耗时长</span><br><span class="line">6：在数据集较小的时候，算法的优劣往往取决于手工组件的设计，和细节处理</span><br><span class="line">7：在数据集很大的时候，神经网络的优势往往高于其他方法</span><br><span class="line">8：算法的创新，例如从sigmod函数转换为ReLU函数。sigmod函数的梯度下降在趋近0的时候变得很缓慢，但是转换成ReLU（线性修正单元）之后梯度都为1，使得梯度下降运行速度大大加快。使得可以训练更大的训练单元，同时也可以快速的验证你的神经网络优劣，从而修正。</span><br><span class="line">9：硬件的提升</span><br></pre></td></tr></table></figure><h3 id="二：神经网络基础"><a href="#二：神经网络基础" class="headerlink" title="二：神经网络基础"></a>二：神经网络基础</h3><p>1：二分分类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1：逻辑回归是一个用于二分分类的算法</span><br><span class="line">2：例如：</span><br><span class="line">判断一个图片结果是不是猫？1是，0不是</span><br><span class="line">输入图片是64*64像素，就有三个64*64的矩阵，对应红绿蓝3原色的亮度</span><br><span class="line">特征向量x为对应提取的所有像素的亮度值，该向量的维度是64*64*3</span><br><span class="line">3：相关参数</span><br><span class="line">（x,y）：表示单独样本</span><br><span class="line">x:为n维的特征向量，</span><br><span class="line">y:输出，1或者0</span><br><span class="line">m:训练集的样本数</span><br><span class="line">（x（1），y(1)）表示样本1的输入和输出</span><br><span class="line">（x（m），y(m)）表示样本m的输入和输出</span><br><span class="line">m_train表示训练集样本数</span><br><span class="line">x_test表示测试集样本数</span><br><span class="line">矩阵X=[x1,x2...xm]组成，即X是一个nx*m的矩阵,X.shape=(n*m)</span><br><span class="line">矩阵Y=[y1,y2...ym]组成，即Y使一个1*m的矩阵，Y.shape=(1,m)</span><br><span class="line">4:逻辑回归</span><br><span class="line">输入x（一张图片），输出Y^=P(1|x)（该图片是猫的概率），w是输入x集合中的一个</span><br><span class="line">y^=wTx+b，w的转置乘以x，加上一个常数b（这里采用正则化）</span><br><span class="line">因为y^是一个0-1之间的概率，所有加上sigmod（逻辑回归），y^=σ（wTx+b），</span><br><span class="line">其中σ（z）=1/(1+e^(-z))，主要就是训练参数w和b</span><br></pre></td></tr></table></figure><p>2：逻辑回归损失函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：一般可以将损失函数定义为：L(y^,y)=1/2(y^-y)^2，但是这样会使得损失函数式非凸的，使用梯度下降法之后会得到多个局部最优解，不是全局最优解</span><br><span class="line">2：逻辑回归中一般定义损失函数为：L（y^，y）=-(log(y^)+(1-y)log(1-y^))，同样损失函数越小越好</span><br><span class="line">3：成本函数是基于整个数据集的损失函数，J(w,b)，找到合适的参数w，b使得J（w,b）尽可能的小</span><br></pre></td></tr></table></figure><p>3：梯度下降</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：对于成本函数J（w,b），要求的合适的w,b使得成本函数J（w,b）最小。</span><br><span class="line">2：此时的成本函数式凸函数，只有一个全局最优解，同时也是局部最优解。</span><br><span class="line">3：对于任意初始w,b都能得到最优解</span><br><span class="line">4：梯度下降的思想是从初始点开始，朝着最陡的下坡方向走，走了一次之后会停留在当前的点，此时的w,b都会改变，此时就完成了一次下降的迭代。第二次迭代...，一直到接近全局最优解。</span><br><span class="line">对于w而言，一次更新记作w:=w-∂(dJ(w)/dw),a表示学习率（代表步长）。 对于w,b两个参数而言是一样的逻辑，即求偏导数。代码通常直接用dw和db来表示</span><br></pre></td></tr></table></figure><p>4：导数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">导数是函数的局部性质。一个函数在某一点的导数描述了这个函数在这一点附近的变化率。如果函数的自变量和取值都是实数的话，函数在某一点的导数就是该函数所代表的曲线在这一点上的切线斜率。导数的本质是通过极限的概念对函数进行局部的线性逼近。</span><br></pre></td></tr></table></figure><p>5：计算图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如J(a,b,c)=3(a+bc)</span><br><span class="line">图的步骤为:</span><br><span class="line">1:U=bc       输入为bc</span><br><span class="line">2:V=a+u 输入为a和u</span><br><span class="line">3:J=3V  输入为v</span><br><span class="line">从左到右(1.2.3)的过程就是流程图的正向计算过程，用于计算最终的输出J</span><br><span class="line">dJ/da=(dJ/dV)*(dv/da)=3*1=3，根据了导数的链式法则，这里则是用到了反向传播求导数。在程序中使用dvar来表示dJ对某个中间变量来求导，例如da=3</span><br></pre></td></tr></table></figure><p>6：逻辑回归中的梯度下降</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1：已知数据</span><br><span class="line">偏差为：z=wTx+b</span><br><span class="line">概率为：y^=a=σ（z）=1/(1+e^(-z))</span><br><span class="line">单个样本损失函数为：L(a,y)=-(ylog(a)+(1-y)log(1-a))</span><br><span class="line">假设样本两个特征x1，x2。</span><br><span class="line">使用w1.w2和b：</span><br><span class="line">2：向前传播计算z</span><br><span class="line">输入为w1,x1,w2,x2,b；我们需要计算z=w1*x1+w2*x2+b→y^=a=σ（z）→L(a,y)</span><br><span class="line">w=[w1,w2],x=[x1,x2]所以z=wTx+b=w1*x1+w2*x2+b</span><br><span class="line">3：向后传播计算偏导数</span><br><span class="line">da=dL(a,y)/da=-y/a+(1-y)/(1-a)</span><br><span class="line">dz=dL(a,y)/dz=(dL(a,y)/da)*(da/dz)=a(1-a)*[-y/a+(1-y)/(1-a)]=a-y</span><br><span class="line">dw1</span><br><span class="line">dw1=x1*dz</span><br><span class="line">dw2=x2*dz</span><br><span class="line">db=dz</span><br></pre></td></tr></table></figure><p>7：m个样本的梯度下降</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">成本函数J(w,b)=(1/m)*∑L(a(i),y)  a(i)=y^(i)=σ（z（i））=σ(wTx(i)+b)</span><br><span class="line">对w1求导，d(J(w,b))/dw1=(1/m)*∑[L(a(i),y)/dw1]</span><br><span class="line">用代码操作如下：</span><br><span class="line">J=0,dw1=0,dw2=0,db=0  #作为累加器</span><br><span class="line">for i =1 to m</span><br><span class="line"> z(i)=wTx(i)+b</span><br><span class="line"> a(i)=σ(z(i))</span><br><span class="line"> J+=-[y(i)loga(i)+(1-a)log(1-a(i))]</span><br><span class="line"> dz(i)=a(i)-y(i)</span><br><span class="line"> dw1+=x1(i)dz(i)</span><br><span class="line"> dw2+=x2(i)dz(i)  #这里假设只有两个特征，如果有n个特征，则需要遍历</span><br><span class="line"> db+=dz(i)</span><br><span class="line">#循环结束之后除以样本数m</span><br><span class="line">J/=m #成本函数</span><br><span class="line">dw1/=m #损失函数对w1求导，注意这里是求导之后的累加</span><br><span class="line">dw2/=m  #损失函数对w2求导，同上</span><br><span class="line">#m个样本遍历完成之后需要更新w1和w2</span><br><span class="line">w1:=w1-∂dw1   #∂为学习率</span><br><span class="line">w2:=w2-∂dw2</span><br><span class="line">b:=b-∂db</span><br><span class="line">#到这里完成之后只进行了一次梯度下降，上述过程需要重复完成</span><br></pre></td></tr></table></figure><p>8：向量化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">前面提到了如果需要完成梯度下降代码，则需要2个for循环，外层m次为遍历所有样本数，内层n为遍历所有特征量，使得代码执行效率大大降低。所以引入向量化，大大提高代码的运行效率！</span><br><span class="line">注意：尽量不要在代码中显示的使用for循环，numpy库中有很多的内置函数</span><br><span class="line"></span><br><span class="line">需求：计算z=wTx+b  w和x为1位列向量</span><br><span class="line">使用for循环代码如下：</span><br><span class="line">z=0</span><br><span class="line">for i in rang(n_x) # 效率低</span><br><span class="line">z+=w[i]*x[i]</span><br><span class="line">z+=b</span><br><span class="line"></span><br><span class="line">使用python中的numpy</span><br><span class="line">z=np.dot(w,x)+b  #非常快</span><br><span class="line"></span><br><span class="line">所以前面代码中显示把dw1,dw2置为0可以改为dw=np.Zeros((n_x,1)),</span><br><span class="line">继而求dw1，dw2...的过程就是求dw的过程dw+=x(i)dz(i)</span><br><span class="line">最后dw1/=m,dw2/=m...改为dw/=m</span><br><span class="line">最终，1次梯度下降的整个过程就是对整个训练集遍历了1次，而不需要再遍历特征值</span><br></pre></td></tr></table></figure><p>9：向量化logistic回归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">前面提到，使用向量化可以去除内层对特征值的循环遍历，但是还是会保留对样本数的遍历；这里使用logistic回归同时可以出去对样本数的遍历。</span><br><span class="line">继而训练一次样本都不会使用到for循环！（多么牛皮啊！！）</span><br><span class="line"></span><br><span class="line">m个样本的训练集：</span><br><span class="line">z(1)=wTx(1)+b a(1)=σ（z(1)）</span><br><span class="line">z(2)=wTx(2)+b a(2)=σ（z(2)）</span><br><span class="line">z(3)=wTx(3)+b a(3)=σ（z(3)）</span><br><span class="line">...</span><br><span class="line">z(m)=wTx(m)+b a(m)=σ（z(m)）</span><br><span class="line">然后求和得到z</span><br><span class="line"></span><br><span class="line">优化：</span><br><span class="line">X=[x(1),x(2),x(3)...x(m)]矩阵，为(n_x,m),n为每个样本的特征数据量</span><br><span class="line">1:构建Z矩阵：Z=[z(1),z(2),z(3)...z(m)]</span><br><span class="line">2:Z=wTX+[b,b,b...b]=[wTX(1),wTX(2),wTX(3)...wTX(m)]+[b,b,b...b]=</span><br><span class="line">[z(1),z(2),z(3)...z(m)]</span><br><span class="line">3：代码表示Z=np.dot(w.T,x)+b,python中向量加上常数b，会自动把b转换成（1，m）的向量，这个在python中叫做广播</span><br><span class="line">4：A=σ(Z)=[σ(a(1)),σ(a(2))...σ(a(m))]=[σ(z(1)),σ(z(2)),...σ(z(m))]</span><br><span class="line">5：不需要for循环直接可以得到一次样本数m的所有偏差，或者是损失率</span><br><span class="line">总结：即同一时间可以完成全部的z(i)计算</span><br></pre></td></tr></table></figure><p>10：向量化逻辑回归的梯度输出（一次迭代最终代码实现）</p><p><img src="C:%5CUsers%5Cyanyubing%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20191224174920564.png" alt="image-20191224174920564"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：每进行一次梯度下降都是为了调整w和b</span><br></pre></td></tr></table></figure><p>11：广播（Broadcasting）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深度学习和神经网络&quot;&gt;&lt;a href=&quot;#深度学习和神经网络&quot; class=&quot;headerlink&quot; title=&quot;深度学习和神经网络&quot;&gt;&lt;/a&gt;深度学习和神经网络&lt;/h1&gt;&lt;h3 id=&quot;一：深度学习概论&quot;&gt;&lt;a href=&quot;#一：深度学习概论&quot; class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>AI学习02—实现</title>
    <link href="https://yanyubing.xyz/2019/12/23/AI%E5%AD%A6%E4%B9%A002%E2%80%94%E5%AE%9E%E7%8E%B0/"/>
    <id>https://yanyubing.xyz/2019/12/23/AI%E5%AD%A6%E4%B9%A002%E2%80%94%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-12-23T07:44:07.624Z</published>
    <updated>2019-12-23T11:47:28.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h1><h3 id="1：深度学习简介"><a href="#1：深度学习简介" class="headerlink" title="1：深度学习简介"></a>1：深度学习简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">上一代框架发展（处理的数据量小，逻辑简单）：</span><br><span class="line">强分类：SVM，随机森林</span><br><span class="line">上一代提出了思想，但是无硬件条件支撑，无法得到实现和验证</span><br><span class="line">新一代框架发展（处理数据量大，逻辑复杂）：</span><br><span class="line">深度神经网络依赖于大数据体系:数据量大，结构体系大</span><br><span class="line">硬件的更新：GPU的发展，适合矩阵运算（英伟达，AMD），另外CPU适合于逻辑运算</span><br></pre></td></tr></table></figure><h3 id="2：深度学习发展"><a href="#2：深度学习发展" class="headerlink" title="2：深度学习发展"></a>2：深度学习发展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">前馈神经网络（BP网络）：</span><br><span class="line">增加input尺寸</span><br><span class="line">增加隐层数目</span><br><span class="line">全连接网络</span><br><span class="line">用反向传播解决网络参数</span><br><span class="line">随机梯度下降：随机步长、初始化点多样</span><br></pre></td></tr></table></figure><h3 id="3：深度学习框架"><a href="#3：深度学习框架" class="headerlink" title="3：深度学习框架"></a>3：深度学习框架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TensorFlow:Google</span><br><span class="line">Torch7：facebook</span><br><span class="line">Caffe</span><br><span class="line">Karas</span><br><span class="line">CNTK</span><br><span class="line">MXNet</span><br><span class="line">Theano</span><br><span class="line">Deeplearning4J</span><br></pre></td></tr></table></figure><h3 id="4：TensorFlow"><a href="#4：TensorFlow" class="headerlink" title="4：TensorFlow"></a>4：TensorFlow</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：TensorFlow™ 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。</span><br><span class="line">2：优势：灵活性，可移植性，多语言支持Go，Java，Lua，Javascript，或者是R。</span><br></pre></td></tr></table></figure><h3 id="5：深度学习框架涉及的概念"><a href="#5：深度学习框架涉及的概念" class="headerlink" title="5：深度学习框架涉及的概念"></a>5：深度学习框架涉及的概念</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">人工智能&gt;机器学习&gt;深度学习</span><br><span class="line">人工智能是一个大的概念：图灵测验</span><br><span class="line">机器学习：是实现人工智能的一致方法</span><br><span class="line">深度学习：是实现机器学习的一种技术</span><br><span class="line"></span><br><span class="line">tensor:张量=容器</span><br><span class="line">张量是现代机器学习的基础。它的核心是一个数据容器，多数情况下，它包含数字，有时候它也包含字符串，但这种情况比较少。因此把它想象成一个数字的水桶。</span><br><span class="line">张量有多种形式，首先让我们来看最基本的形式，你会在深度学习中偶然遇到，它们在0维到5维之间。</span><br><span class="line">0维张量/标量；1维张量：数组；2维张量称为矩阵；3维=时间序列；4维=图像；5维=视频</span><br><span class="line"></span><br><span class="line">graph:数据结构，图。从任何一点出发都能走遍所有节点</span><br><span class="line"></span><br><span class="line">constant:常量</span><br><span class="line"></span><br><span class="line">variable:变量</span><br><span class="line">a=tf.variable(x)</span><br><span class="line">其中a是python变量，tf.variable(x)是tf中的变量</span><br><span class="line"></span><br><span class="line">operator: 操作符，tf中内置的操作符，和python中完全不一样</span><br><span class="line"></span><br><span class="line">session：会话，定义图之后创建会话才能操作图</span><br><span class="line"></span><br><span class="line">initalizer：初始化器，一般是参数，模型...的初始化</span><br><span class="line"></span><br><span class="line">optimizer:优化器，其中随机梯度下降SGD就是其中一种优化手段，相当于对图的最后一个节点操作，从而使图动起来，执行流程</span><br><span class="line"></span><br><span class="line">placeholder:占位符，当信息传递到了input之后，占位符常用是从数据源接收数据的作用</span><br><span class="line"></span><br><span class="line">device:CPU或者GPU</span><br><span class="line"></span><br><span class="line">tf.nn：tensorflow.nn模块是tensorflow用于深度学习计算的核心模块</span><br><span class="line"></span><br><span class="line">tf.train：训练模块</span><br><span class="line"></span><br><span class="line">tf.summary：可视化模块</span><br></pre></td></tr></table></figure><h3 id="6：计算机视觉，卷积神经网络cnn"><a href="#6：计算机视觉，卷积神经网络cnn" class="headerlink" title="6：计算机视觉，卷积神经网络cnn"></a>6：计算机视觉，卷积神经网络cnn</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7：语义理解，循环神经网络rnn"><a href="#7：语义理解，循环神经网络rnn" class="headerlink" title="7：语义理解，循环神经网络rnn"></a>7：语义理解，循环神经网络rnn</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;人工智能&quot;&gt;&lt;a href=&quot;#人工智能&quot; class=&quot;headerlink&quot; title=&quot;人工智能&quot;&gt;&lt;/a&gt;人工智能&lt;/h1&gt;&lt;h3 id=&quot;1：深度学习简介&quot;&gt;&lt;a href=&quot;#1：深度学习简介&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>YOLOv3论文翻译</title>
    <link href="https://yanyubing.xyz/2019/12/23/YOLOv3%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    <id>https://yanyubing.xyz/2019/12/23/YOLOv3%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/</id>
    <published>2019-12-23T01:37:10.221Z</published>
    <updated>2019-12-23T01:39:20.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="YOLOv3：增量改进"><a href="#YOLOv3：增量改进" class="headerlink" title="YOLOv3：增量改进"></a>YOLOv3：增量改进</h1><p>概要：</p><p>我们对yolo做了一些更新！我们做了一点改变设计使它变得更加好。同时，也训练了新的网络表现得很好。相比较最后一次而言，这次网络大一点，但是更加准确。别担心，它已经速度很快。320*320的尺寸，yolov3跑完用22ms，并且平均精度为28.2，和SSD（Single Shot MultiBox Detector：单级式目标检测法）比较一样准确，但是速度快3倍。在旧的检测指标.5IOU mAP上来看,yolov3非常优秀。在Titan X（英伟达的显卡）上花费51ms达到了58.9的精度，和RetinaNet（另一种检测模型，花费198ms达到了57.5的精度）比较，效果差不多，但是速度快3.8倍。代码：<a href="https://pjreddie.com/yolo/上。" target="_blank" rel="noopener">https://pjreddie.com/yolo/上。</a></p><p>1：导论</p><p>今年我没有花费很多时间再研究上面，而是偶尔打电话，有部分时间花费在了Twitter上。也研究了一下GANs模型（生成模型与判别模型）。去年我仅剩的一点动力设法去使yolo优化一点。但是，老实说，没有很大的改变，只是一大堆的小地方改变使yolo得到优化。我也希望对其他人的研究提供一点帮助。实际上，我现在要说的是关于yolo进行的随机更新，但是我们没有资源，因此准备了一份技术报告。技术报告的优点在于它不需要简介，你们都知道我在描述什么。在导论的结尾，将会有本论文的目录结构。首先，我们会告诉你yolov3的细节；然后，我们会说一下我们做了哪些尝试；最后，我们总结！</p><p>2：细节</p><p>这里是处理yolov3的细节，我们更多的采纳了来自其他人的好想法。我们还训练了一个新的识别网络，比任何一个都好。我们会从头开始带着你了解整个系统。图1：我们根据“焦点损失”论文更新了该图。在性能可以相比较的情况下，yolov3的运行速度明显快于其他检测方法。在相同GPU的情况下，是M40或者TitanX的几倍。</p><p><img src="file:///C:%5CUsers%5CYANYUB~1%5CAppData%5CLocal%5CTemp%5Cksohtml4396%5Cwps1.jpg" alt="img"> </p><p>2.1：边框预测</p><p>遵循YOLO9000，我们的系统会使用维簇作为锚定框预测边界。网络为每个边界框tx，ty，tw，th预测4个坐标。如果单元格从图像的左上角偏移了（cx，cy）并且先验边界框的宽度和高度为pw，ph，则预测对应于：</p><p><img src="file:///C:%5CUsers%5CYANYUB~1%5CAppData%5CLocal%5CTemp%5Cksohtml4396%5Cwps2.jpg" alt="img"><br>在训练期间，我们使用平方误差损失之和。如果某个坐标预测的真实值为t^<em>，我们的梯度是真实值（从真实值计算得出）减去我们的预测：t^</em> -t*。通过对上面的公式求逆，我们可以轻松求出真实值。Yolov3使用逻辑回归预测每个边界框的客观性得分，如果先验边框与真实值的重叠大于其他先验边界框，那么得分将为1。</p><p><img src="file:///C:%5CUsers%5CYANYUB~1%5CAppData%5CLocal%5CTemp%5Cksohtml4396%5Cwps3.jpg" alt="img"> </p><p>不是最好的，但是确实与真实值重叠超过了某个阈值，我们使用的阈值为0.5。我们系统的不同之处在于，只为每个对象的真实值分配一个边界框，如果没有将先验边界框分配给真实值，则不会对坐标和类别预测造成任何损失，仅仅是客观上的损失。</p><p>2.2：类别预测</p><p>每个边框使用多边框分类预测可能包含的类别。我们不使用sofemax（一种应用于分类的函数），因为我们发现它不需要良好的性能，而是仅使用独立的逻辑分类器。我们在训练期间使用的是二进制交叉熵损失来进行类别预测。</p><p>当我们处理更加复杂如开放图片数据集时，这个公式将更加有帮助。在这个数据集中有很多重叠的标签（如：人和女人）。使用sofemax会假设每个边框只会有一个类，但是通常并非如此。多标签的方法可以更好的对数据建模。</p><p>2.3：多尺度预测</p><p>Yolov3使用了3种不同的尺度预测边框，我们的系统从不同的尺度使用了相似的概念提取特征利用锥形网络。我们添加了几个卷积层在我们的基本特征提取器中。最后一个是预测3维张量编码边界框，对象和种类预测。在我们的实验中使用了COCO，我们在每个维度预测3个边框，因此，因此，对于4个边界框偏移，1个客观预测和80个类预测，张量为N×N×[3 *（4 +1 + 80）]。</p><p>接下来，我们从先前的2层中获取特征图，并将其上采样2倍。 我们还从网络中较早的地方获取了一个特征图，并使用串联将其与我们的上采样特征合并。 这种方法使我们能够从上采样的特征中获取更有意义的语义信息，并从较早的特征图中获取更细粒度的信息。 然后，我们再添加一些卷积层以处理此组合特征图，并最终预测相似的张量，尽管现在的大小是原来的两倍。</p><p>我们再执行一次相同的设计，以预测最终比例的盒子。 因此，我们对第3层的预测受益于所有先前的计算以及网络早期的细粒度功能。</p><p>我们仍然使用k均值聚类来确定先验边界框。我们只是随意选择了9个聚类和3个尺度，然后将这些聚类在各个尺度之间平均分配。在COCO数据集上，有9个聚类是：（10×13），（16×30），（33×23），（30×61），（62×45），（59×119），（116×90），（156×198），（373×326）。</p><p>2.4：特征提取器</p><p>我们使用一个新的网络来执行特征提取。我们的新网络是YOLOv2，Darknet-19中使用的网络与新的残留网络内容之间的一种混合方法。 我们的网络使用了连续的3×3和1×1卷积层，但现在也有了一些快捷连接，并且规模更大。 它有53个卷积层，所以我们称它为….等待它….. Darknet-53！</p><p><img src="file:///C:%5CUsers%5CYANYUB~1%5CAppData%5CLocal%5CTemp%5Cksohtml4396%5Cwps4.jpg" alt="img"> </p><p>这个新网络比Darknet19强大得多，但仍比ResNet-101或ResNet-152高效，下面是结果：</p><p>   <img src="file:///C:%5CUsers%5CYANYUB~1%5CAppData%5CLocal%5CTemp%5Cksohtml4396%5Cwps5.jpg" alt="img"></p><p>每个网络都经过相同设置的训练，并以256×256的单作物精度进行测试。 运行时间是在Titan X上以256×256进行测量的。因此Darknet-53的性能与最新的分类器相当，但浮点运算更少，速度更高。 Darknet-53优于ResNet-101，并且快1.5倍。 Darknet-53具有与ResNet-152相似的性能，并且快2倍。Darknet-53还实现了每秒最高的测量浮点运算。 这意味着网络结构可以更好地利用GPU使评估速度更快，效率更高。这主要是因为ResNets（残差网络）层太多了，效率也不高。</p><p>2.5：训练</p><p>我们仍然会训练完整的图像，而不会进行任何艰苦的负面挖掘。 我们使用多尺度培训，大量数据扩充，批处理规范化以及所有标准内容。我们使用Darknet神经网络框架进行训练和测试。</p><p>3：我们怎么做的</p><p>YOLOv3很好！参见表3。在coco数据集上，平均君度损失与ssd变体相当的时候，速度快3倍。不过，在此指标上，它仍然比其他模型（例如RetinaNet）要落后很多。</p><p><img src="file:///C:%5CUsers%5CYANYUB~1%5CAppData%5CLocal%5CTemp%5Cksohtml4396%5Cwps6.jpg" alt="img"> </p><p>但是，当我们查看“旧的”平均精度损失检测指标IOU = .5（或图表中的AP50）时非常强。 它几乎与RetinaNet相当，并且远远超过SSD变体。这表明YOLOv3是一个非常强大的检测器，擅长为对象制造合适的边框。但是，随着IOU阈值的增加，性能会显着下降，这表明YOLOv3难以使盒子与对象完美对齐。</p><p>过去，YOLO一直在努力处理小物件。 但是，现在我们看到了这种趋势的逆转。 通过新的多尺度预测，我们看到YOLOv3具有相对较高的APS性能。 但是，它在中型和大型对象上的性能相对较差。 要深入了解这一点，还需要进行更多研究。</p><p>当我们在AP50度量标准上绘制精度与速度的关系时（参见图5），我们看到YOLOv3比其他检测系统具有明显的优势。 即更快，更好。</p><p><img src="file:///C:%5CUsers%5CYANYUB~1%5CAppData%5CLocal%5CTemp%5Cksohtml4396%5Cwps7.jpg" alt="img"> </p><p>4：无效的尝试</p><p>在开发YOLOv3时，我们尝试了很多东西。 很多都行不通。 这是我们能记住的东西：</p><p>1.锚框x，y偏移量预测：</p><p>我们尝试使用普通的锚框预测机制，在该机制中，您可以使用线性激活将x，y偏移量预测为框宽度或高度的倍数。 我们发现此公式降低了模型的稳定性，并且效果不佳。</p><p>2.线性x，y预测而不是逻辑预测：</p><p>我们尝试使用线性激活来直接预测x，y偏移量，而不是逻辑激活。 这导致mAP下降了两点。</p><p>3.失焦：</p><p>我们尝试使用焦点损失。 它降低了我们的mAP大约2点。 YOLOv3可能已经对焦点损失试图解决的问题具有鲁棒性，因为它具有独立的客观性预测和条件类预测。 因此，对于大多数示例而言，分类预测不会带来损失吗？ 或者其他的东西？ 我们不太确定。</p><p><img src="file:///C:%5CUsers%5CYANYUB~1%5CAppData%5CLocal%5CTemp%5Cksohtml4396%5Cwps8.jpg" alt="img"> </p><p><img src="file:///C:%5CUsers%5CYANYUB~1%5CAppData%5CLocal%5CTemp%5Cksohtml4396%5Cwps9.jpg" alt="img"> </p><p>4.双IOU阈值和真值分配:</p><p>更快的RCNN在训练期间使用两个IOU阈值。 如果预测与基本事实的重叠为0.7，则为正例；由[.3-.7]进行的预测将被忽略；对于所有基本真实对象，小于0.3则为负例。 我们尝试了类似的策略，但未取得良好的效果。</p><p>我们非常喜欢我们目前的表述，似乎至少是局部最优。 这些技术中的某些可能最终会产生良好的结果，也许它们只需要进行一些调整即可稳定训练。</p><p>5：总结</p><p>YOLOv3是一个很好的检测器。 快速，准确。 在.5至.95 IOU度量标准之间的COCO平均精度损失效果不佳。 但是，对于.5 IOU的旧检测指标而言，这非常好。</p><p>为什么我们仍要转换指标？原始的COCO论文只是这样一个含糊的句子：“评估服务器完成后，将添加对评估指标的完整讨论”。 Russakovsky等人的报告指出，人类很难区分.3和.5的IOU。</p><p>“令人惊讶的是，培训人员视觉检查IOU为0.3的边界框并将其与IOU为0.5的边界框区别开来是非常困难的。”如果人类很难分辨出差异，那么这有多重要？</p><p>但是也许更好的问题是：“既然有了探测器，我们将如何处理这些探测器？”许多从事这项研究的人都在Google和Facebook上。我想至少我们知道该技术掌握得很好，并且绝对不会被用来收集您的个人信息并将其出售给…。等等，您是在说这正是它的用途？？ 哦。好吧，那些为视觉研究投入大量资金的人是军队，他们从来没有做过任何可怕的事情，例如用新技术杀死许多人，等等。</p><p>我非常希望大多数使用计算机视觉的人都在用它做快乐的好事，例如计算国家公园中斑马的数量[13]或在猫徘徊在房子周围时追踪它们的猫。 但是计算机视觉已经被质疑使用，作为研究人员，我们有责任至少考虑我们的工作可能造成的危害并想办法减轻它。 我们欠世界那么多。 最后，不要@我。 （因为我终于退出了Twitter）。</p><p><img src="file:///C:%5CUsers%5CYANYUB~1%5CAppData%5CLocal%5CTemp%5Cksohtml4396%5Cwps10.jpg" alt="img"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;YOLOv3：增量改进&quot;&gt;&lt;a href=&quot;#YOLOv3：增量改进&quot; class=&quot;headerlink&quot; title=&quot;YOLOv3：增量改进&quot;&gt;&lt;/a&gt;YOLOv3：增量改进&lt;/h1&gt;&lt;p&gt;概要：&lt;/p&gt;
&lt;p&gt;我们对yolo做了一些更新！我们做了一点改变设
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>AI学习01—入门</title>
    <link href="https://yanyubing.xyz/2019/12/23/AI%E5%AD%A6%E4%B9%A001%E2%80%94%E5%85%A5%E9%97%A8/"/>
    <id>https://yanyubing.xyz/2019/12/23/AI%E5%AD%A6%E4%B9%A001%E2%80%94%E5%85%A5%E9%97%A8/</id>
    <published>2019-12-23T01:32:45.487Z</published>
    <updated>2019-12-23T07:43:16.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h1><h3 id="1：所需基本知识"><a href="#1：所需基本知识" class="headerlink" title="1：所需基本知识"></a>1：所需基本知识</h3><p>高数：线性代数，概率论，向量，函数，导数…</p><h3 id="2：机器学习基础"><a href="#2：机器学习基础" class="headerlink" title="2：机器学习基础"></a>2：机器学习基础</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：机器学习主要是研究计算机从给定数据中学习规律，并利用学习到的规律（模型）来对未知或无法观测的数据进行预测。</span><br><span class="line">2：简单说来就是模型如何构建（函数），接收输入，给出尽量准确的输出。</span><br></pre></td></tr></table></figure><h3 id="3：机器学习分类"><a href="#3：机器学习分类" class="headerlink" title="3：机器学习分类"></a>3：机器学习分类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">从学习方法上讲，分为：</span><br><span class="line">监督学习（主流，识别，标注）</span><br><span class="line">无监督学习（聚类）</span><br><span class="line">半监督学习</span><br><span class="line">强化学习（阿尔法狗）</span><br><span class="line"></span><br><span class="line">从学习结果上来讲，分为：</span><br><span class="line">回归</span><br><span class="line">分类</span><br></pre></td></tr></table></figure><h3 id="4：线性回归模型"><a href="#4：线性回归模型" class="headerlink" title="4：线性回归模型"></a>4：线性回归模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1：数据模型成线性变化y=ax+b</span><br><span class="line">2：通过拟合得到a和b，即得到最终的模型</span><br><span class="line">3：具体拟合过程为:求出所有已知点到该线性模型距离合的最小值，最小二乘法</span><br><span class="line">4：训练集，作用就是已知的学习数据</span><br><span class="line">5：测试集，用来检测模型，有交叉验证法（分段平均取出训练集中的部分数据）和自助法等</span><br><span class="line">6：损失函数（Loss Function ）是定义在单个样本上的，算的是一个样本的误差。</span><br><span class="line">7：代价函数（Cost Function ）是定义在整个训练集上的，是所有样本误差的平均，也就是损失函数的平均。</span><br><span class="line">8：目标函数（Object Function）定义为：最终需要优化的函数。等于经验风险+结构风险（也就是Cost Function + 正则化项）。</span><br><span class="line">9：拟合，过拟合和欠拟合。一般来讲正常拟合最优，过拟合指的是曲线经过所有点（问题在于这个数据可能本来就存在隐形误差），欠拟合是值用直线模型去拟合曲线数据。评估又人为控制，对应参数调整！</span><br><span class="line">10：准确率和泛化性能</span><br><span class="line">11：高斯分布（正态分布），中间概率最大，两头概率小</span><br><span class="line">12：随机梯度下降法（SGD），使用批处理平均来进行梯度更新，1个batch完成之后更新参数值</span><br><span class="line">13：最终是找到目标函数的极小值</span><br><span class="line">14：线性回归对误差点比较难已处理，可能会因为单个误差点影响整个模型的真实性，即单个误差点的损失函数比其他点正常点的损失函数合还大。所以线性回归对数据的预处理要求高</span><br></pre></td></tr></table></figure><h3 id="5：指标"><a href="#5：指标" class="headerlink" title="5：指标"></a>5：指标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：accuracy指的是正确预测的样本数占总预测样本数的比值，它不考虑预测的样本是正例还是负例。</span><br><span class="line">2：precision指的是正确预测的正样本数占所有预测为正样本的数量的比值，也就是说所有预测为正样本的样本中有多少是真正的正样本。从这我们可以看出，precision只关注预测为正样本的部分，而accuracy考虑全部样本。</span><br><span class="line">3：Recall可以称为召回率、查全率等等...我们也不考究如何翻译它，它指的是正确预测的正样本数占真实正样本总数的比值，也就是我能从这些样本中能够正确找出多少个正样本。</span><br><span class="line">4：F-score相当于precision和recall的调和平均，用意是要参考两个指标。从公式我们可以看出，recall和precision任何一个数值减小，F-score都会减小，反之，亦然。</span><br><span class="line">5：specificity指标平时见得不多，它是相对于sensitivity（recall）而言的，指的是正确预测的负样本数占真实负样本总数的比值，也就是我能从这些样本中能够正确找出多少个负样本。</span><br><span class="line"></span><br><span class="line">总结：一般p和r不可以同时最优，Precision 会随着R ecall的升高而降低, 两者不可兼得。一般来讲使用调和平均数来确定1/p+1/r</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">【实例说明】</span><br><span class="line">问题：假设某个学校有1000个王者荣耀玩家，其中有10个是王者段位，判断这个玩家是不是王者选手？</span><br><span class="line"></span><br><span class="line">现在我有一个分类器，检测出来有20个王者选手，其中包含5个真正的王者选手。那么上述指标该如何计算呢？</span><br><span class="line"></span><br><span class="line">分析：检测出来有20个王者选手，说明有980个选手被预测为非王者选手。这20个检测为王者选手包含5个真正的王者选手，说明另外15个实际为非王者选手，所以，</span><br><span class="line"></span><br><span class="line">accuracy = (5+980-5) / 1000 = 0.98</span><br><span class="line"></span><br><span class="line">precision = 5 / 20 = 0.25</span><br><span class="line"></span><br><span class="line">recall = 5 / 10 = 0.5</span><br><span class="line"></span><br><span class="line">F-score = 2 / (1/0.25 + 1/0.5) = 0.33</span><br><span class="line"></span><br><span class="line">sensitivity = recall = 0.5</span><br><span class="line"></span><br><span class="line">specificity = (980-5) / (1000-10) = 0.98</span><br><span class="line"></span><br><span class="line">从这个案例我们可以发现，虽然分类器的accuracy可以达到98%，但是如果我的目的是尽可能的找出隐藏在这1000人中的王者选手，那么这个分类器的性能是不达标的，这也就是为什么要引入precision和recall以及F-score评价指标的原因。</span><br></pre></td></tr></table></figure><h3 id="6：逻辑回归"><a href="#6：逻辑回归" class="headerlink" title="6：逻辑回归"></a>6：逻辑回归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logistic回归目的是从特征学习出一个0/1分类模型，而这个模型是将特性的线性组合作为自变量，由于自变量的取值范围是负无穷到正无穷。</span><br><span class="line">因此，使用logistic函数（或称作sigmoid函数）将自变量映射到(0,1)上，映射后的值被认为是属于y=1的概率。</span><br></pre></td></tr></table></figure><h3 id="7：svm-核方法（kernel）"><a href="#7：svm-核方法（kernel）" class="headerlink" title="7：svm-核方法（kernel）"></a>7：svm-核方法（kernel）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单来说是二维到三维空间转换的一种解决问题的方式</span><br></pre></td></tr></table></figure><h3 id="8：决策树"><a href="#8：决策树" class="headerlink" title="8：决策树"></a>8：决策树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">决策树(Decision Tree）是在已知各种情况发生概率的基础上，通过构成决策树来求取净现值的期望值大于等于零的概率，评价项目风险，判断其可行性的决策分析方法，是直观运用概率分析的一种图解法。由于这种决策分支画成图形很像一棵树的枝干，故称决策树。在机器学习中，决策树是一个预测模型，他代表的是对象属性与对象值之间的一种映射关系。Entropy = 系统的凌乱程度，使用算法ID3, C4.5和C5.0生成树算法使用熵。这一度量是基于信息学理论中熵的概念。</span><br><span class="line"></span><br><span class="line">最优的是找到最优特征与结果匹配。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">信息熵：S=-P(X)lnP(x)</span><br><span class="line">表征了信息不确定性的程度</span><br><span class="line">分类属性应当以最高熵减为标准进行</span><br></pre></td></tr></table></figure><h3 id="9：随机森林"><a href="#9：随机森林" class="headerlink" title="9：随机森林"></a>9：随机森林</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：数据集的随机选取</span><br><span class="line">2：待选特征的随机选取，即会有丢弃特征</span><br><span class="line">3：决策树的优化</span><br><span class="line">4：结果由多个决策树共同投票决定</span><br></pre></td></tr></table></figure><h3 id="10：朴素贝叶斯文本分类"><a href="#10：朴素贝叶斯文本分类" class="headerlink" title="10：朴素贝叶斯文本分类"></a>10：朴素贝叶斯文本分类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">应用：</span><br><span class="line">1.给文章确定分类，主题，流派</span><br><span class="line">2.垃圾文本检测</span><br><span class="line">3.原创鉴定</span><br><span class="line">4.年龄，性别鉴定</span><br><span class="line">5.语言鉴定</span><br><span class="line">6.情感分析</span><br><span class="line"></span><br><span class="line">基于贝叶斯规则的简单分类方法</span><br><span class="line">依赖于简单的文本表示——词袋模型</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;人工智能&quot;&gt;&lt;a href=&quot;#人工智能&quot; class=&quot;headerlink&quot; title=&quot;人工智能&quot;&gt;&lt;/a&gt;人工智能&lt;/h1&gt;&lt;h3 id=&quot;1：所需基本知识&quot;&gt;&lt;a href=&quot;#1：所需基本知识&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>YOLOv3</title>
    <link href="https://yanyubing.xyz/2019/12/23/YOLOv3/"/>
    <id>https://yanyubing.xyz/2019/12/23/YOLOv3/</id>
    <published>2019-12-23T01:31:34.370Z</published>
    <updated>2019-12-23T01:31:34.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yoloV3从零实现-深度学习"><a href="#yoloV3从零实现-深度学习" class="headerlink" title="yoloV3从零实现-深度学习"></a>yoloV3从零实现-深度学习</h1><p>基于 <a href="https://github.com/ultralytics/yolov3" target="_blank" rel="noopener">https://github.com/ultralytics/yolov3</a> </p><h3 id="1：环境搭建"><a href="#1：环境搭建" class="headerlink" title="1：环境搭建"></a>1：环境搭建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">操作系统环境windows10，需要查看对应的cuda版本</span><br><span class="line">1：控制面板</span><br><span class="line">2：NVIDIA控制面板</span><br><span class="line">3：帮助-系统信息-组件 NVCUDA==10.1.120</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python环境</span><br><span class="line">1：需求是3.5以上，本公司安装3.7</span><br><span class="line">2：配置Python环境变量</span><br><span class="line">3：在cmd中输入python可以进入编辑模式确定成功</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开发工具Pycharm</span><br><span class="line">1：选择最新版本2019.3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Visual Studio</span><br><span class="line">1：选择2017版本，同时需要安装C++模块</span><br><span class="line">2：在安装cuda时，需要提前装好VS</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cuda</span><br><span class="line">1：版本与windows系统cuda版本保持一致10.1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudnn</span><br><span class="line">1:cudnn版本根据cuda版本确定</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip  conda库 安装pytorch</span><br><span class="line">1：使用pip的方式安装对应版本</span><br><span class="line">2：使用conda的方式安装对应版本</span><br><span class="line">3：最终选择的是pip方式安装cuda10.1，pytoch版本为1.3.1（这里不知道为什么安装一致版本不行）</span><br></pre></td></tr></table></figure><h3 id="2：相关组件详解"><a href="#2：相关组件详解" class="headerlink" title="2：相关组件详解"></a>2：相关组件详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">train.py:训练代码</span><br><span class="line">训练的输入，输出是什么？需要哪些配置参数</span><br><span class="line"></span><br><span class="line">test.py:测试代码</span><br><span class="line">测试的输入输出是什么？需要哪些参数</span><br><span class="line"></span><br><span class="line">detect.py:具体实现的代码</span><br><span class="line">实现之后反馈的形式是什么？需要哪些参数</span><br><span class="line"></span><br><span class="line">models.py：模型</span><br><span class="line">具体使用到了哪些模型</span><br></pre></td></tr></table></figure><h3 id="3：文件详解"><a href="#3：文件详解" class="headerlink" title="3：文件详解"></a>3：文件详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/cfg     配置文件夹，与weights文件一起组合成不同的参数</span><br><span class="line">/weights 权重文件夹，与cfg文件一起合成不同的参数；其中.pt结尾的就是组合之后的一个成体文件</span><br><span class="line">/data    数据文件，包含获取coco数据集的脚本文件；一些kv对应的参数文件;/samples文件夹底下存放的是detect.py执行的检测文件</span><br><span class="line">/images  自己创建，用来存放需要训练coco2014数据集的图片文件train2014.zip val2014.zip</span><br><span class="line">/output  执行detect.py之后生成的文件夹，存放的图片被标注</span><br><span class="line">/utils   存放的函数工具类</span><br><span class="line">requirements.txt  需要准备的环境文件</span><br></pre></td></tr></table></figure><h3 id="4：代码详解"><a href="#4：代码详解" class="headerlink" title="4：代码详解"></a>4：代码详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5：优化"><a href="#5：优化" class="headerlink" title="5：优化"></a>5：优化</h3><h3 id="6：产品实现"><a href="#6：产品实现" class="headerlink" title="6：产品实现"></a>6：产品实现</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;yoloV3从零实现-深度学习&quot;&gt;&lt;a href=&quot;#yoloV3从零实现-深度学习&quot; class=&quot;headerlink&quot; title=&quot;yoloV3从零实现-深度学习&quot;&gt;&lt;/a&gt;yoloV3从零实现-深度学习&lt;/h1&gt;&lt;p&gt;基于 &lt;a href=&quot;https:
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>深度学习-YOLOv3</title>
    <link href="https://yanyubing.xyz/2019/12/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-YOLOv3/"/>
    <id>https://yanyubing.xyz/2019/12/13/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-YOLOv3/</id>
    <published>2019-12-13T01:20:37.398Z</published>
    <updated>2019-12-23T01:32:24.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度学习-YOLOv3"><a href="#深度学习-YOLOv3" class="headerlink" title="深度学习-YOLOv3"></a>深度学习-YOLOv3</h1><p>基于 <a href="https://github.com/ultralytics/yolov3" target="_blank" rel="noopener">https://github.com/ultralytics/yolov3</a> </p><h3 id="1：环境搭建"><a href="#1：环境搭建" class="headerlink" title="1：环境搭建"></a>1：环境搭建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">操作系统环境windows10，需要查看对应的cuda版本</span><br><span class="line">1：控制面板</span><br><span class="line">2：NVIDIA控制面板</span><br><span class="line">3：帮助-系统信息-组件 NVCUDA==10.1.120</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python环境</span><br><span class="line">1：需求是3.5以上，本公司安装3.7</span><br><span class="line">2：配置Python环境变量</span><br><span class="line">3：在cmd中输入python可以进入编辑模式确定成功</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开发工具Pycharm</span><br><span class="line">1：选择最新版本2019.3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Visual Studio</span><br><span class="line">1：选择2017版本，同时需要安装C++模块</span><br><span class="line">2：在安装cuda时，需要提前装好VS</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cuda</span><br><span class="line">1：版本与windows系统cuda版本保持一致10.1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cudnn</span><br><span class="line">1:cudnn版本根据cuda版本确定</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip  conda库 安装pytorch</span><br><span class="line">1：使用pip的方式安装对应版本</span><br><span class="line">2：使用conda的方式安装对应版本</span><br><span class="line">3：最终选择的是pip方式安装cuda10.1，pytoch版本为1.3.1（这里不知道为什么安装一致版本不行）</span><br></pre></td></tr></table></figure><h3 id="2：相关组件详解"><a href="#2：相关组件详解" class="headerlink" title="2：相关组件详解"></a>2：相关组件详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">train.py:训练代码</span><br><span class="line">训练的输入，输出是什么？需要哪些配置参数</span><br><span class="line"></span><br><span class="line">test.py:测试代码</span><br><span class="line">测试的输入输出是什么？需要哪些参数</span><br><span class="line"></span><br><span class="line">detect.py:具体实现的代码</span><br><span class="line">实现之后反馈的形式是什么？需要哪些参数</span><br><span class="line"></span><br><span class="line">models.py：模型</span><br><span class="line">具体使用到了哪些模型</span><br></pre></td></tr></table></figure><h3 id="3：文件详解"><a href="#3：文件详解" class="headerlink" title="3：文件详解"></a>3：文件详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/cfg     配置文件夹，与weights文件一起组合成不同的参数</span><br><span class="line">/weights 权重文件夹，与cfg文件一起合成不同的参数；其中.pt结尾的就是组合之后的一个成体文件</span><br><span class="line">/data    数据文件，包含获取coco数据集的脚本文件；一些kv对应的参数文件;/samples文件夹底下存放的是detect.py执行的检测文件</span><br><span class="line">/images  自己创建，用来存放需要训练coco2014数据集的图片文件train2014.zip val2014.zip</span><br><span class="line">/output  执行detect.py之后生成的文件夹，存放的图片被标注</span><br><span class="line">/utils   存放的函数工具类</span><br><span class="line">requirements.txt  需要准备的环境文件</span><br></pre></td></tr></table></figure><h3 id="4：代码详解"><a href="#4：代码详解" class="headerlink" title="4：代码详解"></a>4：代码详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5：优化"><a href="#5：优化" class="headerlink" title="5：优化"></a>5：优化</h3><h3 id="6：产品实现"><a href="#6：产品实现" class="headerlink" title="6：产品实现"></a>6：产品实现</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深度学习-YOLOv3&quot;&gt;&lt;a href=&quot;#深度学习-YOLOv3&quot; class=&quot;headerlink&quot; title=&quot;深度学习-YOLOv3&quot;&gt;&lt;/a&gt;深度学习-YOLOv3&lt;/h1&gt;&lt;p&gt;基于 &lt;a href=&quot;https://github.com/ult
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>离线数仓-系统业务数据仓库总结</title>
    <link href="https://yanyubing.xyz/2019/12/07/%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93-%E7%B3%BB%E7%BB%9F%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%80%BB%E7%BB%93/"/>
    <id>https://yanyubing.xyz/2019/12/07/%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93-%E7%B3%BB%E7%BB%9F%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-07T14:44:51.475Z</published>
    <updated>2019-12-07T15:39:07.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：离线数仓-系统业务数据仓库总结"><a href="#1：离线数仓-系统业务数据仓库总结" class="headerlink" title="1：离线数仓-系统业务数据仓库总结"></a>1：离线数仓-系统业务数据仓库总结</h1><p>1：表的分类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">实体表：</span><br><span class="line">实体表，一般是指一个现实存在的业务对象，比如用户，商品，商家，销售员等</span><br><span class="line"></span><br><span class="line">维度表：</span><br><span class="line">维度表，一般是指对应一些业务状态，编号的解释表。也可以称之为码表。</span><br><span class="line">比如地区表，订单状态，支付方式，审批状态，商品分类等等。</span><br><span class="line"></span><br><span class="line">事务型事实表：</span><br><span class="line">事务型事实表，一般指随着业务发生不断产生的数据。特点是一旦发生不会再变化。</span><br><span class="line">一般比如，交易流水，操作日志，出库入库记录等等。</span><br><span class="line"></span><br><span class="line">周期型事实表：</span><br><span class="line">周期型事实表，一般指随着业务发生不断产生的数据。</span><br><span class="line">与事务型不同的是，数据会随着业务周期性的推进而变化。</span><br><span class="line">比如订单，其中订单状态会周期性变化。再比如，请假、贷款申请，随着批复状态在周期性变化。</span><br><span class="line"> </span><br><span class="line">总结：把表分类别是为了更好的管理表。</span><br></pre></td></tr></table></figure><p>2：同步策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据同步策略的类型包括：全量表、增量表、新增及变化表、拉链表</span><br><span class="line">全量表：存储完整的数据。</span><br><span class="line">增量表：存储新增加的数据。</span><br><span class="line">新增及变化表：存储新增加的数据和变化的数据。</span><br><span class="line">拉链表：对新增及变化表做定期合并。</span><br><span class="line"></span><br><span class="line">总结：除去实际需求做全量或者增量之外，一般来说数据量小的可以做全量；数据量大，且不会变化的做增量。</span><br></pre></td></tr></table></figure><p>3：实体表同步策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实体表：比如用户，商品，商家，销售员等</span><br><span class="line">实体表数据量比较小：通常可以做每日全量，就是每天存一份完整数据。即每日全量。</span><br></pre></td></tr></table></figure><p>4：维度表同步策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">维度表：比如订单状态，审批状态，商品分类</span><br><span class="line">维度表数据量比较小：通常可以做每日全量，就是每天存一份完整数据。即每日全量。</span><br><span class="line">说明：</span><br><span class="line">1）针对可能会有变化的状态数据可以存储每日全量。</span><br><span class="line">2）没变化的客观世界的维度（比如性别，地区，民族，政治成分，鞋子尺码）可以只存一份固定值。</span><br></pre></td></tr></table></figure><p>5：事务型事实表同步策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">事务型事实表：比如，交易流水，操作日志，出库入库记录等。</span><br><span class="line">因为数据不会变化，而且数据量巨大，所以每天只同步新增数据即可，所以可以做成每日增量表，即每日创建一个分区存储。</span><br></pre></td></tr></table></figure><p>6：周期型事实表同步策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">周期型事实表：比如，订单、请假、贷款申请等</span><br><span class="line">这类表从数据量的角度，存每日全量的话，数据量太大，冗余也太大。如果用每日增量的话无法反应数据变化。</span><br><span class="line"> 每日新增及变化量，包括了当日的新增和修改。一般来说这个表，足够计算大部分当日数据的。但是这种依然无法解决能够得到某一个历史时间点（时间切片）的切片数据。 </span><br><span class="line"> 所以要用利用每日新增和变化表，制作一张拉链表，以方便的取到某个时间切片的快照数据。所以我们需要得到每日新增及变化量。</span><br></pre></td></tr></table></figure><p>7：范式理论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">关系型数据库设计时，遵照一定的规范要求，目的在于降低数据的冗余性，目前业界范式有：第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)、第五范式(5NF)。</span><br><span class="line">范式可以理解为一张数据表的表结构，符合的设计标准的级别。</span><br><span class="line"> 使用范式的根本目的是：</span><br><span class="line">  1）减少数据冗余，尽量让每个数据只出现一次。</span><br><span class="line">  2）保证数据一致性</span><br><span class="line"> 缺点是获取数据时，需要通过Join拼接出最后的数据。</span><br></pre></td></tr></table></figure><p>8：函数依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">在关系模式R(U)中，对于U的子集X和Y，</span><br><span class="line"></span><br><span class="line">1.如果 X → Y，但 Y 不为 X 的子集，则称 X → Y 是非平凡的函数依赖</span><br><span class="line">例：在关系SC(Sno, Cno, Grade)中，</span><br><span class="line">非平凡函数依赖： (Sno, Cno) → Grade。</span><br><span class="line"></span><br><span class="line">2.若 X → Y，但 Y 为 X 的子集, 则称 X → Y 是平凡的函数依赖</span><br><span class="line">平凡函数依赖： (Sno, Cno) → Sno ，(Sno, Cno) → Cno。</span><br><span class="line"></span><br><span class="line">3.若 x → y 并且，存在 x 的真子集 x1，使得 x1 → y, 则 y 部分依赖于 x。</span><br><span class="line">例：学生表（学号，姓名，性别，班级，年龄）关系中，</span><br><span class="line">部分函数依赖：（学号，姓名）→ 性别，学号 → 性别，所以（学号，姓名）→ 性别 是部分函数依赖。</span><br><span class="line"></span><br><span class="line">4.若 x → y 并且，对于 x 的任何一个真子集 x1，都不存在 x1 → y 则称y完全依赖于x。</span><br><span class="line">例：成绩表（学号，课程号，成绩）关系中，</span><br><span class="line">完全函数依赖：（学号，课程号）→ 成绩，学号 －\→ 成绩，课程号 －\→ 成绩，所以（学号，课程号）→ 成绩 是完全函数依赖。</span><br><span class="line"></span><br><span class="line">5.若x → y并且y → z，而y －\→ x，则有x → z，称这种函数依赖为传递函数依赖。</span><br><span class="line">例：关系S1（学号，系名，系主任），</span><br><span class="line">学号 → 系名，系名 → 系主任，并且系名 －\→ 学号，系主任 －\→ 系名，所以学号 → 系主任为传递函数依赖。</span><br></pre></td></tr></table></figure><p>9：范式原则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：第一范式1NF核心原则是：属性不可分割</span><br><span class="line">2：</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：离线数仓-系统业务数据仓库总结&quot;&gt;&lt;a href=&quot;#1：离线数仓-系统业务数据仓库总结&quot; class=&quot;headerlink&quot; title=&quot;1：离线数仓-系统业务数据仓库总结&quot;&gt;&lt;/a&gt;1：离线数仓-系统业务数据仓库总结&lt;/h1&gt;&lt;p&gt;1：表的分类&lt;/p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>离线数仓-用户行为数仓分层搭建总结</title>
    <link href="https://yanyubing.xyz/2019/12/06/%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93-%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%95%B0%E4%BB%93%E5%88%86%E5%B1%82%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/"/>
    <id>https://yanyubing.xyz/2019/12/06/%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93-%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%95%B0%E4%BB%93%E5%88%86%E5%B1%82%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-06T08:25:22.810Z</published>
    <updated>2019-12-07T14:22:41.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：离线数仓-用户行为数仓分层搭建总结"><a href="#1：离线数仓-用户行为数仓分层搭建总结" class="headerlink" title="1：离线数仓-用户行为数仓分层搭建总结"></a>1：离线数仓-用户行为数仓分层搭建总结</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数仓理论书籍：《hadoop构建数据仓库实践》-王雪迎 《数据仓库第四版》-William H.Inmon</span><br></pre></td></tr></table></figure><p>1：数仓分层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ODS层：原始数据层，直接加载日志，数据，不做处理</span><br><span class="line">DWD层：结构和粒度和原表保持一致，对ODS层数据进行清洗（去除空置，脏数据，超过极限范围的数据）</span><br><span class="line">DWS层：以DWD为基础，进行轻度汇总，开始以某一个维度为线索，产生跨主题的多个宽表</span><br><span class="line">ADS层：展示数据，为各种报表系统提供数据</span><br></pre></td></tr></table></figure><p>2：为什么要分层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：把一个复杂的问题简单化 ，每一层只处理单一的步骤，比较简单，并且方便定位问题</span><br><span class="line">2：减少重复开发，通过中间层数据，能够减少极大的重复计算，增加一次计算结果的复用性</span><br><span class="line">3：隔离原始数据，使真实数据合统计数据解耦</span><br></pre></td></tr></table></figure><p>3：数据集市和数据仓库概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：数据集市一般指的部门级别的数据整合</span><br><span class="line">2：数据仓库是企业级别的</span><br></pre></td></tr></table></figure><p>4：Hive运行引擎Tez</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tez可以将多个有依赖的作业转换为一个作业，这样只需写一次HDFS，且中间节点较少，从而大大提升作业的计算性能。</span><br></pre></td></tr></table></figure><p>5：shell中单引号和双引号的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）单引号不取变量值</span><br><span class="line">（2）双引号取变量值</span><br><span class="line">（3）反引号`，执行引号中命令</span><br><span class="line">（4）双引号内部嵌套单引号，取出变量值</span><br><span class="line">（5）单引号内部嵌套双引号，不取出变量值</span><br></pre></td></tr></table></figure><p>6： Hive和数据库比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Hive 和数据库除了拥有类似的查询语言，再无类似之处。</span><br><span class="line">1）数据存储位置</span><br><span class="line">Hive 存储在 HDFS 。数据库将数据保存在块设备或者本地文件系统中。</span><br><span class="line"></span><br><span class="line">2）数据更新</span><br><span class="line">Hive中不建议对数据的改写。而数据库中的数据通常是需要经常进行修改的， </span><br><span class="line"></span><br><span class="line">3）执行延迟</span><br><span class="line">Hive 执行延迟较高。数据库的执行延迟较低。当然，这个是有条件的，即数据规模较小，当数据规模大到超过数据库的处理能力的时候，Hive的并行计算显然能体现出优势。</span><br><span class="line"></span><br><span class="line">4）数据规模</span><br><span class="line">Hive支持很大规模的数据计算；数据库可以支持的数据规模较小。</span><br></pre></td></tr></table></figure><p>7：内部表和外部表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）管理表：当我们删除一个管理表时，Hive也会删除这个表中数据。管理表不适合和其他工具共享数据。</span><br><span class="line">2）外部表：删除该表并不会删除掉原始数据，删除的是表的元数据</span><br><span class="line"></span><br><span class="line">一般数据使用外部表储存，保证数据安全性；临时表或者备份表使用内部表，避免数据的积压。</span><br></pre></td></tr></table></figure><p>8：4个By区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）Sort By：分区内有序；</span><br><span class="line">2）Order By：全局排序，只有一个Reducer；</span><br><span class="line">3）Distrbute By：类似MR中Partition，进行分区，结合sort by使用。</span><br><span class="line">4）Cluster By：当Distribute by和Sorts by字段相同时，可以使用Cluster by方式。Cluster by除了具有Distribute by的功能外还兼具Sort by的功能。但是排序只能是升序排序，不能指定排序规则为ASC或者DESC。</span><br></pre></td></tr></table></figure><p>9：窗口函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1） OVER()：指定分析函数工作的数据窗口大小，这个数据窗口大小可能会随着行的变而变化</span><br><span class="line">2）CURRENT ROW：当前行</span><br><span class="line">3）n PRECEDING：往前n行数据</span><br><span class="line">4） n FOLLOWING：往后n行数据</span><br><span class="line">5）UNBOUNDED：起点，UNBOUNDED PRECEDING 表示从前面的起点， UNBOUNDED FOLLOWING表示到后面的终点</span><br><span class="line">6） LAG(col,n)：往前第n行数据</span><br><span class="line">7）LEAD(col,n)：往后第n行数据</span><br><span class="line">8） NTILE(n)：把有序分区中的行分发到指定数据的组中，各个组有编号，编号从1开始，对于每一行，NTILE返回此行所属的组的编号。注意：n必须为int类型。</span><br><span class="line"></span><br><span class="line">一般窗口函数结合By使用！</span><br></pre></td></tr></table></figure><p>10：自定义UDF、UDTF函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用UDF函数解析公共字段；用UDTF函数解析事件字段。</span><br><span class="line"></span><br><span class="line">UDF一进一出，UDTF多进多出，实际上使用到的是一进多出</span><br></pre></td></tr></table></figure><p>11： Hive优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1）MapJoin</span><br><span class="line">如果不指定MapJoin或者不符合MapJoin的条件，那么Hive解析器会将Join操作转换成Common Join，即：在Reduce阶段完成join。容易发生数据倾斜。可以用MapJoin把小表全部加载到内存在map端进行join，避免reducer处理。</span><br><span class="line"></span><br><span class="line">2）行列过滤</span><br><span class="line">列处理：在SELECT中，只拿需要的列，如果有，尽量使用分区过滤，少用SELECT *。</span><br><span class="line">行处理：在分区剪裁中，当使用外关联时，如果将副表的过滤条件写在Where后面，那么就会先全表关联，之后再过滤。 </span><br><span class="line"></span><br><span class="line">3）采用分桶技术</span><br><span class="line"></span><br><span class="line">4）采用分区技术</span><br><span class="line"></span><br><span class="line">5）合理设置Map数</span><br><span class="line">（1）通常情况下，作业会通过input的目录产生一个或者多个map任务。</span><br><span class="line">主要的决定因素有：input的文件总个数，input的文件大小，集群设置的文件块大小。</span><br><span class="line">（2）是不是map数越多越好？</span><br><span class="line">答案是否定的。如果一个任务有很多小文件（远远小于块大小128m），则每个小文件也会被当做一个块，用一个map任务来完成，而一个map任务启动和初始化的时间远远大于逻辑处理的时间，就会造成很大的资源浪费。而且，同时可执行的map数是受限的。</span><br><span class="line">（3）是不是保证每个map处理接近128m的文件块，就高枕无忧了？</span><br><span class="line">答案也是不一定。比如有一个127m的文件，正常会用一个map去完成，但这个文件只有一个或者两个小字段，却有几千万的记录，如果map处理的逻辑比较复杂，用一个map任务去做，肯定也比较耗时。</span><br><span class="line">针对上面的问题2和3，我们需要采取两种方式来解决：即减少map数和增加map数；</span><br><span class="line"></span><br><span class="line">6）小文件进行合并</span><br><span class="line">在Map执行前合并小文件，减少Map数：CombineHiveInputFormat具有对小文件进行合并的功能（系统默认的格式）。HiveInputFormat没有对小文件合并功能。</span><br><span class="line"></span><br><span class="line">7）合理设置Reduce数</span><br><span class="line">Reduce个数并不是越多越好</span><br><span class="line">（1）过多的启动和初始化Reduce也会消耗时间和资源；</span><br><span class="line">（2）另外，有多少个Reduce，就会有多少个输出文件，如果生成了很多个小文件，那么如果这些小文件作为下一个任务的输入，则也会出现小文件过多的问题；</span><br><span class="line">在设置Reduce个数的时候也需要考虑这两个原则：处理大数据量利用合适的Reduce数；使单个Reduce任务处理数据量大小要合适；</span><br><span class="line"></span><br><span class="line">8）常用参数</span><br><span class="line">// 输出合并小文件</span><br><span class="line">SET hive.merge.mapfiles = true; -- 默认true，在map-only任务结束时合并小文件</span><br><span class="line">SET hive.merge.mapredfiles = true; -- 默认false，在map-reduce任务结束时合并小文件</span><br><span class="line">SET hive.merge.size.per.task = 268435456; -- 默认256M</span><br><span class="line">SET hive.merge.smallfiles.avgsize = 16777216; -- 当输出文件的平均大小小于该值时，启动一个独立的map-reduce任务进行文件merge</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：离线数仓-用户行为数仓分层搭建总结&quot;&gt;&lt;a href=&quot;#1：离线数仓-用户行为数仓分层搭建总结&quot; class=&quot;headerlink&quot; title=&quot;1：离线数仓-用户行为数仓分层搭建总结&quot;&gt;&lt;/a&gt;1：离线数仓-用户行为数仓分层搭建总结&lt;/h1&gt;&lt;figu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>离线数仓-数据采集总结</title>
    <link href="https://yanyubing.xyz/2019/12/06/%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E6%80%BB%E7%BB%93/"/>
    <id>https://yanyubing.xyz/2019/12/06/%E7%A6%BB%E7%BA%BF%E6%95%B0%E4%BB%93-%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-06T03:02:55.301Z</published>
    <updated>2019-12-06T08:23:58.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：离线数仓-数据采集"><a href="#1：离线数仓-数据采集" class="headerlink" title="1：离线数仓-数据采集"></a>1：离线数仓-数据采集</h1><p>1：项目需求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：数据采集平台搭建</span><br><span class="line">2：实现用户行为数仓的分层搭建</span><br><span class="line">3：实现业务数仓的分层搭建</span><br><span class="line">4：针对数据仓库中的数据进行，留存，转换率，复购率，活跃等报表分析</span><br></pre></td></tr></table></figure><p>2：项目选型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据采集传输：Flume,Kafka,Sqoop      Logstash DataX</span><br><span class="line">数据储存：MySql,HDFS Hbase,Redis,MongoDB</span><br><span class="line">数据计算：Hive,Tez,Spark  Flink,Storm</span><br><span class="line">数据查询：Presto,Druid Impala,Kylin</span><br></pre></td></tr></table></figure><p>3：框架版本选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1)Apache:一般大厂使用，运维麻烦</span><br><span class="line">2）CDH：中小公司使用，主件兼容性好</span><br><span class="line">3）HDP：可以进行二次开发，但是没有CDH稳定</span><br><span class="line"></span><br><span class="line">注意：框架不要选择最新，一般选择半年前左右的稳定版本</span><br></pre></td></tr></table></figure><p>4：服务器选择</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：机器成本考虑</span><br><span class="line">2：运维成本考虑</span><br><span class="line"></span><br><span class="line">云主机价格贵，但是运维轻松，不需要专业运维人员，省去运维成本；但是数据安全性不可靠！</span><br><span class="line">有实力就物理机，省钱就云主机。</span><br></pre></td></tr></table></figure><p>5：如何确定集群规模</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：第一个方面就是日活跃数据，和多久不增加集群规模</span><br><span class="line">2：数仓分层，数据需要扩容</span><br></pre></td></tr></table></figure><p>6：HDFS储存多目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1：在hdfs-site.xml文件中配置多目录，最好提前配置好，否则更改目录需要重新启动集群</span><br></pre></td></tr></table></figure><p>7：支持LZO压缩配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1）先下载lzo的jar项目</span><br><span class="line">https://github.com/twitter/hadoop-lzo/archive/master.zip</span><br><span class="line"></span><br><span class="line">2）下载后的文件名是hadoop-lzo-master，它是一个zip格式的压缩包，先进行解压，然后用maven编译。生成hadoop-lzo-0.4.20.jar。</span><br><span class="line"></span><br><span class="line">3）将编译好后的hadoop-lzo-0.4.20.jar 放入hadoop-2.7.2/share/hadoop/common/</span><br><span class="line"> pwd</span><br><span class="line">/opt/module/hadoop-2.7.2/share/hadoop/common</span><br><span class="line"> ls</span><br><span class="line">hadoop-lzo-0.4.20.jar</span><br><span class="line"></span><br><span class="line">4）同步hadoop-lzo-0.4.20.jar到hadoop103、hadoop104</span><br><span class="line">$ xsync hadoop-lzo-0.4.20.jar</span><br><span class="line"></span><br><span class="line">5）core-site.xml增加配置支持LZO压缩</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;io.compression.codecs&lt;/name&gt;</span><br><span class="line">&lt;value&gt;</span><br><span class="line">org.apache.hadoop.io.compress.GzipCodec,</span><br><span class="line">org.apache.hadoop.io.compress.DefaultCodec,</span><br><span class="line">org.apache.hadoop.io.compress.BZip2Codec,</span><br><span class="line">org.apache.hadoop.io.compress.SnappyCodec,</span><br><span class="line">com.hadoop.compression.lzo.LzoCodec,</span><br><span class="line">com.hadoop.compression.lzo.LzopCodec</span><br><span class="line">&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;io.compression.codec.lzo.class&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;com.hadoop.compression.lzo.LzoCodec&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">6）同步core-site.xml到hadoop103、hadoop104</span><br><span class="line">$ xsync core-site.xml</span><br><span class="line"></span><br><span class="line">7）启动及查看集群</span><br><span class="line">$ sbin/start-dfs.sh</span><br><span class="line">$ sbin/start-yarn.sh</span><br><span class="line">（1）web和进程查看</span><br><span class="line">Web查看：http://hadoop102:50070</span><br><span class="line">进程查看：jps查看各个节点状态。</span><br></pre></td></tr></table></figure><p>8：基准测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：测试HDFS写性能</span><br><span class="line">测试内容：向HDFS集群写10个128M的文件</span><br><span class="line">hadoop jar /opt/module/hadoop-2.7.2/share/hadoop/mapreduce/hadoop-mapreduce-client-jobclient-2.7.2-tests.jar TestDFSIO -write -nrFiles 10 -fileSize 128MB</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2：测试HDFS读性能</span><br><span class="line">测试内容：读取HDFS集群10个128M的文件</span><br><span class="line">hadoop jar /opt/module/hadoop-2.7.2/share/hadoop/mapreduce/hadoop-mapreduce-client-jobclient-2.7.2-tests.jar TestDFSIO -read -nrFiles 10 -fileSize 128MB</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3：使用Sort程序评测MapReduce</span><br><span class="line">（1）使用RandomWriter来产生随机数，每个节点运行10个Map任务，每个Map产生大约1G大小的二进制随机数</span><br><span class="line">hadoop jar /opt/module/hadoop-2.7.2/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar randomwriter random-data</span><br><span class="line"></span><br><span class="line">（2）执行Sort程序</span><br><span class="line"> hadoop jar /opt/module/hadoop-2.7.2/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar sort random-data sorted-data</span><br><span class="line"></span><br><span class="line">（3）验证数据是否真正排好序了</span><br><span class="line">hadoop jar /opt/module/hadoop-2.7.2/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.2.jar testmapredsort -sortInput random-data -sortOutput sorted-data</span><br></pre></td></tr></table></figure><p>9：Hadoop参数调优</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）HDFS参数调优hdfs-site.xml</span><br><span class="line">（1）dfs.namenode.handler.count=20 * log2(Cluster Size)，比如集群规模为8台时，此参数设置为60</span><br><span class="line">The number of Namenode RPC server threads that listen to requests from clients. If dfs.namenode.servicerpc-address is not configured then Namenode RPC server threads listen to requests from all nodes.</span><br><span class="line">NameNode有一个工作线程池，用来处理不同DataNode的并发心跳以及客户端并发的元数据操作。对于大集群或者有大量客户端的集群来说，通常需要增大参数dfs.namenode.handler.count的默认值10。设置该值的一般原则是将其设置为集群大小的自然对数乘以20，即20logN，N为集群大小。</span><br><span class="line">（2）编辑日志存储路径dfs.namenode.edits.dir设置与镜像文件存储路径dfs.namenode.name.dir尽量分开，达到最低写入延迟</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2）YARN参数调优yarn-site.xml</span><br><span class="line">（1）情景描述：总共7台机器，每天几亿条数据，数据源-&gt;Flume-&gt;Kafka-&gt;HDFS-&gt;Hive</span><br><span class="line">面临问题：数据统计主要用HiveSQL，没有数据倾斜，小文件已经做了合并处理，开启的JVM重用，而且IO没有阻塞，内存用了不到50%。但是还是跑的非常慢，而且数据量洪峰过来时，整个集群都会宕掉。基于这种情况有没有优化方案。</span><br><span class="line">（2）解决办法：</span><br><span class="line">内存利用率不够。这个一般是Yarn的2个配置造成的，单个任务可以申请的最大内存大小，和Hadoop单个节点可用内存大小。调节这两个参数能提高系统内存的利用率。</span><br><span class="line">（a）yarn.nodemanager.resource.memory-mb</span><br><span class="line">表示该节点上YARN可使用的物理内存总量，默认是8192（MB），注意，如果你的节点内存资源不够8GB，则需要调减小这个值，而YARN不会智能的探测节点的物理内存总量。</span><br><span class="line">（b）yarn.scheduler.maximum-allocation-mb</span><br><span class="line">单个任务可申请的最多物理内存量，默认是8192（MB）。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3）Hadoop宕机</span><br><span class="line">（1）如果MR造成系统宕机。此时要控制Yarn同时运行的任务数，和每个任务申请的最大内存。调整参数：yarn.scheduler.maximum-allocation-mb（单个任务可申请的最多物理内存量，默认是8192MB）</span><br><span class="line">（2）如果写入文件过量造成NameNode宕机。那么调高Kafka的存储大小，控制从Kafka到HDFS的写入速度。高峰期的时候用Kafka进行缓存，高峰期过去数据同步会自动跟上。</span><br></pre></td></tr></table></figure><p>10：Linux环境变量：执行脚本文件需要设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）修改/etc/profile文件：用来设置系统环境参数，比如$PATH. 这里面的环境变量是对系统内所有用户生效。使用bash命令，需要source  /etc/profile一下。</span><br><span class="line">2）修改~/.bashrc文件：针对某一个特定的用户，环境变量的设置只对该用户自己有效。使用bash命令，只要以该用户身份运行命令行就会读取该文件。</span><br><span class="line">3）把/etc/profile里面的环境变量追加到~/.bashrc目录，需要执行的文件都需要追加文件</span><br><span class="line">cat /etc/profile &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><p>11：集群脚本分类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：单启服务的脚本</span><br><span class="line">2：多启有依赖关系的服务脚本，这时候需要考虑到服务启动的延迟时间，sleep一下。</span><br><span class="line">3：查看所有服务进程的脚本</span><br><span class="line">4：集群时间同步脚本</span><br><span class="line">5：集群分发sxync脚本</span><br></pre></td></tr></table></figure><p>12：日志采集对应的Flume组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1）Source</span><br><span class="line">（1）Taildir Source相比Exec Source、Spooling Directory Source的优势</span><br><span class="line">TailDir Source：断点续传、多目录。Flume1.6以前需要自己自定义Source记录每次读取文件位置，实现断点续传。</span><br><span class="line">Exec Source可以实时搜集数据，但是在Flume不运行或者Shell命令出错的情况下，数据将会丢失。</span><br><span class="line">Spooling Directory Source监控目录，不支持断点续传。</span><br><span class="line">（2）batchSize大小如何设置？</span><br><span class="line">答：Event 1K左右时，500-1000合适（默认为100）</span><br><span class="line">2）Channel</span><br><span class="line">采用Kafka Channel，省去了Sink，提高了效率。</span><br></pre></td></tr></table></figure><p>13：Flume的ETL和分类型拦截器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本项目中自定义了两个拦截器，分别是：ETL拦截器、日志类型区分拦截器。</span><br><span class="line">ETL拦截器主要用于，过滤时间戳不合法和Json数据不完整的日志</span><br><span class="line">日志类型区分拦截器主要用于，将启动日志和事件日志区分开来，方便发往Kafka的不同Topic。</span><br></pre></td></tr></table></figure><p>14：kafka监控——Kafka Manager安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Kafka Manager是yahoo的一个Kafka监控管理项目。</span><br><span class="line">1）下载地址</span><br><span class="line">https://github.com/yahoo/kafka-manager</span><br><span class="line">下载之后编译源码，编译完成后，拷贝出：kafka-manager-1.3.3.22.zip</span><br><span class="line"></span><br><span class="line">2）拷贝kafka-manager-1.3.3.22.zip到hadoop102的/opt/module目录</span><br><span class="line">$ pwd</span><br><span class="line">/opt/module</span><br><span class="line"></span><br><span class="line">3）解压kafka-manager-1.3.3.22.zip到/opt/module目录</span><br><span class="line">$ unzip kafka-manager-1.3.3.22.zip</span><br><span class="line"></span><br><span class="line">4）进入到/opt/module/kafka-manager-1.3.3.22/conf目录，在application.conf文件中修改kafka-manager.zkhosts</span><br><span class="line">$ vim application.conf</span><br><span class="line">修改为：</span><br><span class="line">kafka-manager.zkhosts=&quot;hadoop102:2181,hadoop103:2181,hadoop104:2181&quot;</span><br><span class="line"></span><br><span class="line">5）启动KafkaManager</span><br><span class="line">$ nohup bin/kafka-manager   -Dhttp.port=7456 &gt;/opt/module/kafka-manager-1.3.3.22/start.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">6）在浏览器中打开</span><br><span class="line">http://hadoop102:7456</span><br></pre></td></tr></table></figure><p>15：Kafka压力测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1）Kafka压测</span><br><span class="line">用Kafka官方自带的脚本，对Kafka进行压测。Kafka压测时，可以查看到哪个地方出现了瓶颈（CPU，内存，网络IO）。一般都是网络IO达到瓶颈。 </span><br><span class="line">kafka-consumer-perf-test.sh</span><br><span class="line">kafka-producer-perf-test.sh</span><br><span class="line"></span><br><span class="line">2）Kafka Producer压力测试</span><br><span class="line">（1）在/opt/module/kafka/bin目录下面有这两个文件。我们来测试一下</span><br><span class="line">$ bin/kafka-producer-perf-test.sh  --topic test --record-size 100 --num-records 100000 --throughput 1000 --producer-props bootstrap.servers=hadoop102:9092,hadoop103:9092,hadoop104:9092</span><br><span class="line">说明：record-size是一条信息有多大，单位是字节。num-records是总共发送多少条信息。throughput 是每秒多少条信息。</span><br><span class="line">（2）Kafka会打印下面的信息</span><br><span class="line">5000 records sent, 999.4 records/sec (0.10 MB/sec), 1.9 ms avg latency, 254.0 max latency.</span><br><span class="line">5002 records sent, 1000.4 records/sec (0.10 MB/sec), 0.7 ms avg latency, 12.0 max latency.</span><br><span class="line">5001 records sent, 1000.0 records/sec (0.10 MB/sec), 0.8 ms avg latency, 4.0 max latency.</span><br><span class="line">5000 records sent, 1000.0 records/sec (0.10 MB/sec), 0.7 ms avg latency, 3.0 max latency.</span><br><span class="line">5000 records sent, 1000.0 records/sec (0.10 MB/sec), 0.8 ms avg latency, 5.0 max latency.</span><br><span class="line">参数解析：本例中一共写入10w条消息，每秒向Kafka写入了0.10MB的数据，平均是1000条消息/秒，每次写入的平均延迟为0.8毫秒，最大的延迟为254毫秒。</span><br><span class="line"></span><br><span class="line">3）Kafka Consumer压力测试</span><br><span class="line">Consumer的测试，如果这四个指标（IO，CPU，内存，网络）都不能改变，考虑增加分区数来提升性能。</span><br><span class="line">$ bin/kafka-consumer-perf-test.sh --zookeeper hadoop102:2181 --topic test --fetch-size 10000 --messages 10000000 --threads 1</span><br><span class="line">参数说明：</span><br><span class="line">--zookeeper 指定zookeeper的链接信息</span><br><span class="line">--topic 指定topic的名称</span><br><span class="line">--fetch-size 指定每次fetch的数据的大小</span><br><span class="line">--messages 总共要消费的消息个数</span><br><span class="line">测试结果说明：</span><br><span class="line">start.time, end.time, data.consumed.in.MB, MB.sec, data.consumed.in.nMsg, nMsg.sec</span><br><span class="line">2019-02-19 20:29:07:566, 2019-02-19 20:29:12:170, 9.5368, 2.0714, 100010, 21722.4153</span><br><span class="line">开始测试时间，测试结束数据，最大吞吐率9.5368MB/s，平均每秒消费2.0714MB/s，最大每秒消费100010条，平均每秒消费21722.4153条。</span><br></pre></td></tr></table></figure><p>16：Kafka机器数量计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Kafka机器数量（经验公式）=2*（峰值生产速度*副本数/100）+1</span><br><span class="line"></span><br><span class="line">1:先要预估一天大概产生多少数据，然后用Kafka自带的生产压测（只测试Kafka的写入速度，保证数据不积压），计算出峰值生产速度。再根据设定的副本数，就能预估出需要部署Kafka的数量</span><br><span class="line"></span><br><span class="line">2:比如我们采用压力测试测出写入的速度是10M/s一台，峰值的业务数据的速度是50M/s。副本数为2。</span><br><span class="line">Kafka机器数量=2*（50*2/100）+ 1=3台</span><br></pre></td></tr></table></figure><p>17：Flume链接Kafka-hdfs，内存优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1）问题描述：如果启动消费Flume抛出如下异常</span><br><span class="line">ERROR hdfs.HDFSEventSink: process failed</span><br><span class="line">java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line"></span><br><span class="line">2）解决方案步骤：</span><br><span class="line">（1）在hadoop102服务器的/opt/module/flume/conf/flume-env.sh文件中增加如下配置</span><br><span class="line">export JAVA_OPTS=&quot;-Xms100m -Xmx2000m -Dcom.sun.management.jmxremote&quot;</span><br><span class="line">（2）同步配置到hadoop103、hadoop104服务器</span><br><span class="line">$ xsync flume-env.sh</span><br><span class="line"></span><br><span class="line">3）Flume内存参数设置及优化</span><br><span class="line">JVM heap一般设置为4G或更高，部署在单独的服务器上（4核8线程16G内存）</span><br><span class="line">-Xmx与-Xms最好设置一致，减少内存抖动带来的性能影响，如果设置不一致容易导致频繁fullgc。</span><br></pre></td></tr></table></figure><p>18：Flume组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1）FileChannel和MemoryChannel区别</span><br><span class="line">MemoryChannel传输数据速度更快，但因为数据保存在JVM的堆内存中，Agent进程挂掉会导致数据丢失，适用于对数据质量要求不高的需求</span><br><span class="line">FileChannel传输速度相对于Memory慢，但数据安全保障高，Agent进程挂掉也可以从失败中恢复数据。</span><br><span class="line"></span><br><span class="line">2）FileChannel优化</span><br><span class="line">通过配置dataDirs指向多个路径，每个路径对应不同的硬盘，增大Flume吞吐量。</span><br><span class="line">官方说明如下：</span><br><span class="line">Comma separated list of directories for storing log files. Using multiple directories on separate disks can improve file channel peformance</span><br><span class="line">checkpointDir和backupCheckpointDir也尽量配置在不同硬盘对应的目录中，保证checkpoint坏掉后，可以快速使用backupCheckpointDir恢复数据</span><br><span class="line"></span><br><span class="line">3）Sink：HDFS Sink</span><br><span class="line">（1）HDFS存入大量小文件，有什么影响？</span><br><span class="line">元数据层面：每个小文件都有一份元数据，其中包括文件路径，文件名，所有者，所属组，权限，创建时间等，这些信息都保存在Namenode内存中。所以小文件过多，会占用Namenode服务器大量内存，影响Namenode性能和使用寿命</span><br><span class="line">计算层面：默认情况下MR会对每个小文件启用一个Map任务计算，非常影响计算性能。同时也影响磁盘寻址时间。</span><br><span class="line"></span><br><span class="line">（2）HDFS小文件处理</span><br><span class="line">官方默认的这三个参数配置写入HDFS后会产生小文件，hdfs.rollInterval、hdfs.rollSize、hdfs.rollCount</span><br><span class="line">基于以上hdfs.rollInterval=3600，hdfs.rollSize=134217728，hdfs.rollCount =0，hdfs.roundValue=10，hdfs.roundUnit= second几个参数综合作用，效果如下：</span><br><span class="line">（1）tmp文件在达到128M时会滚动生成正式文件</span><br><span class="line">（2）tmp文件创建超10秒时会滚动生成正式文件</span><br><span class="line">举例：在2018-01-01 05:23的时侯sink接收到数据，那会产生如下tmp文件：</span><br><span class="line">201801010520.tmp</span><br><span class="line">即使文件内容没有达到128M，也会在05:33时滚动生成正式文件</span><br></pre></td></tr></table></figure><p>19：数仓概念总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）数据仓库的输入数据源和输出系统分别是什么？</span><br><span class="line">输入系统：埋点产生的用户行为数据、JavaEE后台产生的业务数据。</span><br><span class="line">输出系统：报表系统、用户画像系统、推荐系统</span><br></pre></td></tr></table></figure><p>20：Linux&amp;Shell相关总结</p><p>1）Linux常用命令</p><table><thead><tr><th>序号</th><th>命令</th><th>命令解释</th></tr></thead><tbody><tr><td>1</td><td>top</td><td>查看内存</td></tr><tr><td>2</td><td>df -h</td><td>查看磁盘存储情况</td></tr><tr><td>3</td><td>iotop</td><td>查看磁盘IO读写(yum install iotop安装）</td></tr><tr><td>4</td><td>iotop -o</td><td>直接查看比较高的磁盘读写程序</td></tr><tr><td>5</td><td>netstat -tunlp | grep 端口号</td><td>查看端口占用情况</td></tr><tr><td>6</td><td>uptime</td><td>查看报告系统运行时长及平均负载</td></tr><tr><td>7</td><td>ps  aux</td><td>查看进程</td></tr></tbody></table><p>2）Shell常用工具</p><p>awk、sed、cut、sort</p><p>21：Hadoop相关总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1）Hadoop默认不支持LZO压缩，如果需要支持LZO压缩，需要添加jar包，并在hadoop的cores-site.xml文件中添加相关压缩配置。</span><br><span class="line">2）Hadoop常用端口号，50070，50090，8020，9000等</span><br><span class="line">3）Hadoop配置文件以及简单的Hadoop集群搭建</span><br><span class="line">4）HDFS读流程和写流程</span><br><span class="line">5）MapReduce的Shuffle过程及Hadoop优化（包括：压缩、小文件、集群优化）</span><br><span class="line">6）Yarn的Job提交流程</span><br><span class="line">7）Yarn的默认调度器、调度器分类、以及他们之间的区别</span><br><span class="line">8）HDFS存储多目录</span><br><span class="line">9）Hadoop参数调优</span><br><span class="line">10）项目经验之基准测试</span><br></pre></td></tr></table></figure><p>22： Zookeeper相关总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）选举机制</span><br><span class="line">半数机制</span><br><span class="line">2）常用命令</span><br><span class="line">ls、get、create</span><br></pre></td></tr></table></figure><p>23：Flume相关总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">1）Flume组成，Put事务，Take事务</span><br><span class="line">Taildir Source：断点续传、多目录。Flume1.6以前需要自己自定义Source记录每次读取文件位置，实现断点续传。</span><br><span class="line">File Channel：数据存储在磁盘，宕机数据可以保存。但是传输速率慢。适合对数据传输可靠性要求高的场景，比如，金融行业。</span><br><span class="line">Memory Channel：数据存储在内存中，宕机数据丢失。传输速率快。适合对数据传输可靠性要求不高的场景，比如，普通的日志数据。</span><br><span class="line">Kafka Channel：减少了Flume的Sink阶段，提高了传输效率。           </span><br><span class="line">Source到Channel是Put事务</span><br><span class="line">Channel到Sink是Take事务</span><br><span class="line"></span><br><span class="line">2）Flume拦截器</span><br><span class="line">（1）拦截器注意事项</span><br><span class="line">项目中自定义了：ETL拦截器和区分类型拦截器。</span><br><span class="line">采用两个拦截器的优缺点：优点，模块化开发和可移植性；缺点，性能会低一些</span><br><span class="line">（2）自定义拦截器步骤</span><br><span class="line">a）实现 Interceptor</span><br><span class="line">b）重写四个方法</span><br><span class="line">initialize 初始化</span><br><span class="line">public Event intercept(Event event) 处理单个Event</span><br><span class="line">public List&lt;Event&gt; intercept(List&lt;Event&gt; events) 处理多个Event，在这个方法中调用Event intercept(Event event)</span><br><span class="line">close 方法</span><br><span class="line">c）静态内部类，实现Interceptor.Builder</span><br><span class="line"></span><br><span class="line">3）Flume Channel选择器</span><br><span class="line"></span><br><span class="line">4）Flume 监控器</span><br><span class="line">Ganglia</span><br><span class="line"></span><br><span class="line">5）Flume采集数据会丢失吗?</span><br><span class="line">不会，Channel存储可以存储在File中，数据传输自身有事务。</span><br><span class="line"></span><br><span class="line">6）Flume内存</span><br><span class="line">开发中在flume-env.sh中设置JVM heap为4G或更高，部署在单独的服务器上（4核8线程16G内存）</span><br><span class="line">-Xmx与-Xms最好设置一致，减少内存抖动带来的性能影响，如果设置不一致容易导致频繁fullgc。</span><br><span class="line"></span><br><span class="line">7）FileChannel优化</span><br><span class="line">通过配置dataDirs指向多个路径，每个路径对应不同的硬盘，增大Flume吞吐量。</span><br><span class="line">官方说明如下：</span><br><span class="line">Comma separated list of directories for storing log files. Using multiple directories on separate disks can improve file channel peformance</span><br><span class="line">checkpointDir和backupCheckpointDir也尽量配置在不同硬盘对应的目录中，保证checkpoint坏掉后，可以快速使用backupCheckpointDir恢复数据</span><br><span class="line"></span><br><span class="line">8）Sink：HDFS Sink小文件处理</span><br><span class="line">（1）HDFS存入大量小文件，有什么影响？</span><br><span class="line">元数据层面：每个小文件都有一份元数据，其中包括文件路径，文件名，所有者，所属组，权限，创建时间等，这些信息都保存在Namenode内存中。所以小文件过多，会占用Namenode服务器大量内存，影响Namenode性能和使用寿命</span><br><span class="line">计算层面：默认情况下MR会对每个小文件启用一个Map任务计算，非常影响计算性能。同时也影响磁盘寻址时间。</span><br><span class="line">（2）HDFS小文件处理</span><br><span class="line">官方默认的这三个参数配置写入HDFS后会产生小文件，hdfs.rollInterval、hdfs.rollSize、hdfs.rollCount</span><br><span class="line">基于以上hdfs.rollInterval=3600，hdfs.rollSize=134217728，hdfs.rollCount =0，hdfs.roundValue=10，hdfs.roundUnit= second几个参数综合作用，效果如下：</span><br><span class="line">（1）tmp文件在达到128M时会滚动生成正式文件</span><br><span class="line">（2）tmp文件创建超10秒时会滚动生成正式文件</span><br><span class="line">举例：在2018-01-01 05:23的时侯sink接收到数据，那会产生如下tmp文件：</span><br><span class="line">201801010520.tmp</span><br><span class="line">即使文件内容没有达到128M，也会在05:33时滚动生成正式文件</span><br></pre></td></tr></table></figure><p>24：Kafka相关总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1）Kafka压测</span><br><span class="line">Kafka官方自带压力测试脚本（kafka-consumer-perf-test.sh、kafka-producer-perf-test.sh）。Kafka压测时，可以查看到哪个地方出现了瓶颈（CPU，内存，网络IO）。一般都是网络IO达到瓶颈。</span><br><span class="line"></span><br><span class="line">2）Kafka的机器数量</span><br><span class="line">Kafka机器数量=2*（峰值生产速度*副本数/100）+1</span><br><span class="line"></span><br><span class="line">3）Kafka的日志保存时间</span><br><span class="line">7天</span><br><span class="line"></span><br><span class="line">4）Kafka的硬盘大小</span><br><span class="line">每天的数据量*7天</span><br><span class="line"></span><br><span class="line">5）Kafka监控</span><br><span class="line">公司自己开发的监控器；</span><br><span class="line">开源的监控器：KafkaManager、KafkaMonitor</span><br><span class="line"></span><br><span class="line">6）Kakfa分区数。</span><br><span class="line">分区数并不是越多越好，一般分区数不要超过集群机器数量。分区数越多占用内存越大（ISR等），一个节点集中的分区也就越多，当它宕机的时候，对系统的影响也就越大。</span><br><span class="line">分区数一般设置为：3-10个</span><br><span class="line"></span><br><span class="line">7）副本数设定</span><br><span class="line">一般我们设置成2个或3个，很多企业设置为2个。</span><br><span class="line"></span><br><span class="line">8）多少个Topic</span><br><span class="line">  通常情况：多少个日志类型就多少个Topic。也有对日志类型进行合并的。</span><br><span class="line"></span><br><span class="line">9）Kafka丢不丢数据</span><br><span class="line">Ack=0，相当于异步发送，消息发送完毕即offset增加，继续生产。</span><br><span class="line">Ack=1，leader收到leader replica 对一个消息的接受ack才增加offset，然后继续生产。</span><br><span class="line">Ack=-1，leader收到所有replica 对一个消息的接受ack才增加offset，然后继续生产。</span><br><span class="line"></span><br><span class="line">10）Kafka的ISR副本同步队列</span><br><span class="line">ISR（In-Sync Replicas），副本同步队列。ISR中包括Leader和Follower。如果Leader进程挂掉，会在ISR队列中选择一个服务作为新的Leader。有replica.lag.max.messages（延迟条数）和replica.lag.time.max.ms（延迟时间）两个参数决定一台服务是否可以加入ISR副本队列，在0.10版本移除了replica.lag.max.messages参数，防止服务频繁的进去队列。</span><br><span class="line">任意一个维度超过阈值都会把Follower剔除出ISR，存入OSR（Outof-Sync Replicas）列表，新加入的Follower也会先存放在OSR中。</span><br><span class="line"></span><br><span class="line">11）Kafka分区分配策略</span><br><span class="line">在 Kafka内部存在两种默认的分区分配策略：Range和 RoundRobin。</span><br><span class="line">Range是默认策略。Range是对每个Topic而言的（即一个Topic一个Topic分），首先对同一个Topic里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序。然后用Partitions分区的个数除以消费者线程的总数来决定每个消费者线程消费几个分区。如果除不尽，那么前面几个消费者线程将会多消费一个分区。</span><br><span class="line">例如：我们有10个分区，两个消费者（C1，C2），3个消费者线程，10 / 3 = 3而且除不尽。</span><br><span class="line">C1-0 将消费 0, 1, 2, 3 分区</span><br><span class="line">C2-0 将消费 4, 5, 6 分区</span><br><span class="line">C2-1 将消费 7, 8, 9 分区</span><br><span class="line">RoundRobin：前提：同一个Consumer Group里面的所有消费者的num.streams（消费者消费线程数）必须相等；每个消费者订阅的主题必须相同。</span><br><span class="line">第一步：将所有主题分区组成TopicAndPartition列表，然后对TopicAndPartition列表按照hashCode进行排序，最后按照轮询的方式发给每一个消费线程。</span><br><span class="line"></span><br><span class="line">12）Kafka中数据量计算</span><br><span class="line">每天总数据量100g，每天产生1亿条日志， 10000万/24/60/60=1150条/每秒钟</span><br><span class="line">平均每秒钟：1150条</span><br><span class="line">低谷每秒钟：400条</span><br><span class="line">高峰每秒钟：1150条*（2-20倍）=2300条-23000条</span><br><span class="line">每条日志大小：0.5k-2k</span><br><span class="line">每秒多少数据量：2.3M-20MB</span><br><span class="line"></span><br><span class="line">13） Kafka挂掉</span><br><span class="line">（1）Flume记录</span><br><span class="line">（2）日志有记录</span><br><span class="line">（3）短期没事</span><br><span class="line"></span><br><span class="line">14） Kafka消息数据积压，Kafka消费能力不足怎么处理？ </span><br><span class="line">（1）如果是Kafka消费能力不足，则可以考虑增加Topic的分区数，并且同时提升消费组的消费者数量，消费者数=分区数。（两者缺一不可）</span><br><span class="line">（2）如果是下游的数据处理不及时：提高每批次拉取的数量。批次拉取数据过少（拉取数据/处理时间&lt;生产速度），使处理的数据小于生产的数据，也会造成数据积压。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：离线数仓-数据采集&quot;&gt;&lt;a href=&quot;#1：离线数仓-数据采集&quot; class=&quot;headerlink&quot; title=&quot;1：离线数仓-数据采集&quot;&gt;&lt;/a&gt;1：离线数仓-数据采集&lt;/h1&gt;&lt;p&gt;1：项目需求&lt;/p&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（10）10种算法</title>
    <link href="https://yanyubing.xyz/2018/08/10/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%8910%E7%A7%8D%E7%AE%97%E6%B3%95/"/>
    <id>https://yanyubing.xyz/2018/08/10/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%8810%EF%BC%8910%E7%A7%8D%E7%AE%97%E6%B3%95/</id>
    <published>2018-08-10T13:46:12.000Z</published>
    <updated>2019-12-06T02:57:40.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：算法"><a href="#1：算法" class="headerlink" title="1：算法"></a>1：算法</h1><h3 id="1：二分查找：非递归"><a href="#1：二分查找：非递归" class="headerlink" title="1：二分查找：非递归"></a>1：二分查找：非递归</h3><p>1：二分查找简介</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x&lt;a[n/2],则只要在数组a的左半部分继续搜索x,如果x&gt;a[n/2],则只要在数组a的右半部搜索x.</span><br><span class="line">时间复杂度无非就是while循环的次数！</span><br><span class="line">总共有n个元素，</span><br><span class="line">渐渐跟下去就是n,n/2,n/4,....n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数</span><br><span class="line">由于你n/2^k取整后&gt;=1</span><br><span class="line">即令n/2^k=1</span><br><span class="line">可得k=log2n,（是以2为底，n的对数）</span><br><span class="line">所以时间复杂度可以表示O(h)=O(log2n)</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.it.binarysearchnorecursion;</span><br><span class="line"></span><br><span class="line">//二分查找，非递归</span><br><span class="line">public class BinarySearchNoRecur &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;1, 2, 5, 8, 12, 34, 56, 234&#125;;</span><br><span class="line">        int index=binarySearch(arr, 1);</span><br><span class="line">        System.out.println(&quot;index=&quot;+index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //二分查找非递归实现,arr升序</span><br><span class="line">    public static int binarySearch(int[] arr, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = arr.length - 1;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = (left + right) / 2;</span><br><span class="line">            if (arr[mid] == target) &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125; else if (arr[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2：分治算法-汉诺塔"><a href="#2：分治算法-汉诺塔" class="headerlink" title="2：分治算法-汉诺塔"></a>2：分治算法-汉诺塔</h3><p>1：汉诺塔介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</span><br></pre></td></tr></table></figure><p>2：实现思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：A柱，B柱,C柱，n为盘子的个数</span><br><span class="line">2：当n=1时，A-C</span><br><span class="line">2：当n=2时，A-B，A-C,B-C</span><br><span class="line">3：当n=3时，A→C,A→B,C→B,A→C,B→A,B→C,A→C</span><br><span class="line">n个盘子的时候，移动次数s=2^n – 1</span><br><span class="line"></span><br><span class="line">规律当N个盘子的时候，可以当成两个盘子，把上面n-1当一个整体，把n-1个盘子先移动到B（A-B），然后再把最底下盘子移动到C，即A-C，最终把n-1个盘子移动到C，即B-C</span><br></pre></td></tr></table></figure><p>3：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.it.dac;</span><br><span class="line"></span><br><span class="line">//汉诺塔</span><br><span class="line">public class HanoiTower &#123;</span><br><span class="line">    private static int sum = 0;//记录移动的次数</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int num=10;</span><br><span class="line">        hanoiTower(num, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;);</span><br><span class="line">        System.out.println(&quot;当&quot; + num + &quot;个盘的时候，一起移动了&quot; + sum + &quot;次&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param num 汉诺塔盘的个数</span><br><span class="line">     * @param A   柱A</span><br><span class="line">     * @param B   柱B</span><br><span class="line">     * @param C   柱C</span><br><span class="line">     */</span><br><span class="line">    public static void hanoiTower(int num, char A, char B, char C) &#123;</span><br><span class="line">        //如果只有一个盘</span><br><span class="line">        if (num == 1) &#123;</span><br><span class="line">            System.out.println(&quot;第&quot; + num + &quot;个盘&quot; + A + &quot;-&quot; + C);</span><br><span class="line">            sum++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //当n&gt;2时，先把最上面的盘（所有盘）和最下面的一个盘</span><br><span class="line">            //先把最上面的所有盘，A-B</span><br><span class="line">            hanoiTower(num - 1, A, C, B);</span><br><span class="line">            //最后移动最后一个盘A-C</span><br><span class="line">            System.out.println(&quot;第&quot; + num + &quot;个盘&quot; + A + &quot;-&quot; + C);</span><br><span class="line">            sum++;</span><br><span class="line">            //把B塔所有盘移动到C</span><br><span class="line">            hanoiTower(num - 1, B, A, C);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3：动态规划算法-背包问题"><a href="#3：动态规划算法-背包问题" class="headerlink" title="3：动态规划算法-背包问题"></a>3：动态规划算法-背包问题</h3><p>1：01背包问题概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V？它是在1978年由Merkel和Hellman提出的。</span><br></pre></td></tr></table></figure><p>2：实现思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义：有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。</span><br><span class="line">f[i][v]=max&#123; f[i-1][v], f[i-1][v-w[i]]+v[i] &#125;。</span><br><span class="line">可以压缩空间，f[v]=max&#123;f[v],f[v-w[i]]+v[i]&#125;</span><br><span class="line">f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值</span><br><span class="line">f[i-1][v]表示前i-1件物品恰放入一个容量为v的背包可以获得的最大价值</span><br><span class="line">f[i-1][v-w[i]]+v[i]表示前i-1件物品放入到容量为（v-第i件物品的重量）的空间产生的最大价值+第i件物品的价值</span><br></pre></td></tr></table></figure><p>3：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">核心代码：</span><br><span class="line"></span><br><span class="line">//开始动态规划,i代表物品个数，j代表背包容量</span><br><span class="line">        for (int i = 1; i &lt; v.length; i++) &#123;//不处理第一行，</span><br><span class="line">            for (int j = 1; j &lt; v[0].length; j++) &#123;//不处理第一列</span><br><span class="line">                if (w[i - 1] &gt; j) &#123;//说明第i个物品的重量大于背包重量,无法加入进去</span><br><span class="line">                    v[i][j] = v[i - 1][j];</span><br><span class="line">                &#125; else &#123;//说明第i个物品的重量小于背包的重量，则可以进行比较</span><br><span class="line">                    //因为i从1开始，索引需要-1</span><br><span class="line">                    //v[i][j] = Math.max(v[i - 1][j], (val[i - 1] + v[i - 1][j - w[i - 1]]));</span><br><span class="line">                    //为了记录商品的存放情况，不能用max</span><br><span class="line">                    if (v[i - 1][j] &gt; (val[i - 1] + v[i - 1][j - w[i - 1]])) &#123;</span><br><span class="line">                        v[i][j] = v[i - 1][j];</span><br><span class="line">                    &#125; else if (v[i - 1][j] &lt; (val[i - 1] + v[i - 1][j - w[i - 1]])) &#123;</span><br><span class="line">                        v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];</span><br><span class="line">                        path[i][j] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        v[i][j] = v[i - 1][j];</span><br><span class="line">                        System.out.println(&quot;且存在多种分配方案&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package com.it.knapsackproblem;</span><br><span class="line"></span><br><span class="line">//01背包问题</span><br><span class="line">public class KnapsackProblem &#123;</span><br><span class="line">    private static int sumW = 0;//记录总使用重量</span><br><span class="line">    private static int sumVal = 0;//记录总使用价值</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] w = &#123;1, 4, 3, 6, 10, 2, 5&#125;;//物品的重量</span><br><span class="line">        int[] val = &#123;1500, 3000, 2000, 2444, 4000, 2333, 2000&#125;;//物品的价值</span><br><span class="line">        int m = 10;//背包的重量</span><br><span class="line">        int n = val.length;//物品的个数</span><br><span class="line">        //v[i][j]表示前i个物品放到容量为j的背包中的最大价值</span><br><span class="line">        int[][] v = new int[n + 1][m + 1];</span><br><span class="line">        //定义二维数组用于记录存放情况</span><br><span class="line">        int[][] path = new int[n + 1][m + 1];</span><br><span class="line">        //初始化，</span><br><span class="line">        for (int i = 0; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[i][0] = 0;//当背包容量为0时，最大价值为0</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; v[0].length; j++) &#123;</span><br><span class="line">            v[0][j] = 0;//当物品为0个时，最大价值为0</span><br><span class="line">        &#125;</span><br><span class="line">        //开始动态规划,i代表物品个数，j代表背包容量</span><br><span class="line">        for (int i = 1; i &lt; v.length; i++) &#123;//不处理第一行，</span><br><span class="line">            for (int j = 1; j &lt; v[0].length; j++) &#123;//不处理第一列</span><br><span class="line">                if (w[i - 1] &gt; j) &#123;//说明第i个物品的重量大于背包重量,无法加入进去</span><br><span class="line">                    v[i][j] = v[i - 1][j];</span><br><span class="line">                &#125; else &#123;//说明第i个物品的重量小于背包的重量，则可以进行比较</span><br><span class="line">                    //因为i从1开始，索引需要-1</span><br><span class="line">                    //v[i][j] = Math.max(v[i - 1][j], (val[i - 1] + v[i - 1][j - w[i - 1]]));</span><br><span class="line">                    //为了记录商品的存放情况，不能用max</span><br><span class="line">                    if (v[i - 1][j] &gt; (val[i - 1] + v[i - 1][j - w[i - 1]])) &#123;</span><br><span class="line">                        v[i][j] = v[i - 1][j];</span><br><span class="line">                    &#125; else if (v[i - 1][j] &lt; (val[i - 1] + v[i - 1][j - w[i - 1]])) &#123;</span><br><span class="line">                        v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];</span><br><span class="line">                        path[i][j] = 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        v[i][j] = v[i - 1][j];</span><br><span class="line">                        System.out.println(&quot;且存在多种分配方案&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; v.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; v[i].length; j++) &#123;</span><br><span class="line">                System.out.print(v[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;路径为&quot;);</span><br><span class="line">        //得从后往前遍历</span><br><span class="line">        int i = path.length - 1;//行得最大下标</span><br><span class="line">        int j = path[0].length - 1;//列得最大下标</span><br><span class="line">        //从path数组得最后开始找，得到最优路径</span><br><span class="line">        while (i &gt; 0 &amp;&amp; j &gt; 0) &#123;</span><br><span class="line">            if (path[i][j] == 1) &#123;</span><br><span class="line">                //说明放置过数据</span><br><span class="line">                System.out.printf(&quot;第%d个商品放入背包&quot;, i);</span><br><span class="line">                sumW += w[i - 1];</span><br><span class="line">                sumVal += val[i - 1];</span><br><span class="line">                j -= w[i - 1];//最大重量得减去最后一个物品得重量</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            i--;//物品个数减少</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;背包可以使用的重量为&quot;+m);</span><br><span class="line">        System.out.println(&quot;总计使用重量为&quot;+sumW);</span><br><span class="line">        System.out.println(&quot;总计产生价值为&quot;+sumVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4：KMP算法-字符串匹配问题"><a href="#4：KMP算法-字符串匹配问题" class="headerlink" title="4：KMP算法-字符串匹配问题"></a>4：KMP算法-字符串匹配问题</h3><p>1：暴力匹配简介</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？</span><br><span class="line">首先，先理清楚了暴力匹配算法的流程及内在的逻辑：</span><br><span class="line">如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</span><br><span class="line">如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；</span><br><span class="line">如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</span><br></pre></td></tr></table></figure><p>2：暴力匹配代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假定：母串长度为N，字串长度为M，字串首字母在N中出现的次数为n次</span><br><span class="line">那么算法实际复杂度为：O(N)+O(n)*(M-)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.it.kmp;</span><br><span class="line"></span><br><span class="line">public class ViolenceMatch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 = &quot;wrfemwlrerw&quot;;</span><br><span class="line">        String str2 = &quot;lr&quot;;</span><br><span class="line">        System.out.println(violenceMatch(str1,str2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param str1 母串</span><br><span class="line">     * @param str2 子串</span><br><span class="line">     * @return 返回第一个索引值</span><br><span class="line">     */</span><br><span class="line">    //暴力匹配算法实现</span><br><span class="line">    public static int violenceMatch(String str1, String str2) &#123;</span><br><span class="line">        char[] s1 = str1.toCharArray();//是s1为母串</span><br><span class="line">        char[] s2 = str2.toCharArray();//说s2为字串</span><br><span class="line">        int s1Len = s1.length;</span><br><span class="line">        int s2Len = s2.length;</span><br><span class="line">        int i = 0;//i指向s1</span><br><span class="line">        int j = 0;//j指向s2</span><br><span class="line">        while (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123;//保证匹配不越界</span><br><span class="line">            if (s1[i] == s2[j]) &#123;//说明匹配成功</span><br><span class="line">                i++;</span><br><span class="line">                j++;//如果全部都相等，则j会越界，即退出循环,此时的头索引即为i-j</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //如果不想等，则字串j继续置为0开始，</span><br><span class="line">                // 母串i的索引从第i-(j-1)个开始：即为前面一步和字串已经匹配到了j个元素，i需要回退j且+1开始</span><br><span class="line">                i = i - (j - 1);</span><br><span class="line">                j = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j == s2Len) &#123;</span><br><span class="line">            return i - j;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3：yanyubing算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">1：先遍历母串str1，找到字串str[0]在母串中的位子index，创建集合arr用于存放index；</span><br><span class="line">2：遍历集合arr取出arr.get(index)，循环字串长度，然后依次匹配，如果全部匹配成功，记录index</span><br><span class="line">3:将所有index存放到集合arr2中返回</span><br><span class="line"></span><br><span class="line">假定：母串长度为N，字串长度为M，字串首字母在N中出现的次数为n次</span><br><span class="line">那么算法实际复杂度为：O(N)+O(n)*(M-)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.it.minStr;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">//求最小子串</span><br><span class="line">public class M inStr &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s1 = &quot;abcdefghijk&quot;;</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        for (int i = 0; i &lt; 80000000; i++) &#123;</span><br><span class="line">            int index = r.nextInt(s1.length());</span><br><span class="line">            stringBuilder.append(s1.charAt(index));</span><br><span class="line">        &#125;</span><br><span class="line">        s1 = stringBuilder.toString();</span><br><span class="line">//        System.out.println(s1);</span><br><span class="line">        //测试时间</span><br><span class="line">        String s2 = &quot;abd&quot;;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        ArrayList arrayList = minStr(s1, s2);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;8千万个母串查找字串耗时/ms；&quot;+(end - start));</span><br><span class="line">        System.out.println(&quot;头索引个数为&quot;+ arrayList.size());</span><br><span class="line">        System.out.println(&quot;头索引为&quot;+ arrayList.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //方法,返回满足条件的字串在母串中的索引的集合</span><br><span class="line">    public static ArrayList minStr(String s1, String s2) &#123;</span><br><span class="line">        //母串s1   字串s2</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();//创建一个集合，用来存放字串首字符在母串中出现的索引</span><br><span class="line">        char[] chars1 = s1.toCharArray();//转换为字符数组</span><br><span class="line">        char[] chars2 = s2.toCharArray();//转换为字符数组</span><br><span class="line">        for (int i = 0; i &lt; chars1.length - chars2.length + 1; i++) &#123;</span><br><span class="line">            if (chars2[0] == chars1[i]) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList2 = new ArrayList&lt;&gt;();//创建第二个集合，用来存放所有满足条件，当字串首字符在母串中出现的首字符索引</span><br><span class="line">        //拿到了首字母索引的集合，循环s2.length-2次，从s1索引为1开始和s2索引从每个i开始比较比较</span><br><span class="line">        if (chars2.length == 1) &#123;</span><br><span class="line">            return arrayList;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int j = 0; j &lt; arrayList.size(); j++) &#123;</span><br><span class="line">                boolean flag = true;</span><br><span class="line">                for (int i = 1; i &lt; s2.length(); i++) &#123;//每次比较循环s2.length-2次,制定flag标志为true，如果循环完成还为true，则表示该索引满足条件</span><br><span class="line">                    if (chars1[arrayList.get(j) + i] != chars2[i]) &#123;</span><br><span class="line">                        flag = false;//不满足条件时，把flag置为false,并且推出内层循环</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //一次循环完成之后flag还是true则证明字串满足条件，记录当前的索引</span><br><span class="line">                if (flag) &#123;</span><br><span class="line">                    arrayList2.add(arrayList.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return arrayList2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4：KMP算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：KMP算法实际思路就是尽可能减少已经被匹配过了的母串中的字符串</span><br><span class="line">2：需要借助与字串的部分匹配值表</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">部分匹配值表举例：如字串abcdabd</span><br><span class="line">   头元素 尾元素  共有元素长度</span><br><span class="line">当1个元素时：a   null              0</span><br><span class="line">当2个元素时：a  b     0</span><br><span class="line">当3个元素时：(a，ab)  (bc,c)   0</span><br><span class="line">当4个元素时：(a，ab,abc)  (bcd,cd,d)   0</span><br><span class="line">当5个元素时：(a，ab,abc,abcd)  (bcda,cda,da,a)      1</span><br><span class="line">当6个元素时：(a，ab,abc,abcd,abcda)  (bcdab,cdab,dab,ab,b)  2</span><br><span class="line">当7个元素时：(a，ab,abc,abcd,abcda,abcdab)  (bcdabd,cdabd,dabd,abd,bd,d)0</span><br><span class="line"></span><br><span class="line">即得到的字串abcdabd部分匹配值表为</span><br><span class="line">abcdabd</span><br><span class="line">0000120</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">package com.it.kmp;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Array;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class KMPAlgorithm &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str1 = &quot;BBC ABCDAB ABCDABCDABDE&quot;;</span><br><span class="line">        String str2 = &quot;ABCDABD&quot;;</span><br><span class="line">        int[] next = kmpNext(str2);//</span><br><span class="line">        System.out.println(Arrays.toString(next));//打印字串的部分匹配表的数组</span><br><span class="line">        int num = kmpSearch(str1, str2, next);</span><br><span class="line">        System.out.println(&quot;字串中找到的索引为：&quot;+num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param str1 母串</span><br><span class="line">     * @param str2 字串</span><br><span class="line">     * @param next 字串的部分匹配表</span><br><span class="line">     * @return 返回首字母索引的集合</span><br><span class="line">     */</span><br><span class="line">    //kmp算法</span><br><span class="line">    public static int kmpSearch(String str1, String str2, int[] next) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        //遍历</span><br><span class="line">        for (int i = 0, j = 0; i &lt; str1.length(); i++) &#123;//i指向母串str1,j指向str2</span><br><span class="line">            //还需要处理str2.charAt(j) ！= str1.charAt(i)的情况，调整j的大小</span><br><span class="line">            while (j &gt; 0 &amp;&amp; str2.charAt(j) != str1.charAt(i)) &#123;</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            if (str2.charAt(j) == str1.charAt(i)) &#123;//说明首字符相等</span><br><span class="line">                j++;//继续判断第二个字符，第三个...</span><br><span class="line">            &#125;</span><br><span class="line">            if (j == str2.length()) &#123;//如果j的长度==字串的长度了，那么就说明找到</span><br><span class="line">                return i - j + 1;//首字符索引添加到集合</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param dest 字串</span><br><span class="line">     * @return 部分匹配值表的数组</span><br><span class="line">     */</span><br><span class="line">    public static int[] kmpNext(String dest) &#123;</span><br><span class="line">        //创建一个next数组保存部分匹配值表</span><br><span class="line">        int[] next = new int[dest.length()];</span><br><span class="line">        next[0] = 0;//字符串长度为1的时候，部分匹配值为0</span><br><span class="line">        ArrayList&lt;String&gt; s1 = new ArrayList&lt;String&gt;();//用于存放前缀元素的字符串</span><br><span class="line">        ArrayList&lt;String&gt; s2 = new ArrayList&lt;String&gt;();//用于存放后缀元素</span><br><span class="line">        //我的思路是循环</span><br><span class="line">        for (int i = 1; i &lt; dest.length(); i++) &#123;//i表示第几个元素加入</span><br><span class="line">            /*     * 部分匹配值表举例：如字串abcdabd   头元素 尾元素  共有元素长度</span><br><span class="line">当1个元素时：a   null              0</span><br><span class="line">当2个元素时：a  b     0</span><br><span class="line">当3个元素时：(a，ab)  (bc,c)   0</span><br><span class="line">当4个元素时：(a，ab,abc)  (bcd,cd,d)   0</span><br><span class="line">当5个元素时：(a，ab,abc,abcd)  (bcda,cda,da,a)      1</span><br><span class="line">当6个元素时：(a，ab,abc,abcd,abcda)  (bcdab,cdab,dab,ab,b)  2</span><br><span class="line">当7个元素时：(a，ab,abc,abcd,abcda,abcdab)  (bcdabd,cdabd,dabd,abd,bd,d)0</span><br><span class="line">*/</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;//当i=3时，</span><br><span class="line">                s1.add(dest.substring(0, j));</span><br><span class="line">                s2.add(dest.substring(j, i + 1));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;当i为&quot; + i + &quot;时&quot;);</span><br><span class="line">            System.out.println(&quot;集合s1为&quot; + s1.toString());</span><br><span class="line">            System.out.println(&quot;集合s2为&quot; + s2.toString());</span><br><span class="line">            System.out.println();</span><br><span class="line">            //循环结束表示添加元素完成，开始比较</span><br><span class="line">            //比较s1与s2</span><br><span class="line">            for (int j = 0; j &lt; s1.size(); j++) &#123;</span><br><span class="line">                for (int k = 0; k &lt; s2.size(); k++) &#123;</span><br><span class="line">                    if (s1.get(j).equals(s2.get(k))) &#123;//说明存在相同元素</span><br><span class="line">                        next[i] = s1.get(j).length();//把相同元素的长度赋值给next[i]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;//比较完成之后需要重置s1与s2</span><br><span class="line">            s1.clear();</span><br><span class="line">            s2.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五：贪心算法-集合覆盖问题"><a href="#五：贪心算法-集合覆盖问题" class="headerlink" title="五：贪心算法-集合覆盖问题"></a>五：贪心算法-集合覆盖问题</h3><p>1：贪心算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">假设存在下面需要付费的广播台，以及广播台覆盖可以覆盖的地区，如何选择最少的广播台，让所有的地区都可以接收到信号</span><br><span class="line">广播台覆盖地区</span><br><span class="line">k1&quot;北京&quot;上海&quot;&quot;天津&quot;</span><br><span class="line">k2&quot;广州&quot;&quot;北京&quot;&quot;深圳&quot;</span><br><span class="line">k3&quot;成都&quot;&quot;上海&quot;&quot;杭州&quot;</span><br><span class="line">k4&quot;上海&quot;&quot;天津&quot;</span><br><span class="line">k5&quot;杭州&quot;&quot;大连&quot;</span><br><span class="line"></span><br><span class="line">贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</span><br><span class="line">贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 </span><br><span class="line"></span><br><span class="line">实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</span><br></pre></td></tr></table></figure><p>2：贪心算法思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：覆盖问题，遍历所有广播台，找到一个覆盖了最多未覆盖地区的电台（此电台可能包含一些已经覆盖的地区，但是没关系）</span><br><span class="line">2：将这些电台加入到集合，去掉已经加入的电台</span><br><span class="line">3：重复第1步，直到覆盖完全部地区</span><br></pre></td></tr></table></figure><p>3：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思路清晰，主要就是对于集合的操作</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package com.it.greedy;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">//贪心算法</span><br><span class="line">public class GreedyAlgorithm &#123;</span><br><span class="line">    //存放所有地区,所有地区为全局变量，并且随时需要改变</span><br><span class="line">    static HashSet&lt;String&gt; allAreas = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建广播电台</span><br><span class="line">        HashMap&lt;String, HashSet&gt; broadcasts = new HashMap&lt;&gt;();</span><br><span class="line">        //将各个电台放入</span><br><span class="line">        HashSet&lt;String&gt; hashSet1 = new HashSet();</span><br><span class="line">        hashSet1.add(&quot;北京&quot;);</span><br><span class="line">        hashSet1.add(&quot;上海&quot;);</span><br><span class="line">        hashSet1.add(&quot;天津&quot;);</span><br><span class="line">        HashSet&lt;String&gt; hashSet2 = new HashSet();</span><br><span class="line">        hashSet2.add(&quot;广州&quot;);</span><br><span class="line">        hashSet2.add(&quot;北京&quot;);</span><br><span class="line">        hashSet2.add(&quot;深圳&quot;);</span><br><span class="line">        HashSet&lt;String&gt; hashSet3 = new HashSet();</span><br><span class="line">        hashSet3.add(&quot;成都&quot;);</span><br><span class="line">        hashSet3.add(&quot;上海&quot;);</span><br><span class="line">        hashSet3.add(&quot;杭州&quot;);</span><br><span class="line">        HashSet&lt;String&gt; hashSet4 = new HashSet();</span><br><span class="line">        hashSet4.add(&quot;上海&quot;);</span><br><span class="line">        hashSet4.add(&quot;天津&quot;);</span><br><span class="line">        HashSet&lt;String&gt; hashSet5 = new HashSet();</span><br><span class="line">        hashSet5.add(&quot;杭州&quot;);</span><br><span class="line">        hashSet5.add(&quot;大连&quot;);</span><br><span class="line">        //加入到map</span><br><span class="line">        broadcasts.put(&quot;k1&quot;, hashSet1);</span><br><span class="line">        broadcasts.put(&quot;k2&quot;, hashSet2);</span><br><span class="line">        broadcasts.put(&quot;k3&quot;, hashSet3);</span><br><span class="line">        broadcasts.put(&quot;k4&quot;, hashSet4);</span><br><span class="line">        broadcasts.put(&quot;k5&quot;, hashSet5);</span><br><span class="line">        for (Map.Entry&lt;String, HashSet&gt; Entry : broadcasts.entrySet()) &#123;</span><br><span class="line">            HashSet&lt;String&gt; value = Entry.getValue();//得到value</span><br><span class="line">            for (String s : value) &#123;</span><br><span class="line">                allAreas.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //添加完所有地区</span><br><span class="line">        System.out.println(&quot;需要覆盖的地区&quot;);</span><br><span class="line">        System.out.println(allAreas.toString());</span><br><span class="line">        System.out.println();</span><br><span class="line">        //创建ArrayList集合，存放选择的电台集合。</span><br><span class="line">        // 选择的条件为：遍历电台，将最多的未覆盖的地区的电台加入到选择的集合中</span><br><span class="line">        ArrayList&lt;String&gt; selects = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //定义一个数组,用于存放每个电台与还未覆盖地区的交集的个数</span><br><span class="line">        int arr[] = new int[broadcasts.size()];//长度为电台总个数</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();//存放电台集合</span><br><span class="line">        arrayList.add(&quot;k1&quot;);</span><br><span class="line">        arrayList.add(&quot;k2&quot;);</span><br><span class="line">        arrayList.add(&quot;k3&quot;);</span><br><span class="line">        arrayList.add(&quot;k4&quot;);</span><br><span class="line">        arrayList.add(&quot;k5&quot;);</span><br><span class="line"></span><br><span class="line">        while (allAreas.size() &gt; 0) &#123;</span><br><span class="line">            System.out.println(&quot;需要覆盖的地区&quot;);</span><br><span class="line">            System.out.println(allAreas.toString());</span><br><span class="line">            System.out.println();</span><br><span class="line">            int index = 0;//手动创建索引</span><br><span class="line">            //遍历广播电台</span><br><span class="line">            for (Map.Entry&lt;String, HashSet&gt; stringHashSetEntry : broadcasts.entrySet()) &#123;</span><br><span class="line">                String key = stringHashSetEntry.getKey();//得到电台名称</span><br><span class="line">                HashSet&lt;String&gt; value = stringHashSetEntry.getValue();//得到每个电台对应的覆盖地区</span><br><span class="line">                int count = 0;</span><br><span class="line">                for (String s : value) &#123;</span><br><span class="line">                    if (allAreas.contains(s)) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[index] = count;</span><br><span class="line">                index++;</span><br><span class="line">                //每次循环完成之后count为当前k1电台与allAreas的交集的个数</span><br><span class="line">            &#125;</span><br><span class="line">            //所有的循环完成之后即得到了存放交集的arr，遍历数组取出最大值</span><br><span class="line">            // 将对应的电台加入selects电台集合</span><br><span class="line">            // 并且将该电台所覆盖的地区从需要覆盖的地区中去除</span><br><span class="line">            int max = 0;</span><br><span class="line">            int index2 = 0;//记录最大值所在的索引</span><br><span class="line">            for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                if (arr[i] &gt; max) &#123;</span><br><span class="line">                    max = arr[i];</span><br><span class="line">                    index2 = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //循环结束即得到了最大值的索引，添加对应的电台到电台集合</span><br><span class="line">            selects.add(arrayList.get(index2));//&quot;k1&quot;</span><br><span class="line">            System.out.println(&quot;得到的电台为：&quot; + arrayList.get(index2));</span><br><span class="line">            //移除对应电台所覆盖的地区</span><br><span class="line">            HashSet&lt;String&gt; hashSet = broadcasts.get(arrayList.get(index2));//得到&quot;k1&quot;电台对应覆盖地区的集合</span><br><span class="line">            for (String s : hashSet) &#123;</span><br><span class="line">                allAreas.remove(s);</span><br><span class="line">            &#125;//移除了地区</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;得到的电台为：&quot; + selects.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六：普利姆算法-修路问题"><a href="#六：普利姆算法-修路问题" class="headerlink" title="六：普利姆算法-修路问题"></a>六：普利姆算法-修路问题</h3><p>1：普里姆算法（Prim算法）简介-最小生成树MST</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）发现；并在1957年由美国计算机科学家罗伯特·普里姆（英语：Robert C. Prim）独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。</span><br></pre></td></tr></table></figure><p>2：算法描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1).输入：一个加权连通图，其中顶点集合为V，边集合为E；</span><br><span class="line">2).初始化：Vnew = &#123;x&#125;，其中x为集合V中的任一节点（起始点），Enew = &#123;&#125;,为空；</span><br><span class="line">3).重复下列操作，直到Vnew = V：</span><br><span class="line">a.在集合E中选取权值最小的边&lt;u, v&gt;，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</span><br><span class="line">b.将v加入集合Vnew中，将&lt;u, v&gt;边加入集合Enew中；</span><br><span class="line">4).输出：使用集合Vnew和Enew来描述所得到的最小生成树。</span><br><span class="line"></span><br><span class="line">图解见：https://baike.baidu.com/item/Prim/10242166?fr=aladdin#1</span><br></pre></td></tr></table></figure><p>3：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">package com.it.prim;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">//普利姆算法</span><br><span class="line">public class PrimAlgorithm &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//测试图是否创建成功</span><br><span class="line">        char[] data = new char[]&#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</span><br><span class="line">        int verxs = data.length;</span><br><span class="line">        //邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通</span><br><span class="line">        int[][] weight = new int[][]&#123;</span><br><span class="line">                &#123;10000, 5, 7, 10000, 10000, 10000, 2&#125;,</span><br><span class="line">                &#123;5, 10000, 10000, 9, 10000, 10000, 3&#125;,</span><br><span class="line">                &#123;7, 10000, 10000, 10000, 8, 10000, 10000&#125;,</span><br><span class="line">                &#123;10000, 9, 10000, 10000, 10000, 4, 10000&#125;,</span><br><span class="line">                &#123;10000, 10000, 8, 10000, 10000, 5, 4&#125;,</span><br><span class="line">                &#123;10000, 10000, 10000, 4, 5, 10000, 6&#125;,</span><br><span class="line">                &#123;2, 3, 10000, 10000, 4, 6, 10000&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        //创建MGraph对象</span><br><span class="line">        MGraph graph = new MGraph(verxs);</span><br><span class="line">        //创建一个MinTree对象</span><br><span class="line">        MinTree minTree = new MinTree();</span><br><span class="line">        minTree.createGraph(graph, verxs, data, weight);</span><br><span class="line">        //输出</span><br><span class="line">        minTree.showGraph(graph);</span><br><span class="line">        //测试普利姆算法</span><br><span class="line">        minTree.prim(graph, 1);//</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//构建最小生成树--&gt;村庄的图</span><br><span class="line">class MinTree &#123;</span><br><span class="line">    //创建图的临接矩阵</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param graph  图对象</span><br><span class="line">     * @param verxs  图对应的顶点的个数</span><br><span class="line">     * @param data   图的各个顶点的值</span><br><span class="line">     * @param weight 图的临接矩阵</span><br><span class="line">     *               初始化图对象</span><br><span class="line">     */</span><br><span class="line">    public void createGraph(MGraph graph, int verxs, char data[], int[][] weight) &#123;</span><br><span class="line">        int i, j;</span><br><span class="line">        for (i = 0; i &lt; verxs; i++) &#123;//顶点</span><br><span class="line">            graph.data[i] = data[i];</span><br><span class="line">            for (j = 0; j &lt; verxs; j++) &#123;</span><br><span class="line">                graph.weight[i][j] = weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历图，显示图的临接矩阵</span><br><span class="line">    public void showGraph(MGraph graph) &#123;</span><br><span class="line">        for (int[] link : graph.weight) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//编写prim算法，得到最小生成树</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param graph 图</span><br><span class="line">     * @param v     表示从图的第几个顶点开始生成&apos;A&apos;-&gt;0 &apos;B&apos;-&gt;1...</span><br><span class="line">     */</span><br><span class="line">    public void prim(MGraph graph, int v) &#123;</span><br><span class="line">        //visited[] 标记结点(顶点)是否被访问过</span><br><span class="line">        int visited[] = new int[graph.verxs];</span><br><span class="line">        //visited[] 默认元素的值都是0, 表示没有访问过</span><br><span class="line">//for(int i =0; i &lt;graph.verxs; i++) &#123;</span><br><span class="line">//visited[i] = 0;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">        //把当前这个结点标记为已访问</span><br><span class="line">        visited[v] = 1;</span><br><span class="line">        //h1 和 h2 记录两个顶点的下标</span><br><span class="line">        int h1 = -1;</span><br><span class="line">        int h2 = -1;</span><br><span class="line">        int minWeight = 10000; //将 minWeight 初始成一个大数，后面在遍历过程中，会被替换</span><br><span class="line">        for (int k = 1; k &lt; graph.verxs; k++) &#123;//因为有 graph.verxs顶点，普利姆算法结束后，有 graph.verxs-1边</span><br><span class="line"></span><br><span class="line">            //这个是确定每一次生成的子图 ，和哪个结点的距离最近</span><br><span class="line">            for (int i = 0; i &lt; graph.verxs; i++) &#123;// i结点表示被访问过的结点</span><br><span class="line">                for (int j = 0; j &lt; graph.verxs; j++) &#123;//j结点表示还没有访问过的结点</span><br><span class="line">                    if (visited[i] == 1 &amp;&amp; visited[j] == 0 &amp;&amp; graph.weight[i][j] &lt; minWeight) &#123;</span><br><span class="line">                        //替换minWeight(寻找已经访问过的结点和未访问过的结点间的权值最小的边)</span><br><span class="line">                        minWeight = graph.weight[i][j];</span><br><span class="line">                        h1 = i;</span><br><span class="line">                        h2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //找到一条边是最小</span><br><span class="line">            System.out.println(&quot;边&lt;&quot; + graph.data[h1] + &quot;,&quot; + graph.data[h2] + &quot;&gt; 权值:&quot; + minWeight);</span><br><span class="line">            //将当前这个结点标记为已经访问</span><br><span class="line">            visited[h2] = 1;</span><br><span class="line">            //minWeight 重新设置为最大值 10000</span><br><span class="line">            minWeight = 10000;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//图</span><br><span class="line">class MGraph &#123;</span><br><span class="line">    int verxs;//表示图的节点个数</span><br><span class="line">    char[] data;//存放节点的数据</span><br><span class="line">    int[][] weight;//存放边，临接矩阵</span><br><span class="line"></span><br><span class="line">    public MGraph(int verxs) &#123;//构造器</span><br><span class="line">        this.verxs = verxs;</span><br><span class="line">        data = new char[verxs];</span><br><span class="line">        weight = new int[verxs][verxs];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七：克鲁斯卡尔算法-公交站问题"><a href="#七：克鲁斯卡尔算法-公交站问题" class="headerlink" title="七：克鲁斯卡尔算法-公交站问题"></a>七：克鲁斯卡尔算法-公交站问题</h3><p>1：Kruskal算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Kruskal算法是一种用来查找最小生成树的算法，由Joseph Kruskal在1956年发表。用来解决同样问题的还有Prim算法和Boruvka算法等。三种算法都是贪心算法的应用。和Boruvka算法不同的地方是，Kruskal算法在图中存在相同权值的边时也有效。 </span><br><span class="line"> </span><br><span class="line">1：新建图G，G中拥有原图中相同的节点，但没有边；</span><br><span class="line">2：将原图中所有的边按权值从小到大排序；</span><br><span class="line">3：从权值最小的边开始，如果这条边连接的两个节点于图G中不会形成回路，则添加这条边到图G中；</span><br><span class="line">4：重复3，直至图G中所有的节点都在同一个连通分量中。</span><br><span class="line"></span><br><span class="line">核心思想是不要形成回路，如何判断如何形成了回路！需要加入边的两个顶点不能指向同一个终点。</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">核心代码：获取终点的方法</span><br><span class="line">/**</span><br><span class="line">    * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同</span><br><span class="line">    * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成</span><br><span class="line">    * @param i : 表示传入的顶点对应的下标</span><br><span class="line">    * @return 返回的就是 下标为i的这个顶点对应的终点的下标, 一会回头还有来理解</span><br><span class="line">    */</span><br><span class="line">   private int getEnd(int[] ends, int i) &#123; // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]</span><br><span class="line">       while(ends[i] != 0) &#123;</span><br><span class="line">           i = ends[i];</span><br><span class="line">       &#125;</span><br><span class="line">       return i;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">package com.it.kruskalCase;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class KruskalCase &#123;</span><br><span class="line"></span><br><span class="line">    private int edgeNum; //边的个数</span><br><span class="line">    private char[] vertexs; //顶点数组</span><br><span class="line">    private int[][] matrix; //邻接矩阵</span><br><span class="line">    //使用 INF 表示两个顶点不能连通</span><br><span class="line">    private static final int INF = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        char[] vertexs = &#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</span><br><span class="line">        //克鲁斯卡尔算法的邻接矩阵</span><br><span class="line">        int matrix[][] = &#123;</span><br><span class="line">                /*A*//*B*//*C*//*D*//*E*//*F*//*G*/</span><br><span class="line">                /*A*/ &#123;   0,  12, INF, INF, INF,  16,  14&#125;,</span><br><span class="line">                /*B*/ &#123;  12,   0,  10, INF, INF,   7, INF&#125;,</span><br><span class="line">                /*C*/ &#123; INF,  10,   0,   3,   5,   6, INF&#125;,</span><br><span class="line">                /*D*/ &#123; INF, INF,   3,   0,   4, INF, INF&#125;,</span><br><span class="line">                /*E*/ &#123; INF, INF,   5,   4,   0,   2,   8&#125;,</span><br><span class="line">                /*F*/ &#123;  16,   7,   6, INF,   2,   0,   9&#125;,</span><br><span class="line">                /*G*/ &#123;  14, INF, INF, INF,   8,   9,   0&#125;&#125;;</span><br><span class="line">        //大家可以在去测试其它的邻接矩阵，结果都可以得到最小生成树.</span><br><span class="line"></span><br><span class="line">        //创建KruskalCase 对象实例</span><br><span class="line">        KruskalCase kruskalCase = new KruskalCase(vertexs, matrix);</span><br><span class="line">        //输出构建的</span><br><span class="line">        kruskalCase.print();</span><br><span class="line">        kruskalCase.kruskal();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public KruskalCase(char[] vertexs, int[][] matrix) &#123;</span><br><span class="line">        //初始化顶点数和边的个数</span><br><span class="line">        int vlen = vertexs.length;</span><br><span class="line"></span><br><span class="line">        //初始化顶点, 复制拷贝的方式</span><br><span class="line">        this.vertexs = new char[vlen];</span><br><span class="line">        for(int i = 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            this.vertexs[i] = vertexs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //初始化边, 使用的是复制拷贝的方式</span><br><span class="line">        this.matrix = new int[vlen][vlen];</span><br><span class="line">        for(int i = 0; i &lt; vlen; i++) &#123;</span><br><span class="line">            for(int j= 0; j &lt; vlen; j++) &#123;</span><br><span class="line">                this.matrix[i][j] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //统计边的条数</span><br><span class="line">        for(int i =0; i &lt; vlen; i++) &#123;</span><br><span class="line">            for(int j = i+1; j &lt; vlen; j++) &#123;</span><br><span class="line">                if(this.matrix[i][j] != INF) &#123;</span><br><span class="line">                    edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void kruskal() &#123;</span><br><span class="line">        int index = 0; //表示最后结果数组的索引</span><br><span class="line">        int[] ends = new int[edgeNum]; //用于保存&quot;已有最小生成树&quot; 中的每个顶点在最小生成树中的终点</span><br><span class="line">        //创建结果数组, 保存最后的最小生成树</span><br><span class="line">        EData[] rets = new EData[edgeNum];</span><br><span class="line"></span><br><span class="line">        //获取图中 所有的边的集合 ， 一共有12边</span><br><span class="line">        EData[] edges = getEdges();</span><br><span class="line">        System.out.println(&quot;图的边的集合=&quot; + Arrays.toString(edges) + &quot; 共&quot;+ edges.length); //12</span><br><span class="line"></span><br><span class="line">        //按照边的权值大小进行排序(从小到大)</span><br><span class="line">        sortEdges(edges);</span><br><span class="line"></span><br><span class="line">        //遍历edges 数组，将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入 rets, 否则不能加入</span><br><span class="line">        for(int i=0; i &lt; edgeNum; i++) &#123;</span><br><span class="line">            //获取到第i条边的第一个顶点(起点)</span><br><span class="line">            int p1 = getPosition(edges[i].start); //p1=4</span><br><span class="line">            //获取到第i条边的第2个顶点</span><br><span class="line">            int p2 = getPosition(edges[i].end); //p2 = 5</span><br><span class="line"></span><br><span class="line">            //获取p1这个顶点在已有最小生成树中的终点</span><br><span class="line">            int m = getEnd(ends, p1); //m = 4</span><br><span class="line">            //获取p2这个顶点在已有最小生成树中的终点</span><br><span class="line">            int n = getEnd(ends, p2); // n = 5</span><br><span class="line">            //是否构成回路</span><br><span class="line">            if(m != n) &#123; //没有构成回路</span><br><span class="line">                ends[m] = n; // 设置m 在&quot;已有最小生成树&quot;中的终点 &lt;E,F&gt; [0,0,0,0,5,0,0,0,0,0,0,0]</span><br><span class="line">                rets[index++] = edges[i]; //有一条边加入到rets数组</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。</span><br><span class="line">        //统计并打印 &quot;最小生成树&quot;, 输出  rets</span><br><span class="line">        System.out.println(&quot;最小生成树为&quot;);</span><br><span class="line">        for(int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">            System.out.println(rets[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印邻接矩阵</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;邻接矩阵为: \n&quot;);</span><br><span class="line">        for(int i = 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            for(int j=0; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                System.out.printf(&quot;%12d&quot;, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();//换行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 功能：对边进行排序处理, 冒泡排序</span><br><span class="line">     * @param edges 边的集合</span><br><span class="line">     */</span><br><span class="line">    private void sortEdges(EData[] edges) &#123;</span><br><span class="line">        for(int i = 0; i &lt; edges.length - 1; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; edges.length - 1 - i; j++) &#123;</span><br><span class="line">                if(edges[j].weight &gt; edges[j+1].weight) &#123;//交换</span><br><span class="line">                    EData tmp = edges[j];</span><br><span class="line">                    edges[j] = edges[j+1];</span><br><span class="line">                    edges[j+1] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param ch 顶点的值，比如&apos;A&apos;,&apos;B&apos;</span><br><span class="line">     * @return 返回ch顶点对应的下标，如果找不到，返回-1</span><br><span class="line">     */</span><br><span class="line">    private int getPosition(char ch) &#123;</span><br><span class="line">        for(int i = 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            if(vertexs[i] == ch) &#123;//找到</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //找不到,返回-1</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 功能: 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组</span><br><span class="line">     * 是通过matrix 邻接矩阵来获取</span><br><span class="line">     * EData[] 形式 [[&apos;A&apos;,&apos;B&apos;, 12], [&apos;B&apos;,&apos;F&apos;,7], .....]</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private EData[] getEdges() &#123;</span><br><span class="line">        int index = 0;</span><br><span class="line">        EData[] edges = new EData[edgeNum];</span><br><span class="line">        for(int i = 0; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            for(int j=i+1; j &lt;vertexs.length; j++) &#123;</span><br><span class="line">                if(matrix[i][j] != INF) &#123;</span><br><span class="line">                    edges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return edges;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同</span><br><span class="line">     * @param ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成</span><br><span class="line">     * @param i : 表示传入的顶点对应的下标</span><br><span class="line">     * @return 返回的就是 下标为i的这个顶点对应的终点的下标, 一会回头还有来理解</span><br><span class="line">     */</span><br><span class="line">    private int getEnd(int[] ends, int i) &#123; // i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]</span><br><span class="line">        while(ends[i] != 0) &#123;</span><br><span class="line">            i = ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建一个类EData ，它的对象实例就表示一条边</span><br><span class="line">class EData &#123;</span><br><span class="line">    char start; //边的一个点</span><br><span class="line">    char end; //边的另外一个点</span><br><span class="line">    int weight; //边的权值</span><br><span class="line">    //构造器</span><br><span class="line">    public EData(char start, char end, int weight) &#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    //重写toString, 便于输出边信息</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;EData [&lt;&quot; + start + &quot;, &quot; + end + &quot;&gt;= &quot; + weight + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八：迪杰斯特拉算法-最短路径问题"><a href="#八：迪杰斯特拉算法-最短路径问题" class="headerlink" title="八：迪杰斯特拉算法-最短路径问题"></a>八：迪杰斯特拉算法-最短路径问题</h3><p>1：迪杰斯特拉算法介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</span><br><span class="line"></span><br><span class="line">通过被选定的单一顶点源，思想主要是图的广度优先算法。</span><br></pre></td></tr></table></figure><p>2：实现步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.指定一个节点，例如我们要计算 &apos;A&apos; 到其他节点的最短路径</span><br><span class="line"></span><br><span class="line">2.引入两个集合（S、U），S集合包含已求出的最短路径的点（以及相应的最短长度），U集合包含未求出最短路径的点（以及A到该点的路径，注意 A-&gt;C由于没有直接相连 初始时为∞）</span><br><span class="line"></span><br><span class="line">3.初始化两个集合，S集合初始时 只有当前要计算的节点，A-&gt;A = 0，</span><br><span class="line">U集合初始时为 A-&gt;B = 4, A-&gt;C = ∞, A-&gt;D = 2, A-&gt;E = ∞，</span><br><span class="line"></span><br><span class="line">4.从U集合中找出路径最短的点，加入S集合，例如 A-&gt;D = 2</span><br><span class="line"></span><br><span class="line">5:更新U集合路径，if ( &apos;AD 距离&apos;+&apos;D 到 B,C,E 的距离&apos;   &lt; &apos;A 到 B,C,E 的距离&apos; ) 则更新U</span><br><span class="line"></span><br><span class="line">6:循环执行 4、5 两步骤，直至遍历结束，得到A 到其他节点的最短路径</span><br></pre></td></tr></table></figure><p>3：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">核心思想：</span><br><span class="line">1：第一次可以找到和A相邻最短的临接节点“例如K”，即A到该节点&quot;K&quot;路径最短；</span><br><span class="line">这时如果A到K的路径+“K”到其他节点的路径 &lt;A直接到其他节点的路径</span><br><span class="line">则需要更新A到其他节点路径最短的集合</span><br><span class="line">2：这一次又可以找到和A相邻的第二短的节点</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package com.it.dijkstra;</span><br><span class="line"></span><br><span class="line">public class Dijkstra &#123;</span><br><span class="line">    public static final int M = 10000; // 代表正无穷</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 二维数组每一行分别是 A、B、C、D、E 各点到其余点的距离,</span><br><span class="line">        // A -&gt; A 距离为0, 常量M 为正无穷</span><br><span class="line">        int[][] weight1 = &#123;</span><br><span class="line">                &#123;0, 4, M, 2, M&#125;,</span><br><span class="line">                &#123;4, 0, 4, 1, M&#125;,</span><br><span class="line">                &#123;M, 4, 0, 1, 3&#125;,</span><br><span class="line">                &#123;2, 1, 1, 0, 7&#125;,</span><br><span class="line">                &#123;M, M, 3, 7, 0&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        int start = 0;</span><br><span class="line"></span><br><span class="line">        int[] shortPath = dijkstra(weight1, start);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; shortPath.length; i++) &#123;</span><br><span class="line">            System.out.println(&quot;从&quot; + start + &quot;出发到&quot; + i + &quot;的最短距离为：&quot; + shortPath[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int[] dijkstra(int[][] weight, int start) &#123;</span><br><span class="line">        // 接受一个有向图的权重矩阵，和一个起点编号start（从0编号，顶点存在数组中）</span><br><span class="line">        // 返回一个int[] 数组，表示从start到它的最短路径长度</span><br><span class="line">        int n = weight.length; // 顶点个数</span><br><span class="line">        int[] shortPath = new int[n]; // 保存start到其他各点的最短路径</span><br><span class="line">        String[] path = new String[n]; // 保存start到其他各点最短路径的字符串表示</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            path[i] = start + &quot;--&gt;&quot; + i;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] visited = new int[n]; // 标记当前该顶点的最短路径是否已经求出,1表示已求出</span><br><span class="line"></span><br><span class="line">        // 初始化，第一个顶点已经求出</span><br><span class="line">        shortPath[start] = 0;</span><br><span class="line">        visited[start] = 1;</span><br><span class="line"></span><br><span class="line">        for (int count = 1; count &lt; n; count++) &#123; // 要加入n-1个顶点</span><br><span class="line">            int k = -1; // 选出一个距离初始顶点start最近的未标记顶点</span><br><span class="line">            int dmin = Integer.MAX_VALUE;</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                if (visited[i] == 0 &amp;&amp; weight[start][i] &lt; dmin) &#123;</span><br><span class="line">                    dmin = weight[start][i];</span><br><span class="line">                    k = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 将新选出的顶点标记为已求出最短路径，且到start的最短路径就是dmin</span><br><span class="line">            shortPath[k] = dmin;</span><br><span class="line">            visited[k] = 1;</span><br><span class="line"></span><br><span class="line">            // 以k为中间点，修正从start到未访问各点的距离</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                //如果 &apos;起始点到当前点距离&apos; + &apos;当前点到某点距离&apos; &lt; &apos;起始点到某点距离&apos;, 则更新</span><br><span class="line">                if (visited[i] == 0 &amp;&amp; weight[start][k] + weight[k][i] &lt; weight[start][i]) &#123;</span><br><span class="line">                    weight[start][i] = weight[start][k] + weight[k][i];</span><br><span class="line">                    path[i] = path[k] + &quot;--&gt;&quot; + i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;从&quot; + start + &quot;出发到&quot; + i + &quot;的最短路径为：&quot; + path[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;=====================================&quot;);</span><br><span class="line">        return shortPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九：弗洛伊德算法-最短路径"><a href="#九：弗洛伊德算法-最短路径" class="headerlink" title="九：弗洛伊德算法-最短路径"></a>九：弗洛伊德算法-最短路径</h3><p>1：Floyd算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。</span><br><span class="line"></span><br><span class="line">注意：目标是多源点，该算法的时间复杂度为（n^3）</span><br></pre></td></tr></table></figure><p>2：思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。</span><br><span class="line">2，对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。</span><br><span class="line">把图用邻接矩阵G表示出来，如果从Vi到Vj有路可达，则G[i][j]=d，d表示该路的长度；否则G[i][j]=无穷大。定义一个矩阵D用来记录所插入点的信息，D[i][j]表示从Vi到Vj需要经过的点，初始化D[i][j]=j。把各个顶点插入图中，比较插点后的距离与原来的距离，G[i][j] = min( G[i][j], G[i][k]+G[k][j] )，如果G[i][j]的值变小，则D[i][j]=k。在G中包含有两点之间最短道路的信息，而在D中则包含了最短通路径的信息。</span><br><span class="line">比如，要寻找从V5到V1的路径。根据D，假如D(5,1)=3则说明从V5到V1经过V3，路径为&#123;V5,V3,V1&#125;，如果D(5,3)=3，说明V5与V3直接相连，如果D(3,1)=1，说明V3与V1直接相连。</span><br></pre></td></tr></table></figure><p>3：其他</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Floyd算法适用于APSP(All Pairs Shortest Paths，多源最短路径)，是一种动态规划算法，稠密图效果最佳，边权可正可负。此算法简单有效，由于三重循环结构紧凑，对于稠密图，效率要高于执行|V|次Dijkstra算法，也要高于执行|V|次SPFA算法。</span><br><span class="line">优点：容易理解，可以算出任意两个节点之间的最短距离，代码编写简单。</span><br><span class="line">缺点：时间复杂度比较高，不适合计算大量数据。</span><br></pre></td></tr></table></figure><p>4：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package com.it.floyd;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class FloydAlgorithm &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 测试看看图是否创建成功</span><br><span class="line">        char[] vertex = &#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</span><br><span class="line">        //创建邻接矩阵</span><br><span class="line">        int[][] matrix = new int[vertex.length][vertex.length];</span><br><span class="line">        final int N = 65535;</span><br><span class="line">        matrix[0] = new int[]&#123;0, 5, 7, N, N, N, 2&#125;;</span><br><span class="line">        matrix[1] = new int[]&#123;5, 0, N, 9, N, N, 3&#125;;</span><br><span class="line">        matrix[2] = new int[]&#123;7, N, 0, N, 8, N, N&#125;;</span><br><span class="line">        matrix[3] = new int[]&#123;N, 9, N, 0, N, 4, N&#125;;</span><br><span class="line">        matrix[4] = new int[]&#123;N, N, 8, N, 0, 5, 4&#125;;</span><br><span class="line">        matrix[5] = new int[]&#123;N, N, N, 4, 5, 0, 6&#125;;</span><br><span class="line">        matrix[6] = new int[]&#123;2, 3, N, N, 4, 6, 0&#125;;</span><br><span class="line"></span><br><span class="line">        //创建 Graph 对象</span><br><span class="line">        Graph graph = new Graph(vertex.length, matrix, vertex);</span><br><span class="line">        //调用弗洛伊德算法</span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建图</span><br><span class="line">class Graph &#123;</span><br><span class="line">    private char[] vertex; // 存放顶点的数组</span><br><span class="line">    private int[][] dis; // 保存，从各个顶点出发到其它顶点的距离，最后的结果，也是保留在该数组</span><br><span class="line">    private int[][] pre;// 保存到达目标顶点的前驱顶点</span><br><span class="line"></span><br><span class="line">    // 构造器</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param length 大小</span><br><span class="line">     * @param matrix 邻接矩阵</span><br><span class="line">     * @param vertex 顶点数组</span><br><span class="line">     */</span><br><span class="line">    public Graph(int length, int[][] matrix, char[] vertex) &#123;</span><br><span class="line">        this.vertex = vertex;</span><br><span class="line">        this.dis = matrix;</span><br><span class="line">        this.pre = new int[length][length];</span><br><span class="line">        // 对pre数组初始化, 注意存放的是前驱顶点的下标</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            Arrays.fill(pre[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 显示pre数组和dis数组</span><br><span class="line">    public void show() &#123;</span><br><span class="line"></span><br><span class="line">        //为了显示便于阅读，我们优化一下输出</span><br><span class="line">        char[] vertex = &#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</span><br><span class="line">        for (int k = 0; k &lt; dis.length; k++) &#123;</span><br><span class="line">            // 先将pre数组输出的一行</span><br><span class="line">            for (int i = 0; i &lt; dis.length; i++) &#123;</span><br><span class="line">                System.out.print(vertex[pre[k][i]] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            // 输出dis数组的一行数据</span><br><span class="line">            for (int i = 0; i &lt; dis.length; i++) &#123;</span><br><span class="line">                System.out.print(&quot;(&quot; + vertex[k] + &quot;到&quot; + vertex[i] + &quot;的最短路径是&quot; + dis[k][i] + &quot;) &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void floyd() &#123;</span><br><span class="line">        int len = 0; //变量保存距离</span><br><span class="line">        //对中间顶点遍历， k 就是中间顶点的下标 [A, B, C, D, E, F, G]</span><br><span class="line">        for (int k = 0; k &lt; dis.length; k++) &#123; //</span><br><span class="line">            //从i顶点开始出发 [A, B, C, D, E, F, G]</span><br><span class="line">            for (int i = 0; i &lt; dis.length; i++) &#123;</span><br><span class="line">                //到达j顶点 // [A, B, C, D, E, F, G]</span><br><span class="line">                for (int j = 0; j &lt; dis.length; j++) &#123;</span><br><span class="line">                    len = dis[i][k] + dis[k][j];// =&gt; 求出从i 顶点出发，经过 k中间顶点，到达 j 顶点距离</span><br><span class="line">                    if (len &lt; dis[i][j]) &#123;//如果len小于 dis[i][j]</span><br><span class="line">                        dis[i][j] = len;//更新距离</span><br><span class="line">                        pre[i][j] = pre[k][j];//更新前驱顶点</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十：马踏棋盘算法-骑士周游"><a href="#十：马踏棋盘算法-骑士周游" class="headerlink" title="十：马踏棋盘算法-骑士周游"></a>十：马踏棋盘算法-骑士周游</h3><p>1：简介</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将马随机放在国际象棋的Board[0～7][0～7]的某个方格中，马按走棋规则进行移动。，走遍棋盘上全部64个方格。编制非递归程序，求出马的行走路线，并按求出的行走路线，将数字1，2，…，64依次填入一个8×8的方阵，输出之。</span><br></pre></td></tr></table></figure><p>2：思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：可以用图的深度优先遍历+回溯；即一直走到底，然后发现走不通之后回溯</span><br><span class="line">2：问题所在，深度为64，回溯次数太多，栈中会产生很多方法！</span><br><span class="line">3：记录马下一步位置0-7，哪些可以走</span><br></pre></td></tr></table></figure><p>3：优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">贪心算法思路：</span><br><span class="line">如,当马儿接下来有8种方式都可以走，把种方式对应的下一次可以走的方式为1,1,2,3,4,4,4,5（已经进行了非递减排序）</span><br><span class="line">那么下一步直接选择下一步对应的下一步最小的位置进行，减少回溯的次数。</span><br><span class="line"></span><br><span class="line"> //根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数</span><br><span class="line">    public static void sort(ArrayList&lt;Point&gt; ps) &#123;</span><br><span class="line">        ps.sort(new Comparator&lt;Point&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Point o1, Point o2) &#123;</span><br><span class="line">                //获取到o1的下一步的所有位置个数</span><br><span class="line">                int count1 = next(o1).size();</span><br><span class="line">                //获取到o2的下一步的所有位置个数</span><br><span class="line">                int count2 = next(o2).size();</span><br><span class="line">                if (count1 &lt; count2) &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125; else if (count1 == count2) &#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>4：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">核心代码：</span><br><span class="line"> while(!ps.isEmpty()) &#123;</span><br><span class="line">            Point p = ps.remove(0);//取出下一个可以走的位置</span><br><span class="line">            //判断该点是否已经访问过</span><br><span class="line">            if(!visited[p.y * X + p.x]) &#123;//说明还没有访问过</span><br><span class="line">                traversalChessboard(chessboard, p.y, p.x, step + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿是否完成了任务，使用   step 和应该走的步数比较 ，</span><br><span class="line">        //如果没有达到数量，则表示没有完成任务，将整个棋盘置0</span><br><span class="line">        //说明: step &lt; X * Y  成立的情况有两种</span><br><span class="line">        //1. 棋盘到目前位置,仍然没有走完</span><br><span class="line">        //2. 棋盘处于一个回溯过程</span><br><span class="line">        if(step &lt; X * Y &amp;&amp; !finished ) &#123;</span><br><span class="line">            chessboard[row][column] = 0;</span><br><span class="line">            visited[row * X + column] = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            finished = true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">package com.it.hourse;</span><br><span class="line"></span><br><span class="line">import java.awt.Point;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">public class HorseChessboard &#123;</span><br><span class="line"></span><br><span class="line">    private static int X; // 棋盘的列数</span><br><span class="line">    private static int Y; // 棋盘的行数</span><br><span class="line">    //创建一个数组，标记棋盘的各个位置是否被访问过</span><br><span class="line">    private static boolean visited[];</span><br><span class="line">    //使用一个属性，标记是否棋盘的所有位置都被访问</span><br><span class="line">    private static boolean finished; // 如果为true,表示成功</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;骑士周游算法，开始运行~~&quot;);</span><br><span class="line">        //测试骑士周游算法是否正确</span><br><span class="line">        X = 8;</span><br><span class="line">        Y = 8;</span><br><span class="line">        int row = 2; //马儿初始位置的行，从2开始编号</span><br><span class="line">        int column = 2; //马儿初始位置的列，从1开始编号</span><br><span class="line">        //创建棋盘</span><br><span class="line">        int[][] chessboard = new int[X][Y];</span><br><span class="line">        visited = new boolean[X * Y];//初始值都是false</span><br><span class="line">        //测试一下耗时</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        traversalChessboard(chessboard, row - 1, column - 1, 1);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;共耗时: &quot; + (end - start) + &quot; 毫秒&quot;);</span><br><span class="line"></span><br><span class="line">        //输出棋盘的最后情况</span><br><span class="line">        for(int[] rows : chessboard) &#123;</span><br><span class="line">            for(int step: rows) &#123;</span><br><span class="line">                System.out.print(step + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 完成骑士周游问题的算法</span><br><span class="line">     * @param chessboard 棋盘</span><br><span class="line">     * @param row 马儿当前的位置的行 从0开始</span><br><span class="line">     * @param column 马儿当前的位置的列  从0开始</span><br><span class="line">     * @param step 是第几步 ,初始位置就是第1步</span><br><span class="line">     */</span><br><span class="line">    public static void traversalChessboard(int[][] chessboard, int row, int column, int step) &#123;</span><br><span class="line">        chessboard[row][column] = step;</span><br><span class="line">        //row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36</span><br><span class="line">        visited[row * X + column] = true; //标记该位置已经访问</span><br><span class="line">        //获取当前位置可以走的下一个位置的集合</span><br><span class="line">        ArrayList&lt;Point&gt; ps = next(new Point(column, row));</span><br><span class="line">        //对ps进行排序,排序的规则就是对ps的所有的Point对象的下一步的位置的数目，进行非递减排序</span><br><span class="line">        sort(ps);</span><br><span class="line">        //遍历 ps</span><br><span class="line">        while(!ps.isEmpty()) &#123;</span><br><span class="line">            Point p = ps.remove(0);//取出下一个可以走的位置</span><br><span class="line">            //判断该点是否已经访问过</span><br><span class="line">            if(!visited[p.y * X + p.x]) &#123;//说明还没有访问过</span><br><span class="line">                traversalChessboard(chessboard, p.y, p.x, step + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿是否完成了任务，使用   step 和应该走的步数比较 ，</span><br><span class="line">        //如果没有达到数量，则表示没有完成任务，将整个棋盘置0</span><br><span class="line">        //说明: step &lt; X * Y  成立的情况有两种</span><br><span class="line">        //1. 棋盘到目前位置,仍然没有走完</span><br><span class="line">        //2. 棋盘处于一个回溯过程</span><br><span class="line">        if(step &lt; X * Y &amp;&amp; !finished ) &#123;</span><br><span class="line">            chessboard[row][column] = 0;</span><br><span class="line">            visited[row * X + column] = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            finished = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 功能： 根据当前位置(Point对象)，计算马儿还能走哪些位置(Point)，并放入到一个集合中(ArrayList), 最多有8个位置</span><br><span class="line">     * @param curPoint</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static ArrayList&lt;Point&gt; next(Point curPoint) &#123;</span><br><span class="line">        //创建一个ArrayList</span><br><span class="line">        ArrayList&lt;Point&gt; ps = new ArrayList&lt;Point&gt;();</span><br><span class="line">        //创建一个Point</span><br><span class="line">        Point p1 = new Point();</span><br><span class="line">        //表示马儿可以走5这个位置</span><br><span class="line">        if((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y -1) &gt;= 0) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走6这个位置</span><br><span class="line">        if((p1.x = curPoint.x - 1) &gt;=0 &amp;&amp; (p1.y=curPoint.y-2)&gt;=0) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走7这个位置</span><br><span class="line">        if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y - 2) &gt;= 0) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走0这个位置</span><br><span class="line">        if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y - 1) &gt;= 0) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走1这个位置</span><br><span class="line">        if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走2这个位置</span><br><span class="line">        if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走3这个位置</span><br><span class="line">        if ((p1.x = curPoint.x - 1) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        //判断马儿可以走4这个位置</span><br><span class="line">        if ((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) &#123;</span><br><span class="line">            ps.add(new Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        return ps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数</span><br><span class="line">    public static void sort(ArrayList&lt;Point&gt; ps) &#123;</span><br><span class="line">        ps.sort(new Comparator&lt;Point&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Point o1, Point o2) &#123;</span><br><span class="line">                // TODO Auto-generated method stub</span><br><span class="line">                //获取到o1的下一步的所有位置个数</span><br><span class="line">                int count1 = next(o1).size();</span><br><span class="line">                //获取到o2的下一步的所有位置个数</span><br><span class="line">                int count2 = next(o2).size();</span><br><span class="line">                if(count1 &lt; count2) &#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125; else if (count1 == count2) &#123;</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：算法&quot;&gt;&lt;a href=&quot;#1：算法&quot; class=&quot;headerlink&quot; title=&quot;1：算法&quot;&gt;&lt;/a&gt;1：算法&lt;/h1&gt;&lt;h3 id=&quot;1：二分查找：非递归&quot;&gt;&lt;a href=&quot;#1：二分查找：非递归&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（9）图</title>
    <link href="https://yanyubing.xyz/2018/07/24/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E5%9B%BE/"/>
    <id>https://yanyubing.xyz/2018/07/24/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%889%EF%BC%89%E5%9B%BE/</id>
    <published>2018-07-24T13:46:12.000Z</published>
    <updated>2019-12-06T01:22:18.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：图"><a href="#1：图" class="headerlink" title="1：图"></a>1：图</h1><p>1：图的常用概念</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1：顶点</span><br><span class="line">2：边</span><br><span class="line">3：路径</span><br><span class="line">4：无向图</span><br><span class="line">5：有向图</span><br><span class="line">6：带权图</span><br><span class="line"></span><br><span class="line">为什么要有图？</span><br><span class="line">数据结构：线性表和树</span><br><span class="line">线性表局限于一个直接前驱和一个直接后继的关系</span><br><span class="line">树也只有一个直接前驱也就是父节点</span><br><span class="line">当我们需要表示多对多关系时，这里我们就用到了图</span><br></pre></td></tr></table></figure><p>2：图的表示方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：邻接矩阵：二维数组</span><br><span class="line">2：邻接表：数组+链表</span><br></pre></td></tr></table></figure><p>3：图的遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1：深度优先</span><br><span class="line">DFS：深度优先搜索法是树的先根遍历的推广，它的基本思想是：从图G的某个顶点v0出发，访问v0，然后选择一个与v0相邻且没被访问过的顶点vi访问，再从vi出发选择一个与vi相邻且未被访问的顶点vj进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点w，从w出发按同样的方法向前遍历，直到图中所有顶点都被访问</span><br><span class="line"></span><br><span class="line">例如：A-(B,C,D)相邻，B-（A,C,F）相邻，C-（A,B,D,E）相邻，D-（A,C）相邻 E-(C)相邻...</span><br><span class="line">则访问顺序为：A --B--C--D--E--F(先访问A，然后A的相邻的B，然后与B相邻的C，然后与C相邻的D，因为与D相邻的都已经被访问，则回退访问与C相邻的E；因为与E相邻的都已经访问过了，则回退访问与C相邻的，而与C相邻的也已经全部访问过了，则回退访问与B相邻的F)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2：广度优先</span><br><span class="line">图的广度优先搜索是树的按层次遍历的推广，它的基本思想是：首先访问初始点vi，并将其标记为已访问过，接着访问vi的所有未被访问过的邻接点vi1,vi2,…, vi t，并均标记已访问过，然后再按照vi1,vi2,…, vi t的次序，访问每一个顶点的所有未被访问过的邻接点，并均标记为已访问过，依次类推，直到图中所有和初始点vi有路径相通的顶点都被访问过为止。</span><br><span class="line"></span><br><span class="line">例如：A-(B,C,D)相邻，B-（A,C,F）相邻，C-（A,B,D,E）相邻，D-（A,C）相邻 E-(C)相邻...</span><br><span class="line">则访问顺序为 A-B-C-D-F-E，先把本节点的相邻节点全部访问完成再访问扩展访问</span><br></pre></td></tr></table></figure><p>4：遍历代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">深度优先遍历核心代码：</span><br><span class="line">while (w != -1) &#123;//说明存在临接节点</span><br><span class="line">            if (!isVisited[w]) &#123;</span><br><span class="line">                dfs(isVisited, w);//这里保证了递归的访问临接节点</span><br><span class="line">            &#125;</span><br><span class="line">            //临接节点都已经访问完开始弹栈，回溯</span><br><span class="line">            //如果w已经被访问，查找下一个临接节点</span><br><span class="line">            while ((w = getNextNeighbor(i, w)) != -1 &amp;&amp; !isVisited[w]) &#123;</span><br><span class="line">                //这时的临接节点存在且没有被访问的情况下继续访问下个临接节点</span><br><span class="line">                dfs(isVisited, w);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">广度优先遍历核心代码：</span><br><span class="line"> //所有访问的节点入队列，如果当前节点的所有临接节点都已经访问完，则出队列，进行下一个的所有临接节点的访问</span><br><span class="line">        LinkedList queue = new LinkedList();</span><br><span class="line">        //首先访问该节点</span><br><span class="line">        System.out.print(getValueByIndex(i) + &quot;→&quot;);</span><br><span class="line">        queue.addLast(i);//访问的节点入队列</span><br><span class="line">        //将该节点设置为已经访问</span><br><span class="line">        isVisited[i] = true;</span><br><span class="line">        while (!queue.isEmpty()) &#123;//队列不为空</span><br><span class="line">            //取出队列的头结点，并且移除</span><br><span class="line">            i = (int) queue.removeFirst();</span><br><span class="line">            //然后访问所有该节点的临接节点</span><br><span class="line">            int w = getFirstNeighbor(i);//访问第一个临接节点</span><br><span class="line">            if (!isVisited[w]) &#123;</span><br><span class="line">                System.out.print(getValueByIndex(w) + &quot;→&quot;);</span><br><span class="line">                queue.addLast(w);</span><br><span class="line">                isVisited[w]=true;</span><br><span class="line">            &#125;</span><br><span class="line">            while (getNextNeighbor(i, w) != -1) &#123;//进入循环证明有下一个临接节点</span><br><span class="line">                int x = getNextNeighbor(i, w);</span><br><span class="line">                if (!isVisited[x]) &#123;</span><br><span class="line">                    System.out.print(getValueByIndex(x) + &quot;→&quot;);</span><br><span class="line">                    queue.addLast(x);//x入队列</span><br><span class="line">                    isVisited[x]=true;</span><br><span class="line">                &#125;</span><br><span class="line">                w = x;//后移</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">package com.it.graph;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">//用二维数组构建图</span><br><span class="line">public class Graph &#123;</span><br><span class="line">    private ArrayList&lt;String&gt; vertexList;   //存储顶点集合</span><br><span class="line">    private int[][] edges;                  //存储图的邻接矩阵，二维数组的大小是n*n</span><br><span class="line">    private int numOfEdges;                 //表示边的数目</span><br><span class="line">    private boolean[] isVisited;    //定义一个数组,表示当前节点是否被访问</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试图是否创建成功</span><br><span class="line">        int n = 8;//节点的个数</span><br><span class="line">        String vertexs[] = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;&#125;;</span><br><span class="line">        //创建图对象</span><br><span class="line">        Graph graph = new Graph(8);</span><br><span class="line">        //循环添加顶点</span><br><span class="line">        for (String vertex : vertexs) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        //添加边</span><br><span class="line">        //A-B  A-C A-G  B-C  B-D  B-E  C-F C-H D-H</span><br><span class="line">        graph.insertEdge(0, 1, 1);</span><br><span class="line">        graph.insertEdge(0, 2, 1);</span><br><span class="line">        graph.insertEdge(0, 6, 1);</span><br><span class="line">        graph.insertEdge(1, 2, 1);</span><br><span class="line">        graph.insertEdge(1, 3, 1);</span><br><span class="line">        graph.insertEdge(1, 4, 1);</span><br><span class="line">        graph.insertEdge(2, 5, 1);</span><br><span class="line">        graph.insertEdge(2, 7, 1);</span><br><span class="line">        graph.insertEdge(3, 7, 1);</span><br><span class="line">        //显示邻接矩阵</span><br><span class="line">        graph.showGraph();</span><br><span class="line">        //测试深度遍历</span><br><span class="line">        boolean[] isVisited1 = new boolean[n];</span><br><span class="line">        boolean[] isVisited2 = new boolean[n];</span><br><span class="line">        System.out.println(&quot;深度遍历&quot;);</span><br><span class="line">        graph.dfs(isVisited1, 0);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;广度遍历&quot;);</span><br><span class="line">        graph.bfs(isVisited2, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param n //n表示顶点的个数</span><br><span class="line">     */</span><br><span class="line">    public Graph(int n) &#123;</span><br><span class="line">        //初始化矩阵和vertexList</span><br><span class="line">        edges = new int[n][n];</span><br><span class="line">        vertexList = new ArrayList&lt;String&gt;(n);</span><br><span class="line">        numOfEdges = 0;//边的数目初始化为0；</span><br><span class="line">        isVisited = new boolean[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param index 传入当前节点的下标</span><br><span class="line">     * @return 返回临接节点的下标，如果没有则返回-1</span><br><span class="line">     */</span><br><span class="line">    //根据当前节点的索引得到一个临接节点的下标</span><br><span class="line">    public int getFirstNeighbor(int index) &#123;</span><br><span class="line">        for (int i = 0; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            if (edges[index][i] &gt; 0) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param v1 当前节点下标</span><br><span class="line">     * @param v2 v1前一个临接节点的下标</span><br><span class="line">     * @return 返回的是v1的除去v2的下一个临接节点</span><br><span class="line">     */</span><br><span class="line">    //根据前一个临接节点的下标来获取下一个临接节点</span><br><span class="line">    public int getNextNeighbor(int v1, int v2) &#123;</span><br><span class="line">        for (int i = v2 + 1; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            if (edges[v1][i] &gt; 0) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //深度优先遍历算法,i第一次就是0</span><br><span class="line">    public void dfs(boolean[] isVisited, int i) &#123;</span><br><span class="line">        //首先访问该节点</span><br><span class="line">        System.out.print(getValueByIndex(i) + &quot;→&quot;);</span><br><span class="line">        //将该节点设置为已经访问</span><br><span class="line">        isVisited[i] = true;</span><br><span class="line">        //获取i的第一个临接节点w</span><br><span class="line">        int w = getFirstNeighbor(i);</span><br><span class="line">        while (w != -1) &#123;//说明存在临接节点</span><br><span class="line">            if (!isVisited[w]) &#123;</span><br><span class="line">                dfs(isVisited, w);//这里保证了递归的访问临接节点</span><br><span class="line">            &#125;//临接节点都已经访问完开始弹栈，回溯</span><br><span class="line">            //如果w已经被访问，查找下一个临接节点</span><br><span class="line">            while ((w = getNextNeighbor(i, w)) != -1 &amp;&amp; !isVisited[w]) &#123;</span><br><span class="line">                //这时的临接节点存在且没有被访问的情况下继续访问下个临接节点</span><br><span class="line">                dfs(isVisited, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //广度优先遍历</span><br><span class="line">    public void bfs(boolean[] isVisited, int i) &#123;</span><br><span class="line">        //所有访问的节点入队列，如果当前节点的所有临接节点都已经访问完，则出队列，进行下一个的所有临接节点的访问</span><br><span class="line">        LinkedList queue = new LinkedList();</span><br><span class="line">        //首先访问该节点</span><br><span class="line">        System.out.print(getValueByIndex(i) + &quot;→&quot;);</span><br><span class="line">        queue.addLast(i);//访问的节点入队列</span><br><span class="line">        //将该节点设置为已经访问</span><br><span class="line">        isVisited[i] = true;</span><br><span class="line">        while (!queue.isEmpty()) &#123;//队列不为空</span><br><span class="line">            //取出队列的头结点，并且移除</span><br><span class="line">            i = (int) queue.removeFirst();</span><br><span class="line">            //然后访问所有该节点的临接节点</span><br><span class="line">            int w = getFirstNeighbor(i);//访问第一个临接节点</span><br><span class="line">            if (!isVisited[w]) &#123;</span><br><span class="line">                System.out.print(getValueByIndex(w) + &quot;→&quot;);</span><br><span class="line">                queue.addLast(w);</span><br><span class="line">                isVisited[w]=true;</span><br><span class="line">            &#125;</span><br><span class="line">            while (getNextNeighbor(i, w) != -1) &#123;//进入循环证明有下一个临接节点</span><br><span class="line">                int x = getNextNeighbor(i, w);</span><br><span class="line">                if (!isVisited[x]) &#123;</span><br><span class="line">                    System.out.print(getValueByIndex(x) + &quot;→&quot;);</span><br><span class="line">                    queue.addLast(x);//x入队列</span><br><span class="line">                    isVisited[x]=true;</span><br><span class="line">                &#125;</span><br><span class="line">                w = x;//后移</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //图中常用的方法</span><br><span class="line">    //1:返回节点的个数</span><br><span class="line">    public int getNumOfVertex() &#123;</span><br><span class="line">        return vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2:得到边的数目</span><br><span class="line">    public int getNumOfEdges() &#123;</span><br><span class="line">        return numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3:返回节点i（下标）对应的数据 0-“A”  1-“B”</span><br><span class="line">    public String getValueByIndex(int i) &#123;</span><br><span class="line">        return vertexList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4:返回v1,v2对应的权值</span><br><span class="line">    public int getWeight(int v1, int v2) &#123;</span><br><span class="line">        return edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5:显示图对应的矩阵（二维数组）</span><br><span class="line">    public void showGraph() &#123;</span><br><span class="line">        for (int[] edge : edges) &#123;</span><br><span class="line">            for (int i : edge) &#123;</span><br><span class="line">                System.out.print(i + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入顶点,vertex：顶点的名称</span><br><span class="line">    public void insertVertex(String vertex) &#123;</span><br><span class="line">        //将顶点加入集合</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param v1     表示点的下标，即第几个顶点。“A”-“B”  “A”-0 “B”-1</span><br><span class="line">     * @param v2     表示点的下标，即第几个顶点。“A”-“B”  “A”-0 “B”-1</span><br><span class="line">     *               举例：要描述A和B的关系，则v1表示A的下标，v2表示B的下标</span><br><span class="line">     * @param weight 表示权值，即A,B两点之间的关系</span><br><span class="line">     */</span><br><span class="line">    //添加边</span><br><span class="line">    public void insertEdge(int v1, int v2, int weight) &#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：图&quot;&gt;&lt;a href=&quot;#1：图&quot; class=&quot;headerlink&quot; title=&quot;1：图&quot;&gt;&lt;/a&gt;1：图&lt;/h1&gt;&lt;p&gt;1：图的常用概念&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（8）树</title>
    <link href="https://yanyubing.xyz/2018/07/10/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%91/"/>
    <id>https://yanyubing.xyz/2018/07/10/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%888%EF%BC%89%E6%A0%91/</id>
    <published>2018-07-10T13:46:12.000Z</published>
    <updated>2019-12-06T01:22:03.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：树"><a href="#1：树" class="headerlink" title="1：树"></a>1：树</h1><h3 id="1：二叉排序树"><a href="#1：二叉排序树" class="headerlink" title="1：二叉排序树"></a>1：二叉排序树</h3><p>1：二叉排序树概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一棵空树，或者是具有下列性质的二叉树：</span><br><span class="line">（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</span><br><span class="line">（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</span><br><span class="line">（3）左、右子树也分别为二叉排序树；</span><br><span class="line">（4）没有键值相等的结点。</span><br></pre></td></tr></table></figure><p>2：功能实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：二叉排序树的创建，遍历</span><br><span class="line">2；二叉排序树的删除分三种情况：①删除叶子节点 ②删除只有一颗子树的节点 ③删除有两颗子树的节点</span><br></pre></td></tr></table></figure><p>3：二叉排序树删除节点的三种情况具体思路分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：删除叶子节点思路</span><br><span class="line">①定位要删除的节点</span><br><span class="line">②找到目标节点的父节点parent</span><br><span class="line">③确定目标节点和父节点的关系</span><br><span class="line">④删除，即为置空</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2：删除只有一颗子树的节点</span><br><span class="line">①定位要删除的节点</span><br><span class="line">②找到目标节点的父节点parent</span><br><span class="line">③确定目标节点的子节点是左子节点还是右子节点</span><br><span class="line">④确定目标节点是parent的左子节点还是右子节点</span><br><span class="line">③④两步实际上都是为了把目标节点替换成它的子节点</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3：删除有两颗子树的节点</span><br><span class="line">①定位要删除的节点</span><br><span class="line">②找到目标节点的父节点parent</span><br><span class="line">③储存目标节点的右子树的最小节点temp</span><br><span class="line">④删除该节点，把目标节点的值替换为temp</span><br><span class="line">注意：此处③这里也可以找左子树中的所有节点的最大值为temp</span><br><span class="line"></span><br><span class="line">注意：其实最重要的就是把每种情况都列举完全，不漏不累赘！</span><br></pre></td></tr></table></figure><p>4：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">package com.it.binarysorttree;</span><br><span class="line"></span><br><span class="line">//二叉排序树</span><br><span class="line">public class BinarySortTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;7, 3, 10, 12, 5, 1, 9, 2&#125;;</span><br><span class="line">        //创建二叉排序树</span><br><span class="line">        BinarySortTree binarySortTree = new BinarySortTree();</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            binarySortTree.add(new Node(arr[i]));//迭代添加节点</span><br><span class="line">        &#125;</span><br><span class="line">        //中序遍历</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">        //测试情况一：删除叶子节点</span><br><span class="line">        binarySortTree.delNode(2);</span><br><span class="line">        System.out.println(&quot;删除叶子节点之后&quot;);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">        //测试所有情况：</span><br><span class="line">        System.out.println(&quot;删除root节点之后&quot;);</span><br><span class="line">        binarySortTree.delNode(7);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">        System.out.println(&quot;----------------&quot;);</span><br><span class="line">        binarySortTree.delNode(10);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建</span><br><span class="line">class BinarySortTree &#123;</span><br><span class="line">    private Node root;</span><br><span class="line"></span><br><span class="line">    //查找要删除的节点</span><br><span class="line">    public Node search(int value) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else return root.search(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找父节点</span><br><span class="line">    public Node searchParent(int value) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param node 传入的节点（当做二叉排序树的根节点）</span><br><span class="line">     * @return 返回的以node为根节点的二叉排序树的最小节点的值，同时完成删除最小节点</span><br><span class="line">     */</span><br><span class="line">    public int delRightTreeMin(Node node) &#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        //循环查找左边节点，就会找到最小值</span><br><span class="line">        while (target.left != null) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;//循环结束target就指向了最小节点</span><br><span class="line">        delNode(target.value);//删除最小节点</span><br><span class="line">        return target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除节点</span><br><span class="line">    public void delNode(int value) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //1：需要先去找到要删除的节点，targetNode</span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            //如果没有找到要删除的值</span><br><span class="line">            if (targetNode == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果我们发现当前这颗二叉排序树只有一个节点，到这里说明root就是要删除的节点</span><br><span class="line">            if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">                root = null;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //去找target的父节点</span><br><span class="line">            Node parentNode = searchParent(value);</span><br><span class="line">            //特殊情况，如果删除的节点是root节点，但是root节点有子节点的情况</span><br><span class="line">            //分两种情况，一种是只有一颗子树的情况</span><br><span class="line">            if (parentNode == null) &#123;</span><br><span class="line">                System.out.println(&quot;你要删除根节点且根节点底下有子树&quot;);</span><br><span class="line">                //只有一个左子树</span><br><span class="line">                if (targetNode.left != null &amp;&amp; targetNode.right == null) &#123;</span><br><span class="line">                    targetNode = targetNode.left;</span><br><span class="line">                &#125; else if (targetNode.left == null &amp;&amp; targetNode.right != null) &#123;</span><br><span class="line">                    targetNode = targetNode.right;</span><br><span class="line">                &#125; else &#123;//说明根节点有两个子树</span><br><span class="line">                    int minVal = delRightTreeMin(targetNode.right);//minVal就就是右子树的最小值</span><br><span class="line">                    targetNode.value = minVal;//该节点的值重置为minVal</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //情况一：如果要删除的节点是叶子节点</span><br><span class="line">                if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123;</span><br><span class="line">                    //判断targetNode是父节点的左子节点还是右子节点</span><br><span class="line">                    if (parentNode.left != null &amp;&amp; parentNode.left.value == value) &#123;</span><br><span class="line">                        parentNode.left = null;</span><br><span class="line">                    &#125; else if (parentNode.right != null &amp;&amp; parentNode.right.value == value) &#123;//说明是右子节点</span><br><span class="line">                        parentNode.right = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (targetNode.left != null &amp;&amp; targetNode.right != null) &#123;</span><br><span class="line">                    //情况三：删除有两个叶子节点的节点</span><br><span class="line">                    //③储存目标节点的右子树的最小节点temp</span><br><span class="line">                    int minVal = delRightTreeMin(targetNode.right);//minVal就就是最小值</span><br><span class="line">                    targetNode.value = minVal;//该节点的值重置为minVal</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //情况二：删除只有一颗子树的节点（此时放在最后写，是不用去判断条件）</span><br><span class="line">                    //如果要删除的节点有左子节点</span><br><span class="line">                    if (targetNode.left != null) &#123;//说明此时的目标节点存在的是左子树</span><br><span class="line">                        if (parentNode.left == targetNode) &#123;//如果目标节点是父节点的左子节点</span><br><span class="line">                            parentNode.left = targetNode.left;//重置</span><br><span class="line">                        &#125; else &#123;//如果目标节点是父节点的右子节点</span><br><span class="line">                            parentNode.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;//如果要删除的节点存在的是右子节点</span><br><span class="line">                        if (parentNode.left == targetNode) &#123;//如果目标节点是父节点的左子节点</span><br><span class="line">                            parentNode.left = targetNode.right;</span><br><span class="line">                        &#125; else &#123;//如果目标节点是父节点的右子节点</span><br><span class="line">                            parentNode.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点的方法</span><br><span class="line">    public void add(Node node) &#123;</span><br><span class="line">        if (root == null) &#123;//说明现在是空树</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉排序树是空的，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//节点</span><br><span class="line">class Node &#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    public Node(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param value 想要查找节点的值</span><br><span class="line">     * @return 如果找到，则返回节点，如果没找到，则返回null</span><br><span class="line">     */</span><br><span class="line">    public Node search(int value) &#123;</span><br><span class="line">        if (value == this.value) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else if (value &lt; this.value) &#123;//如果查找的值小于当前节点，则需要在左子树递归查找，</span><br><span class="line">            if (this.left == null) &#123;//说明没找到</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.left.search(value);</span><br><span class="line">        &#125; else &#123;//如果查找的值大于当前节点，则向右子树查找</span><br><span class="line">            if (this.right == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param value 要查找节点的值</span><br><span class="line">     * @return 返回值为该节点的父节点，没有就null</span><br><span class="line">     */</span><br><span class="line">    //查找要删除节点的父节点</span><br><span class="line">    public Node searchParent(int value) &#123;</span><br><span class="line">        //说明this就为要删除节点的父节点</span><br><span class="line">        if ((this.left != null &amp;&amp; this.left.value == value) ||</span><br><span class="line">                this.right != null &amp;&amp; this.right.value == value) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果要查找的值小于当前节点的值，并且当前节点的子节点不为空</span><br><span class="line">            if (value &lt; this.value &amp;&amp; this.left != null) &#123;</span><br><span class="line">                return this.left.searchParent(value);//向左子树递归</span><br><span class="line">            &#125; else if (value &gt;= this.value &amp;&amp; this.right != null) &#123;//实际使用需要避免有相同值</span><br><span class="line">                return this.right.searchParent(value);//向右子树递归查找</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点的方法</span><br><span class="line">    //递归添加节点，注意需要满足二叉排序树的要求</span><br><span class="line">    public void add(Node node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断当前节点的值和当前子树根节点的关系</span><br><span class="line">        if (node.value &lt; this.value) &#123;</span><br><span class="line">            //当前节点的左子节点为空，直接挂上</span><br><span class="line">            if (this.left == null) &#123;</span><br><span class="line">                this.left = node;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果当前节点的左子节点不为空，递归</span><br><span class="line">            else &#123;</span><br><span class="line">                this.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;//node.value &gt;= this.value</span><br><span class="line">            if (this.right == null) &#123;</span><br><span class="line">                this.right = node;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node [value=&quot; + value + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2：平衡二叉树"><a href="#2：平衡二叉树" class="headerlink" title="2：平衡二叉树"></a>2：平衡二叉树</h3><p>1：平衡二叉树（AVL树）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">分析：给你一个数列&#123;1,2,3,4,5,6&#125;，要求创建一个二叉排序树</span><br><span class="line">问题：这个时候的二叉排序树相当于是单链表（左链表为空），插入和删除没问题，但是查询慢</span><br><span class="line">1：平衡二叉树又被叫做平衡二叉搜索树，又被称为AVL树</span><br><span class="line">2：首先得是二叉排序树</span><br><span class="line">3：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法（算法）有红黑树、AVL、替罪羊树、Treap、伸展树等。 </span><br><span class="line">4：最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci（斐波那契）数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。</span><br></pre></td></tr></table></figure><p>2：左旋转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二叉左旋</span><br><span class="line">一棵二叉平衡树的子树，根是Root，左子树是x，右子树的根为RootR，右子树的两个孩子树分别为RLeftChild和RRightChild。则左旋后，该子树的根为RootR，右子树为RRightChild，左子树的根为Root，Root的两个孩子树分别为x（左）和RLeftChild（右）。</span><br></pre></td></tr></table></figure><p>3：右旋转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一棵二叉平衡树的子树，根是Root，右子树是x，左子树的根为RootL，左子树的两个孩子树分别为LLeftChild和LRightChild。则右旋后，该子树的根为RootL，左子树为LLeftChild，右子树的根为Root，Root的两个孩子树分别为LRightChild（左）和x（右）。</span><br></pre></td></tr></table></figure><p>4：双旋转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">问题：int []arr=&#123;10,11,7,6,8,9&#125;;使用右旋转无法得到AVL树</span><br><span class="line">双旋转处理步骤：</span><br><span class="line">1：当满足右旋转时</span><br><span class="line">2：触发条件：如果当前节点的左子树的右子树的高度大于当前点的左子树的左子树的高度</span><br><span class="line">3：先对当前节点的左节点进行左旋转</span><br><span class="line">4：再对当前节点进行右旋转即可</span><br></pre></td></tr></table></figure><p>5：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line">package com.it.avl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AVLTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        int[] arr = &#123;4, 3, 6, 5, 7, 8&#125;;</span><br><span class="line">//        int [] arr=&#123;10,12,8,9,7,6&#125;;</span><br><span class="line">        int[] arr = &#123;10, 11, 7, 6, 8, 9&#125;;</span><br><span class="line"></span><br><span class="line">        //创建一个AVLTree对象</span><br><span class="line">        AVLTree avlTree = new AVLTree();</span><br><span class="line">        //添加节点</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            avlTree.add(new Node(arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历</span><br><span class="line">        System.out.println(&quot;中序遍历&quot;);</span><br><span class="line">        avlTree.infixOrder();</span><br><span class="line">        //没有做平衡前</span><br><span class="line">        System.out.println(&quot;树的高度=&quot; + avlTree.getRoot().height());</span><br><span class="line">        System.out.println(&quot;左子树的高度=&quot; + avlTree.getRoot().leftHeight());</span><br><span class="line">        System.out.println(&quot;右子树的高度=&quot; + avlTree.getRoot().rightHeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建AVL Tree,是平衡二叉树的一种</span><br><span class="line">class AVLTree &#123;</span><br><span class="line">    private Node root;</span><br><span class="line"></span><br><span class="line">    public Node getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找要删除的节点</span><br><span class="line">    public Node search(int value) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else return root.search(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查找父节点</span><br><span class="line">    public Node searchParent(int value) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param node 传入的节点（当做二叉排序树的根节点）</span><br><span class="line">     * @return 返回的以node为根节点的二叉排序树的最小节点的值，同时完成删除最小节点</span><br><span class="line">     */</span><br><span class="line">    public int delRightTreeMin(Node node) &#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        //循环查找左边节点，就会找到最小值</span><br><span class="line">        while (target.left != null) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;//循环结束target就指向了最小节点</span><br><span class="line">        delNode(target.value);//删除最小节点</span><br><span class="line">        return target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除节点</span><br><span class="line">    public void delNode(int value) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //1：需要先去找到要删除的节点，targetNode</span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            //如果没有找到要删除的值</span><br><span class="line">            if (targetNode == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果我们发现当前这颗二叉排序树只有一个节点，到这里说明root就是要删除的节点</span><br><span class="line">            if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">                root = null;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //去找target的父节点</span><br><span class="line">            Node parentNode = searchParent(value);</span><br><span class="line">            //特殊情况，如果删除的节点是root节点，但是root节点有子节点的情况</span><br><span class="line">            //分两种情况，一种是只有一颗子树的情况</span><br><span class="line">            if (parentNode == null) &#123;</span><br><span class="line">                System.out.println(&quot;你要删除根节点且根节点底下有子树&quot;);</span><br><span class="line">                //只有一个左子树</span><br><span class="line">                if (targetNode.left != null &amp;&amp; targetNode.right == null) &#123;</span><br><span class="line">                    targetNode = targetNode.left;</span><br><span class="line">                &#125; else if (targetNode.left == null &amp;&amp; targetNode.right != null) &#123;</span><br><span class="line">                    targetNode = targetNode.right;</span><br><span class="line">                &#125; else &#123;//说明根节点有两个子树</span><br><span class="line">                    int minVal = delRightTreeMin(targetNode.right);//minVal就就是右子树的最小值</span><br><span class="line">                    targetNode.value = minVal;//该节点的值重置为minVal</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //情况一：如果要删除的节点是叶子节点</span><br><span class="line">                if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123;</span><br><span class="line">                    //判断targetNode是父节点的左子节点还是右子节点</span><br><span class="line">                    if (parentNode.left != null &amp;&amp; parentNode.left.value == value) &#123;</span><br><span class="line">                        parentNode.left = null;</span><br><span class="line">                    &#125; else if (parentNode.right != null &amp;&amp; parentNode.right.value == value) &#123;//说明是右子节点</span><br><span class="line">                        parentNode.right = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (targetNode.left != null &amp;&amp; targetNode.right != null) &#123;</span><br><span class="line">                    //情况三：删除有两个叶子节点的节点</span><br><span class="line">                    //③储存目标节点的右子树的最小节点temp</span><br><span class="line">                    int minVal = delRightTreeMin(targetNode.right);//minVal就就是最小值</span><br><span class="line">                    targetNode.value = minVal;//该节点的值重置为minVal</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //情况二：删除只有一颗子树的节点（此时放在最后写，是不用去判断条件）</span><br><span class="line">                    //如果要删除的节点有左子节点</span><br><span class="line">                    if (targetNode.left != null) &#123;//说明此时的目标节点存在的是左子树</span><br><span class="line">                        if (parentNode.left == targetNode) &#123;//如果目标节点是父节点的左子节点</span><br><span class="line">                            parentNode.left = targetNode.left;//重置</span><br><span class="line">                        &#125; else &#123;//如果目标节点是父节点的右子节点</span><br><span class="line">                            parentNode.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;//如果要删除的节点存在的是右子节点</span><br><span class="line">                        if (parentNode.left == targetNode) &#123;//如果目标节点是父节点的左子节点</span><br><span class="line">                            parentNode.left = targetNode.right;</span><br><span class="line">                        &#125; else &#123;//如果目标节点是父节点的右子节点</span><br><span class="line">                            parentNode.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点的方法</span><br><span class="line">    public void add(Node node) &#123;</span><br><span class="line">        if (root == null) &#123;//说明现在是空树</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉排序树是空的，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//节点</span><br><span class="line">class Node &#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    public Node(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回左子树的高度</span><br><span class="line">    public int leftHeight() &#123;</span><br><span class="line">        if (left == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return left.height();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回右子树的高度</span><br><span class="line">    public int rightHeight() &#123;</span><br><span class="line">        if (right == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回当前节点的高度，以该节点为根节点的树的高度</span><br><span class="line">    public int height() &#123;</span><br><span class="line">        return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //左旋转</span><br><span class="line">    private void leftRotate() &#123;//在添加节点的时候调用该方法</span><br><span class="line"></span><br><span class="line">        //以当前根节点的值创建新的节点</span><br><span class="line">        Node newNode = new Node(value);</span><br><span class="line">        //把新的节点的左子树设置为当前节点的左子树</span><br><span class="line">        newNode.left = left;</span><br><span class="line">        //把新的节点右子树设置成当前节点的右子树的左子树</span><br><span class="line">        newNode.right = right.left;</span><br><span class="line">        //把当前节点的值替换成右子节点的值</span><br><span class="line">        value = right.value;</span><br><span class="line">        //把当前节点的右子树设置成当前节点的右子节点的右子树</span><br><span class="line">        right = right.right;</span><br><span class="line">        //把当前节点的左子节点设置成新的节点</span><br><span class="line">        left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //右旋转</span><br><span class="line">    private void rightRotate() &#123;</span><br><span class="line">        //以当前根节点的值创建新的节点</span><br><span class="line">        Node newNode = new Node(value);</span><br><span class="line">        newNode.right = right;</span><br><span class="line">        newNode.left = left.right;</span><br><span class="line">        left = left.left;</span><br><span class="line">        value = left.value;</span><br><span class="line">        right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param value 想要查找节点的值</span><br><span class="line">     * @return 如果找到，则返回节点，如果没找到，则返回null</span><br><span class="line">     */</span><br><span class="line">    public Node search(int value) &#123;</span><br><span class="line">        if (value == this.value) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else if (value &lt; this.value) &#123;//如果查找的值小于当前节点，则需要在左子树递归查找，</span><br><span class="line">            if (this.left == null) &#123;//说明没找到</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.left.search(value);</span><br><span class="line">        &#125; else &#123;//如果查找的值大于当前节点，则向右子树查找</span><br><span class="line">            if (this.right == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param value 要查找节点的值</span><br><span class="line">     * @return 返回值为该节点的父节点，没有就null</span><br><span class="line">     */</span><br><span class="line">    //查找要删除节点的父节点</span><br><span class="line">    public Node searchParent(int value) &#123;</span><br><span class="line">        //说明this就为要删除节点的父节点</span><br><span class="line">        if ((this.left != null &amp;&amp; this.left.value == value) ||</span><br><span class="line">                this.right != null &amp;&amp; this.right.value == value) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果要查找的值小于当前节点的值，并且当前节点的子节点不为空</span><br><span class="line">            if (value &lt; this.value &amp;&amp; this.left != null) &#123;</span><br><span class="line">                return this.left.searchParent(value);//向左子树递归</span><br><span class="line">            &#125; else if (value &gt;= this.value &amp;&amp; this.right != null) &#123;//实际使用需要避免有相同值</span><br><span class="line">                return this.right.searchParent(value);//向右子树递归查找</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点的方法</span><br><span class="line">    //递归添加节点，注意需要满足二叉排序树的要求</span><br><span class="line">    public void add(Node node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断当前节点的值和当前子树根节点的关系</span><br><span class="line">        if (node.value &lt; this.value) &#123;</span><br><span class="line">            //当前节点的左子节点为空，直接挂上</span><br><span class="line">            if (this.left == null) &#123;</span><br><span class="line">                this.left = node;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果当前节点的左子节点不为空，递归</span><br><span class="line">            else &#123;</span><br><span class="line">                this.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;//node.value &gt;= this.value</span><br><span class="line">            if (this.right == null) &#123;</span><br><span class="line">                this.right = node;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //当添加完一个节点后，如果（右子树的高度-左子树的高度&gt;1），左旋转</span><br><span class="line">        if (rightHeight() - leftHeight() &gt; 1) &#123;</span><br><span class="line">//            如果当前节点的右子树的左子树的高度大于当前点的右子树的右子树的高度</span><br><span class="line">//            这里进行双旋转</span><br><span class="line">            if (right != null &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;</span><br><span class="line">                //先对当前节点的右子树进行右旋转</span><br><span class="line">                right.rightRotate();</span><br><span class="line">                //再对当前节点进行左旋转</span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //当添加完一个节点后，如果（左子树的高度-右子树的高度&gt;1），右旋转</span><br><span class="line">        if (leftHeight() - rightHeight() &gt; 1) &#123;</span><br><span class="line">//            如果当前节点的左子树的右子树的高度大于当前点的左子树的左子树的高度（根节点表示当前节点）</span><br><span class="line">//            这里进行双旋转</span><br><span class="line">            if (left != null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;</span><br><span class="line">                //先对当前节点的左子树进行左旋转</span><br><span class="line">                left.leftRotate();</span><br><span class="line">                //再对当前节点进行右旋转</span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //直接进行右旋转即可</span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node [value=&quot; + value + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3：N叉树与B树"><a href="#3：N叉树与B树" class="headerlink" title="3：N叉树与B树"></a>3：N叉树与B树</h3><p>1：N叉树介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">树家族是为了实现方便快捷的查找而存在的。树的高度是命中查找的一个不可抗拒的时间下限。在一定的数据条件下，树的高度和宽度是互相制约的。（就像一定面积下，矩形的长和宽是互相制约的）而树家族中最简单的二叉树，尽管易于实现，却不能有实际的价值。其最最令人发指的是二叉树的高度太高。n叉树的提出和实现解决了二叉树的不足，典型的n叉树有：2-3-4树/红黑树和B树。</span><br><span class="line"></span><br><span class="line">需要满足排序树的需求！</span><br></pre></td></tr></table></figure><p>2：B树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">树的度M：对于二叉树而言，每个节点的最多有2个子节点，该节点的度最多为2，所有二叉树的度为2。树的度是指树中节点最多的节点的度。</span><br><span class="line"></span><br><span class="line">举例：将树的度设置为1024，在600亿个元素中最多只需要进行4次I/O就可以读取到想要的元素，1024*1024*1024*1024   即该树只需要4层就可以储存600亿个元素</span><br></pre></td></tr></table></figure><p>3：B树结构之一：2-3树介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：2-3树的所有叶子节点都在同一层（只要是B树都满足这个条件）</span><br><span class="line">2：有两个子节点的节点叫做二节点，二节点要么有2个子节点，要么没有子节点</span><br><span class="line">3：有三个子节点的节点叫做三节点，三节点要么有3个子节点，要么没有子节点</span><br><span class="line">4:2-3树是由二节点和三节点构建的数</span><br><span class="line">5：2-3树与满二叉树相似。高为h的2-3树包含的节点数大于等于高度为h的满二叉树的节点数，即至少有2^h-1个节点。</span><br></pre></td></tr></table></figure><p>4:2-3树的构建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">说明：&#123;&#125;表示树，（）表示节点在同一层形成的3节点的父节点类型 →表示指向右子节点 ←表示指向左子节点</span><br><span class="line">1：首先明白2-3树的父节点形式，父节点可以是1个Node,对应2节点；也可以是2个Node，对应的3节点。</span><br><span class="line">2：构建步骤</span><br><span class="line">1：第一个Node1成为2节点的父节点类型  1形式 &#123;Node1&#125;  </span><br><span class="line">2：第二个Node2与Node1比较，Node2&gt;Node1就把Node放在Node1的右边，Node1与Node2同时在一层，形成了3节点的父节点类型  &#123;(Node1 Node2)&#125; 2形式</span><br><span class="line">3：第三个Node3加入时形成一个2节点的排序树，这里需要变形   1+（1+1）形式  &#123;Node2←Node1→Node3&#125;</span><br><span class="line">4：第四个Node4加入时，如果Node4大于Node1且小于Node3      &#123;Node2←Node1→(Node4 Node3)&#125;</span><br><span class="line">5：第五个Node5加入时，形成一个2节点的子节点全为三节点的父节点类型，这里需要变形，如Node5大于Node1且小于Node4时  1+（2+2）形式 &#123;（Node2 Node1）←Node5→(Node4 Node3)&#125;</span><br><span class="line">6：第6个Node6加入时，也需要变形成2+（1+1+2）形式</span><br><span class="line">7：第7个Node6加入时，   形成2+（2+2+1）形式</span><br><span class="line">....</span><br><span class="line">总结：增加1个节点就需要变形的情况为叶子节点的个数为2，但是需要在该节点上继续添加一个值</span><br></pre></td></tr></table></figure><p>5：B+树介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址（链表储存，且关键字有序），叶子结点以上各层作为索引使用（上层不作为实际存储数据的节点）。一棵m阶的B+树定义如下:</span><br><span class="line">(1)每个结点至多有m个子女； </span><br><span class="line">(2)除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女；</span><br><span class="line">(3)有k个子女的结点必有k个关键字。 </span><br><span class="line">B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。</span><br></pre></td></tr></table></figure><p>6：B*树介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：树&quot;&gt;&lt;a href=&quot;#1：树&quot; class=&quot;headerlink&quot; title=&quot;1：树&quot;&gt;&lt;/a&gt;1：树&lt;/h1&gt;&lt;h3 id=&quot;1：二叉排序树&quot;&gt;&lt;a href=&quot;#1：二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;1：二叉排序树
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（7）树</title>
    <link href="https://yanyubing.xyz/2018/07/02/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%E6%A0%91/"/>
    <id>https://yanyubing.xyz/2018/07/02/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%887%EF%BC%89%E6%A0%91/</id>
    <published>2018-07-02T13:46:12.000Z</published>
    <updated>2019-12-06T01:21:47.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：树"><a href="#1：树" class="headerlink" title="1：树"></a>1：树</h1><h3 id="一：普通二叉树"><a href="#一：普通二叉树" class="headerlink" title="一：普通二叉树"></a>一：普通二叉树</h3><p>1：树结构的概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：数组结构的查找快，但是增删慢（数组需要扩容，同时数组索引需要整体移动）；集合的底层也是数组</span><br><span class="line">2：链表结构的增删快，但是查找慢（链表无索引，需要整体遍历）</span><br><span class="line">3：二叉排序树的结构效率都高，最多有左子节点和右子节点</span><br><span class="line">4：满二叉树，节点个数=2^n-1</span><br><span class="line">5：完全二叉树，如果一棵具有n个结点的深度为k的二叉树，它的每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应，这棵二叉树称为完全二叉树。</span><br></pre></td></tr></table></figure><p>2：二叉树遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">① NLR：前序遍历(Preorder Traversal 亦称（先序遍历））</span><br><span class="line">——访问根结点的操作发生在遍历其左右子树之前。</span><br><span class="line">根→左→右</span><br><span class="line">② LNR：中序遍历(Inorder Traversal)</span><br><span class="line">——访问根结点的操作发生在遍历其左右子树之中（间）。</span><br><span class="line">左→根→右</span><br><span class="line">③ LRN：后序遍历(Postorder Traversal)</span><br><span class="line">——访问根结点的操作发生在遍历其左右子树之后。</span><br><span class="line">左→右→根</span><br><span class="line">注意：遍历的实际方法是在节点类中去创建的</span><br></pre></td></tr></table></figure><p>3：二叉树的查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">此时二叉树为无序二叉树，所以比较只有相等和不等</span><br><span class="line">1：前序查找，先与根节点比较，再与左边节点比较，递归前序查找；最后与右边节点比较，再递归前序查找</span><br><span class="line">2：中序查找...</span><br><span class="line">3：后序查找...</span><br></pre></td></tr></table></figure><p>4：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">package com.it.tree;</span><br><span class="line"></span><br><span class="line">public class BinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BinaryTree binaryTree = new BinaryTree();</span><br><span class="line">        HeroNode root = new HeroNode(1, &quot;宋江&quot;);</span><br><span class="line">        HeroNode heroNode2 = new HeroNode(2, &quot;吴用&quot;);</span><br><span class="line">        HeroNode heroNode3 = new HeroNode(3, &quot;卢俊义&quot;);</span><br><span class="line">        HeroNode heroNode4 = new HeroNode(4, &quot;林冲&quot;);</span><br><span class="line">        HeroNode heroNode5 = new HeroNode(5, &quot;关胜&quot;);</span><br><span class="line">        //说明，二叉树应该是递归创建，此处先手动创建</span><br><span class="line">        root.setLeft(heroNode2);</span><br><span class="line">        root.setRight(heroNode3);</span><br><span class="line">        heroNode3.setRight(heroNode4);</span><br><span class="line">        //设置root节点</span><br><span class="line">        binaryTree.setRoot(root);</span><br><span class="line">        //测试：遍历</span><br><span class="line">        //1：前序遍历</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line">        System.out.println(&quot;--------------&quot;);</span><br><span class="line">        //2:中序遍历</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line">        System.out.println(&quot;--------------&quot;);</span><br><span class="line">        //3：后续遍历</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line">        System.out.println(&quot;--------------&quot;);</span><br><span class="line">        //测试：查找</span><br><span class="line">        System.out.println(binaryTree.preFind(2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建二叉树</span><br><span class="line">class BinaryTree &#123;</span><br><span class="line">    //遍历是由二叉树根节点调用的，但是实际执行的是每个节点的方法</span><br><span class="line">    private HeroNode root;//创建根节点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void setRoot(HeroNode root) &#123;</span><br><span class="line">        this.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序查找</span><br><span class="line">    public HeroNode preFind(int no) &#123;</span><br><span class="line">        HeroNode heroNode = null;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            heroNode = this.root.preFind(no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法查找！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序遍历</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            this.root.preOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            this.root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //后续遍历</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            this.root.postOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//hero节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    private int no;</span><br><span class="line">    private String name;</span><br><span class="line">    private HeroNode left;</span><br><span class="line">    private HeroNode right;</span><br><span class="line"></span><br><span class="line">    public HeroNode(int no, String name) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode getLeft() &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeft(HeroNode left) &#123;</span><br><span class="line">        this.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode getRight() &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRight(HeroNode right) &#123;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;no=&quot; + no +</span><br><span class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //节点的前序遍历方法</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this);//先输出父节点</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.preOrder();//递归前序遍历</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        //递归向左子树中序遍历</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        //输出父节点</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //后序遍历</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序查找</span><br><span class="line">    public HeroNode preFind(int no) &#123;</span><br><span class="line">        //先比较当前节点是不是</span><br><span class="line">        if (this.no == no) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode res = null;</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            res = this.left.preFind(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (res != null) &#123;</span><br><span class="line">            return res;//说明左子树找到</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            res = this.right.preFind(no);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二：顺序存储二叉树"><a href="#二：顺序存储二叉树" class="headerlink" title="二：顺序存储二叉树"></a>二：顺序存储二叉树</h3><p>1：顺序存储二叉树概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：从数据结构看，数组存储方式和树的存储方式可以相互转换</span><br><span class="line">2：顺序二叉树通常只考虑完全二叉树</span><br><span class="line">3：第n个元素的左子节点为2*n+1</span><br><span class="line">4：第n个元素的左子节点为2*n+2</span><br><span class="line">5：第n个元素的父节点为（n-1）/2</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">以下代码为：通过二叉树的前序遍历方式遍历数组</span><br><span class="line">package com.it.tree;</span><br><span class="line"></span><br><span class="line">public class ArrBinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //以二叉树的前序遍历方式遍历数组</span><br><span class="line">        int[] arr = &#123;1, 2, 3, 4, 5, 6, 7&#125;;</span><br><span class="line">        //创建一个ArrBinaryTree</span><br><span class="line">        ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);</span><br><span class="line">        arrBinaryTree.preOrder();//从根节点开始遍历</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写一个ArrayBinaryTree,实现顺序存储二叉树遍历</span><br><span class="line">class ArrBinaryTree &#123;</span><br><span class="line">    private int[] arr;//存储二叉树节点的数组</span><br><span class="line"></span><br><span class="line">    public ArrBinaryTree(int[] arr) &#123;</span><br><span class="line">        this.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        this.preOrder(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //编写一个方法，完成顺序存储二叉树前序遍历</span><br><span class="line">    public void preOrder(int index) &#123;//index表示数组的下标</span><br><span class="line">        //如果数组为空，或者arr.length=0;</span><br><span class="line">        if (arr == null || arr.length == 0) &#123;</span><br><span class="line">            System.out.println(&quot;数组为空，不能遍历&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(arr[index]);//输出当前元素</span><br><span class="line">            //向左递归遍历</span><br><span class="line">            if (index * 2 + 1 &lt; arr.length) &#123;//证明有左节点</span><br><span class="line">                preOrder(2 * index + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            //向右递归遍历</span><br><span class="line">            if (index * 2 + 2 &lt; arr.length) &#123;//证明有右节点</span><br><span class="line">                preOrder(index * 2 + 2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三：线索化二叉树"><a href="#三：线索化二叉树" class="headerlink" title="三：线索化二叉树"></a>三：线索化二叉树</h3><p>1：线索化二叉树概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。</span><br><span class="line">运算：一个节点2个指针，n个节点则有2n个指针，而n个节点需要n-1个指针连接，则空指针域的个数为2n-(n-1)=n+1个</span><br><span class="line">2：二叉树的遍历本质上是将一个复杂的非线性结构转换为线性结构，使每个结点都有了唯一前驱和后继（第一个结点无前驱，最后一个结点无后继）。对于二叉树的一个结点，查找其左右子女是方便的，其前驱后继只有在遍历中得到。为了容易找到前驱和后继，有两种方法。一是在结点结构中增加向前和向后的指针，这种方法增加了存储开销，不可取；二是利用二叉树的空链指针。</span><br><span class="line">3：在二叉树的结点上加上线索的二叉树称为线索二叉树，对二叉树以某种遍历方式（如先序、中序、后序或层次等）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。</span><br><span class="line">4：一个节点的前一个节点，称为前驱节点</span><br><span class="line">5：一个节点的后一个节点，称为后继节点</span><br><span class="line">6：线索化的实际意义就是把每个节点都产生关联，把空指针域给填满！</span><br></pre></td></tr></table></figure><p>2：中序线索化二叉树遍历代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：因为线索化二叉树的最后一排节点的前驱和后继节点都已经被填满，所以不能用传统判断是否为空的方式作为递归的结束点</span><br><span class="line">2：继而设置了leftType和rightType是否==1来判断是不是前驱或者后继节点（对应原二叉树的null）</span><br><span class="line">3：用中序线索化的二叉树，就用对应的中序遍历保持一致</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line">package com.it.tree;</span><br><span class="line"></span><br><span class="line">public class ThreadedBinaryTreeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试中序线索化二叉树功能</span><br><span class="line">        HeroNode2 root = new HeroNode2(1, &quot;tom&quot;);</span><br><span class="line">        HeroNode2 heroNode2 = new HeroNode2(3, &quot;jack&quot;);</span><br><span class="line">        HeroNode2 heroNode3 = new HeroNode2(6, &quot;smith&quot;);</span><br><span class="line">        HeroNode2 heroNode4 = new HeroNode2(8, &quot;mary&quot;);</span><br><span class="line">        HeroNode2 heroNode5 = new HeroNode2(10, &quot;king&quot;);</span><br><span class="line">        HeroNode2 heroNode6 = new HeroNode2(14, &quot;dim&quot;);</span><br><span class="line">        //二叉树后面递归创建，暂时手动创建</span><br><span class="line">        root.setLeft(heroNode2);</span><br><span class="line">        root.setRight(heroNode3);</span><br><span class="line">        heroNode2.setLeft(heroNode4);</span><br><span class="line">        heroNode2.setRight(heroNode5);</span><br><span class="line">        heroNode3.setLeft(heroNode6);</span><br><span class="line">        //测试线索化</span><br><span class="line">        BinaryTree2 binaryTree2 = new BinaryTree2();</span><br><span class="line">        binaryTree2.setRoot(root);</span><br><span class="line">        binaryTree2.threadedNodes();</span><br><span class="line">        //测试</span><br><span class="line">        HeroNode2 left = heroNode5.getLeft();</span><br><span class="line">        HeroNode2 right = heroNode5.getRight();</span><br><span class="line">        System.out.println(&quot;heroNode5的前驱节点为：&quot; + left);</span><br><span class="line">        System.out.println(&quot;heroNode5的后继节点为：&quot; + right);</span><br><span class="line">        //测试遍历</span><br><span class="line">        binaryTree2.threadedList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//当线索化二叉树后，不能使用原来的二叉树遍历方式，因为不能用null来结束递归，用中序线索化的二叉树，就用对应的中序遍历保持一致</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实现线索化功能的二叉树</span><br><span class="line">class BinaryTree2 &#123;</span><br><span class="line">    //遍历是由二叉树根节点调用的，但是实际执行的是每个节点的方法</span><br><span class="line">    private HeroNode2 root;//创建根节点</span><br><span class="line">    //为了实现线索化，需要创建一个指向当前节点前驱节点的指针</span><br><span class="line">    //在递归进行线索化时，pre总是保留一个前驱节点</span><br><span class="line">    private HeroNode2 pre = null;</span><br><span class="line"></span><br><span class="line">    public void setRoot(HeroNode2 root) &#123;</span><br><span class="line">        this.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void threadedNodes() &#123;</span><br><span class="line">        this.threadedNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历线索二叉树的方法</span><br><span class="line">    public void threadedList() &#123;</span><br><span class="line">        //定义变量，存储当前遍历的节点</span><br><span class="line">        HeroNode2 node = root;</span><br><span class="line">        while (node != null) &#123;</span><br><span class="line">            //循环找到leftType==1的节点，第一个找到的是8这个节点，该节点是按照线索化处理后的有效节点</span><br><span class="line">            //后面随着遍历而变化</span><br><span class="line">            while (node.getLeftType() == 0) &#123;//代表有左子树</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            //打印当前节点</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            //如果当前节点的右指针指向的后继节点，就一直输出</span><br><span class="line">            while (node.getRightType() == 1) &#123;</span><br><span class="line">                //获取当前节点的后继节点</span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            //替换这个遍历的节点</span><br><span class="line">            node = node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //编写对二叉树进行中序线索化的方法,heroNode2是需要进行线索化的节点</span><br><span class="line">    public void threadedNodes(HeroNode2 heroNode2) &#123;</span><br><span class="line">        //如果是null,不能线索化</span><br><span class="line">        if (heroNode2 == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //中序线索化</span><br><span class="line">        //1：先线索化左子树</span><br><span class="line">        threadedNodes(heroNode2.getLeft());</span><br><span class="line">        //2：处理当前节点,实际上线索化的操作都是由此方法完成</span><br><span class="line">        //处理当前节点的前驱节点</span><br><span class="line">        if (heroNode2.getLeft() == null) &#123;</span><br><span class="line">            //让当前节点的左指针指向前驱节点</span><br><span class="line">            heroNode2.setLeft(pre);</span><br><span class="line">            //修改当前节点的左指针的类型,指向前驱节点</span><br><span class="line">            heroNode2.setLeftType(1);</span><br><span class="line">        &#125;</span><br><span class="line">        //处理后置节点,注意此时判断条件的顺序，否则会出现空指针异常</span><br><span class="line">        if (pre != null &amp;&amp; pre.getRight() == null) &#123;</span><br><span class="line">            //让前驱节点的右指针指向当前节点</span><br><span class="line">            pre.setRight(heroNode2);</span><br><span class="line">            //修改前驱节点的右指针类型</span><br><span class="line">            pre.setRightType(1);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = heroNode2;</span><br><span class="line">        //3：再处理线索化右子树</span><br><span class="line">        threadedNodes(heroNode2.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序查找</span><br><span class="line">    public HeroNode2 preFind(int no) &#123;</span><br><span class="line">        HeroNode2 heroNode2 = null;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            heroNode2 = this.root.preFind(no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法查找！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return heroNode2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序遍历</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            this.root.preOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            this.root.infixOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //后续遍历</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        if (this.root != null) &#123;</span><br><span class="line">            this.root.postOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;二叉树为空，无法遍历&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//hero2节点</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line">    private int no;</span><br><span class="line">    private String name;</span><br><span class="line">    private HeroNode2 left;</span><br><span class="line">    private HeroNode2 right;</span><br><span class="line">    //如果leftType==0，表示指向的是左子树，如果是1则表示指向的前驱节点</span><br><span class="line">    //如果rightType==0，表示指向的是右子树，如果是1则表示指向的后继节点</span><br><span class="line">    private int leftType;</span><br><span class="line">    private int rightType;</span><br><span class="line"></span><br><span class="line">    public HeroNode2(int no, String name) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getLeftType() &#123;</span><br><span class="line">        return leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeftType(int leftType) &#123;</span><br><span class="line">        this.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getRightType() &#123;</span><br><span class="line">        return rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRightType(int rightType) &#123;</span><br><span class="line">        this.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode2 getLeft() &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLeft(HeroNode2 left) &#123;</span><br><span class="line">        this.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeroNode2 getRight() &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRight(HeroNode2 right) &#123;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode&#123;&quot; +</span><br><span class="line">                &quot;no=&quot; + no +</span><br><span class="line">                &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //节点的前序遍历方法</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this);//先输出父节点</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.preOrder();//递归前序遍历</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //中序遍历</span><br><span class="line">    public void infixOrder() &#123;</span><br><span class="line">        //递归向左子树中序遍历</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        //输出父节点</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //后序遍历</span><br><span class="line">    public void postOrder() &#123;</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序查找</span><br><span class="line">    public HeroNode2 preFind(int no) &#123;</span><br><span class="line">        //先比较当前节点是不是</span><br><span class="line">        if (this.no == no) &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        HeroNode2 res = null;</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            res = this.left.preFind(no);</span><br><span class="line">        &#125;</span><br><span class="line">        if (res != null) &#123;</span><br><span class="line">            return res;//说明左子树找到</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            res = this.right.preFind(no);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四：树结构的应用一：堆排序"><a href="#四：树结构的应用一：堆排序" class="headerlink" title="四：树结构的应用一：堆排序"></a>四：树结构的应用一：堆排序</h3><p>1：堆排序介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最好，最坏，平均复杂度均为O（nlogn），它也是不稳定的排序</span><br><span class="line">2：堆是具有以下性质的完全二叉树，每个节点的值都大于或等于其左右孩子节点的值，称为大定堆；每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆。对孩子之间值的比较没要求</span><br><span class="line">3：大顶堆特点arr[i]&gt;=arr[2*i+1]&amp;&amp;arr[i]&gt;=arr[2*i+2],i对应的是第几个节点</span><br><span class="line">4：小顶堆特点arr[i]&lt;=arr[2*i+1]&amp;&amp;arr[i]&lt;=arr[2*i+2],i对应的是第几个节点</span><br><span class="line">5：一般升序采用大顶堆，降序采用小顶堆</span><br></pre></td></tr></table></figure><p>2：堆排序实现思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆排序     O(nlog2n)      O(nlog2n)      O(nlog2n)         O(1) 不稳定  较复杂</span><br><span class="line">速度测试：800万数据排序话费时间1.7s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1：将待排序序列构造成一个大顶堆，（实际是用数组实现）</span><br><span class="line">2：此时，整个序列的最大值就是堆顶的根节点</span><br><span class="line">3：将其与末尾元素进行交换，此时末尾成为最大值</span><br><span class="line">4：然后将剩余N-1个元素重新构造成一个堆，这样就会得到n个元素的次小值，如此反复执行，便能得到一个有序序列了</span><br><span class="line">5：可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到了一个有序序列了</span><br><span class="line"></span><br><span class="line">逻辑：逻辑就是非叶子节点与它的子节点之间比较，如果子节点&gt;自己；那么就交换；然后继续进行下一个非叶子节点的比较；比较完成之后可以得到最大元素（即此时的堆顶元素），</span><br><span class="line">注意：非叶子节点的顺序是从右至左，从下至上，依次进行！</span><br></pre></td></tr></table></figure><p>3：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">package com.it.tree;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">//堆排序</span><br><span class="line">public class HeapSort &#123;</span><br><span class="line">    private static int temp = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试冒泡排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[8000000];</span><br><span class="line">        for (int i = 0; i &lt; 8000000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 80000000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start =System.currentTimeMillis();</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        long end =System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot;+(end-start));</span><br><span class="line"></span><br><span class="line">//        //要求将数组升序排列，需要构建大顶堆</span><br><span class="line">//        int arr[] = &#123;0, 1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">////        //分步完成.，这里测试是手动确定i值</span><br><span class="line">////        adjustHeap(arr, 1, arr.length);</span><br><span class="line">////        System.out.println(&quot;第一次调整&quot; + Arrays.toString(arr));</span><br><span class="line">////        //第二次排序</span><br><span class="line">////        adjustHeap(arr, 0, arr.length);</span><br><span class="line">////        System.out.println(&quot;第二次调整&quot;+Arrays.toString(arr));</span><br><span class="line">//        heapSort(arr);</span><br><span class="line">//        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //编写一个堆排序的方法,这里实现从下至上，从右至左</span><br><span class="line">    public static void heapSort(int[] arr) &#123;</span><br><span class="line">        System.out.println(&quot;堆排序！&quot;);</span><br><span class="line">        //这里是确定i来从下至上，从右至左实现方法：int i = arr.length/2-1即为从左下角开始</span><br><span class="line">        for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;//上述for循环结束即实现了一个大顶堆，后面需要交换堆顶与最后一个元素的值</span><br><span class="line">        for (int j = arr.length - 1; j &gt; 0; j--) &#123;</span><br><span class="line">            temp = arr[j];//从最后元素开始</span><br><span class="line">            arr[j] = arr[0];//arr[0]为最大值</span><br><span class="line">            arr[0] = temp;</span><br><span class="line">            adjustHeap(arr, 0, j);</span><br><span class="line">            // 方法中的i = k;//i指向k，</span><br><span class="line">            // 继续循环比较，最主要的是这里，</span><br><span class="line">            // 当i=0时，这里和for循环搭配起来实现了把arr[1]和arr[2]的值替换成了第二大和第三大的值</span><br><span class="line">            //所以每次都可以直接进行替换，而不需要再去从右至左的调用方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 功能：将以i对应的非叶子节点的树调整成大顶堆</span><br><span class="line">     * 例如：当i=1时，原数组为4,6,8,5,9, 调整成4,9,8,5,6</span><br><span class="line">     * 再次调用时，i=0,原数组4,9,8,5,6,调整成了9，6,8,5,4</span><br><span class="line">     *</span><br><span class="line">     * @param arr    待调整的数组</span><br><span class="line">     * @param i      表示非叶子节点在数组中的索引</span><br><span class="line">     * @param length 表示对多少个元素进行调整，length在逐渐减少</span><br><span class="line">     */</span><br><span class="line">    //将一个数组（二叉树），调整成一个大顶堆</span><br><span class="line">    public static void adjustHeap(int arr[], int i, int length) &#123;</span><br><span class="line">        int tmp = arr[i];//先取出当前元素的值，保留在临时变量</span><br><span class="line">        //k表示当前节点的左子叶节点，继续调整就是下一个节点的左子叶节点</span><br><span class="line">        for (int k = 2 * i + 1; k &lt; length; k = 2 * k + 1) &#123;</span><br><span class="line">            if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123;//说明左子节点小于右子节点值</span><br><span class="line">                k++;//k指向右子节点</span><br><span class="line">            &#125;</span><br><span class="line">            if (arr[k] &gt; tmp) &#123;</span><br><span class="line">                arr[i] = arr[k];//把子节点中的最大值赋值给该子叶节点</span><br><span class="line">                i = k;//i指向k，继续循环比较，最主要的是这里，当i=0时，这里和for循环搭配起来实现了把arr[1]和arr[2]的值替换成了第二大和第三大的值</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;//说明当前的i值对应的子叶节点的自己点都比自己小，无序调整。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //for循环结束之后就把当前i值对应的子叶节点调整为了大顶堆，arr[i]在i为父节点时候最大，注意前提条件i从右至左，从上至下扫描</span><br><span class="line">        arr[i] = tmp;//前面已经用temp记录了arr[i]的值，相当于是交换了arr[i]与arr[k]的值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五：树结构应用二：赫夫曼树"><a href="#五：树结构应用二：赫夫曼树" class="headerlink" title="五：树结构应用二：赫夫曼树"></a>五：树结构应用二：赫夫曼树</h3><p>1：赫夫曼树介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：赫夫曼树是带权路径长度最小的二叉树，用途是平均查找信息的代价最小。</span><br><span class="line">2：普通二叉树的用途也普通，比较通用，就是信息存储和查找。</span><br><span class="line">3：普通二叉树可能有的只有一个子节点，而哈夫曼树一定有两个。</span><br><span class="line">4：树的带权路径长度规定为所有叶子节点的带权路径长度之和，记为wpl。权值越大的节点离根节点越近的二叉树才是最优二叉树（赫夫曼树）。</span><br><span class="line">5：wpl最小的构建二叉树的方式即为赫夫曼树，注意权值在叶子节点上！</span><br></pre></td></tr></table></figure><p>2：构成赫夫曼树的步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">哈夫曼树的构造：</span><br><span class="line">假设给定的权值如下：3,5,7,8,10,15；</span><br><span class="line">首先取集合中最小的两个数：3+5=8，再删除集合中3和5的值，把8放入原集合,</span><br><span class="line">原集合变成:7,8,8,10,15；</span><br><span class="line"> 8</span><br><span class="line">/ \</span><br><span class="line">3 5</span><br><span class="line">继续取出最小2个数7 8 ，构成15，然后把7 8 删除，依次进行...所有数都使用完毕之后就变成了赫夫曼树。</span><br><span class="line"></span><br><span class="line">原理：最小两个数相累加的过程实际上就是两个子叶节点相加得到它们父节点的过程。所以说赫夫曼树的子节点一定有两个！</span><br></pre></td></tr></table></figure><p> 3：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package com.it.huffmantree;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class HuffmanTree &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr = &#123;13, 7, 8, 3, 29, 6, 1&#125;;</span><br><span class="line">        Node huffmanTree = createHuffmanTree(arr);</span><br><span class="line">        //前序遍历赫夫曼树</span><br><span class="line">        System.out.println(&quot;前序遍历赫夫曼树&quot;);</span><br><span class="line">        prOrder(huffmanTree);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //编写一个前序遍历的方法</span><br><span class="line">    public static void prOrder(Node root) &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;空树，无法遍历！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param arr 需要创建的赫夫曼树的数组、、</span><br><span class="line">     * @return 返回的是赫夫曼树的root节点</span><br><span class="line">     */</span><br><span class="line">    //创建赫夫曼树的方法</span><br><span class="line">    public static Node createHuffmanTree(int[] arr) &#123;</span><br><span class="line">        //为了操作方便，需要先把arr元素放在Node中，然后实现从小到大排序</span><br><span class="line">        List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;();</span><br><span class="line">        for (int value : arr) &#123;</span><br><span class="line">            nodes.add(new Node(value));</span><br><span class="line">        &#125;//for循环完成之后就实现了所有value放在了Node中</span><br><span class="line"></span><br><span class="line">        while (nodes.size() &gt; 1) &#123;//退出循环条件为nodes中只有一个元素</span><br><span class="line">            Collections.sort(nodes);//实现了排序，前提是Node实现了Comparable接口</span><br><span class="line">            //开始构建赫夫曼树</span><br><span class="line">            //1:取出权值最小的节点（二叉树）</span><br><span class="line">            Node leftNode = nodes.get(0);</span><br><span class="line">            //2：取出权值第二小的节点（二叉树）</span><br><span class="line">            Node rightNode = nodes.get(1);</span><br><span class="line">            //3:构建父节点，形成二叉树</span><br><span class="line">            Node parent = new Node(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            //4：从arr中删除leftNode与rightNode；同时使parent加入</span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">            //测试排序</span><br><span class="line">            System.out.println(&quot;nodes&quot; + nodes);</span><br><span class="line">        &#125;</span><br><span class="line">        //每一次循环就完成了一个二叉树的构建，并且删除了两个子节点，增加了一个父节点</span><br><span class="line">        //返回赫夫曼树的头</span><br><span class="line">        return nodes.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建节点类,为了让Node对象支持value排序，实现comparable接口</span><br><span class="line">class Node implements Comparable&lt;Node&gt; &#123;</span><br><span class="line">    int value;</span><br><span class="line">    Node left;//指向左子节点</span><br><span class="line">    Node right;//指向右子节点</span><br><span class="line"></span><br><span class="line">    //写一个前序遍历</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Node(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node&#123;&quot; +</span><br><span class="line">                &quot;value=&quot; + value +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Node o) &#123;</span><br><span class="line">        return this.value - o.value;//从小到大排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六：算法-赫夫曼编码"><a href="#六：算法-赫夫曼编码" class="headerlink" title="六：算法-赫夫曼编码"></a>六：算法-赫夫曼编码</h3><p>1：赫夫曼编码概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1:哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，哈夫曼编码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就叫做Huffman编码（有时也称为霍夫曼编码）</span><br><span class="line">2:压缩率通常在20%-90%之间</span><br></pre></td></tr></table></figure><p>2：赫夫曼编码实现分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1：传输的字符串 i like like like java do you like a java </span><br><span class="line">2：d 1; y 1;u 1;j 2;v 2;o 2;l 4;k 4;e 4;i 5;a 5;  9;各个字符对应的个数，包括最后是空格出现次数</span><br><span class="line">3：按照上面字符出现的次数构建一颗赫夫曼树，次数作为权值</span><br><span class="line">4：根据赫夫曼树，给各个字符，规定编码（前缀编码），向左的路径为0，向右的路径为1；即每个字符都得到了自己的编码，从根节点到字符的节点</span><br><span class="line">5：前缀编码：没有任何一个字符的编码是另一个字符的前缀；因为叶子节点不可能在另一个叶子节点下。</span><br><span class="line">6：按照上述的每个字符的编码，确定字符串对应的编码</span><br><span class="line"></span><br><span class="line">注意：当有多个权值一样时，赫夫曼树可能会出现多种情况，对应的字符编码也就不一样，但是不影响最终的wpl值</span><br></pre></td></tr></table></figure><p>3：代码实现字符串的压缩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">功能：根据赫夫曼编码数据的原理，需要创建i like like like java do you like a java对应的赫夫曼树</span><br><span class="line">思路：</span><br><span class="line">1：Node&#123;data(储存数据) weigth(权值)，left rigth&#125;</span><br><span class="line">2：得到i like like like java do you like a java对应的字节数组</span><br><span class="line">3：编写一个方法，将准备构建赫夫曼树的Node节点放在List中,[Node&#123;data=97,weight=5&#125;,Node&#123;data=32.weigth=9&#125;...]；体现d 1; y 1;u 1;j 2;v 2;o 2;l 4;k 4;e 4;i 5;a 5;  9</span><br><span class="line">4：通过List构建对应的赫夫曼树</span><br><span class="line">5：遍历赫夫曼树得到对应字符的赫夫曼编码</span><br><span class="line">6：传入字符串，得到字符串对应使用赫夫曼编码编码的数据</span><br><span class="line"></span><br><span class="line">核心代码步骤：</span><br><span class="line">//根据字节数组中字符出现的次数，封装到node中，形成nodes集合</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        //根据nodes创建赫夫曼树</span><br><span class="line">        Node huffmanTree = createHuffmanTree(nodes);</span><br><span class="line">        //根据赫夫曼树创建对应的赫夫曼编码</span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTree);</span><br><span class="line">        //根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span><br><span class="line">        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line">        return huffmanCodeBytes;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">package com.it.huffmancode;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class HuffmanCode &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//i like like like java do you like a java</span><br><span class="line">        String content = &quot;i like like like java do you like a java&quot;;</span><br><span class="line">        byte[] contentBytes = content.getBytes();</span><br><span class="line">     /* 分步：</span><br><span class="line">         System.out.println(Arrays.toString(contentBytes));</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(contentBytes);</span><br><span class="line">        System.out.println(nodes);</span><br><span class="line">        Node huffmanTree = createHuffmanTree(nodes);//huffmanTree为赫夫曼树的根节点</span><br><span class="line">        //遍历</span><br><span class="line">        System.out.println(&quot;前序遍历&quot;);</span><br><span class="line">        prOrder(huffmanTree);</span><br><span class="line">        //测试是否生成对应的赫夫曼编码</span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTree);</span><br><span class="line">        System.out.println(&quot;生成的哈夫曼编码表&quot; + huffmanCodes);</span><br><span class="line">        //测试</span><br><span class="line">        byte[] huffmanCodeBytes = zip(contentBytes, huffmanCodes);</span><br><span class="line">        //huffmanCodeBytes=[-44, -33, -12, -33, -12, -33, -12, -18, -21, -109, 118, 121, 77, -1, 106, 119, 14],已经到达了压缩</span><br><span class="line">        System.out.println(&quot;huffmanCodeBytes=&quot; + Arrays.toString(huffmanCodeBytes));*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //整体测试</span><br><span class="line">        byte[] huffmanCodeBytes = huffmanZip(contentBytes);</span><br><span class="line">        System.out.println(&quot;压缩后的结果是：&quot;+Arrays.toString(huffmanCodeBytes));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param bytes 原始字符串对应的字节数组（contents）</span><br><span class="line">     * @return 经过赫夫曼编码处理后的字节数组（压缩后的数组）</span><br><span class="line">     */</span><br><span class="line">    //使用一个方法，把前面的方法都封装起来，便于调用</span><br><span class="line">    private static byte[] huffmanZip(byte[] bytes) &#123;</span><br><span class="line">        //根据字节数组中字符出现的次数，封装到node中，形成nodes集合</span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        //根据nodes创建赫夫曼树</span><br><span class="line">        Node huffmanTree = createHuffmanTree(nodes);</span><br><span class="line">        //根据赫夫曼树创建对应的赫夫曼编码</span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTree);</span><br><span class="line">        //根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span><br><span class="line">        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);</span><br><span class="line">        return huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param bytes        这是原始的字符串对应的byte[]</span><br><span class="line">     * @param huffmanCodes 生成的赫夫曼编码map</span><br><span class="line">     * @return 返回赫夫曼编码处理后的byte[]</span><br><span class="line">     * 举例：传入的String content = &quot;i like like like java do you like a java&quot;;</span><br><span class="line">     * 返回的是字符串&quot;10101000...&quot;对应的byte[] huffmanCodeBytes,即8位对应的一个byte，放入到huffmanCodeBytes中</span><br><span class="line">     * huffmanCodeBytes[0]=10101000（补码）=&gt;byte[推倒10101000-1=&gt;10100111（反码）=&gt;11011000（原码）]</span><br><span class="line">     * 即huffmanCodeBytes[0]=&gt;  -88</span><br><span class="line">     */</span><br><span class="line">    //编写一个方法，传入字符串，得到对应通过赫夫曼编码编码之后的01数据</span><br><span class="line">    private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        for (byte b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(b));//这里就是得到了字符串&quot;10101000...&quot;，不管哪种方式编码都是133位</span><br><span class="line">        &#125;</span><br><span class="line">        //将字符串&quot;10101000...&quot;转换为byte[]，才能传输</span><br><span class="line">        //统计返回byte[]huffmanCodes长度</span><br><span class="line">        int len;</span><br><span class="line">        if (stringBuilder.length() % 8 == 0) &#123;</span><br><span class="line">            len = stringBuilder.length() / 8;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            len = stringBuilder.length() / 8 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个存储压缩后的byte[]</span><br><span class="line">        byte[] huffmanCodeBytes = new byte[len];</span><br><span class="line">        int index = 0;//记录是第几个byte</span><br><span class="line">        //遍历</span><br><span class="line">        for (int i = 0; i &lt; stringBuilder.length(); i += 8) &#123;//因为每8位对应一个byte,所以步长为8</span><br><span class="line">            String strByte;</span><br><span class="line">            if (i + 8 &gt; stringBuilder.length()) &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + 8);</span><br><span class="line">            &#125;</span><br><span class="line">            //将strByte转成byte，放入huffmanCodeBytes</span><br><span class="line">            huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte, 2);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        //循环结束之后得到赫夫曼得到的字节数组</span><br><span class="line">        return huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //生成赫夫曼树对应的赫夫曼编码</span><br><span class="line">    //思路：</span><br><span class="line">    //1：遍历赫夫曼树，得到路径，形成byte→01这种形式,需要Map集合储存</span><br><span class="line">    //2：路径需要拼接，定义StringBuilder储存叶子节点的路径</span><br><span class="line">    static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;Byte, String&gt;();</span><br><span class="line">    static StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line"></span><br><span class="line">    //重载getCodes()</span><br><span class="line">    private static Map&lt;Byte, String&gt; getCodes(Node root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(root, &quot;0&quot;, stringBuilder);</span><br><span class="line">        getCodes(root, &quot;1&quot;, stringBuilder);</span><br><span class="line">        return huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将传入的node节点所有的赫夫曼编码得到，并放入到集合huffmanCodes</span><br><span class="line">     *</span><br><span class="line">     * @param node          传入节点</span><br><span class="line">     * @param code          代表路径，左代表0，右代表1</span><br><span class="line">     * @param stringBuilder 拼接路径的字符串</span><br><span class="line">     */</span><br><span class="line">    private static void getCodes(Node node, String code, StringBuilder stringBuilder) &#123;</span><br><span class="line">        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);</span><br><span class="line">        //将code加入到stringBuilder2中</span><br><span class="line">        stringBuilder2.append(code);</span><br><span class="line">        if (node != null) &#123;//node==null不处理</span><br><span class="line">            //判断当前node是叶子节点还是非叶子节点</span><br><span class="line">            if (node.data == null) &#123;//说明是非叶子节点</span><br><span class="line">                //递归处理</span><br><span class="line">                //向左递归</span><br><span class="line">                getCodes(node.left, &quot;0&quot;, stringBuilder2);</span><br><span class="line">                //向右递归</span><br><span class="line">                getCodes(node.right, &quot;1&quot;, stringBuilder2);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //说明是叶子节点，表示已经找到</span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序遍历</span><br><span class="line">    private static void prOrder(Node root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            System.out.println(&quot;无节点，无法遍历&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param bytes 接收字节数组</span><br><span class="line">     * @return 返回的是Nodes</span><br><span class="line">     */</span><br><span class="line">    private static List&lt;Node&gt; getNodes(byte[] bytes) &#123;</span><br><span class="line">        //1:创建一个ArrayList</span><br><span class="line">        ArrayList&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;();</span><br><span class="line">        //遍历bytes，存储每个byte出现的次数，使用map</span><br><span class="line">        //byte对应的是字符，Integer对应的字符出现的次数</span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = new HashMap&lt;&gt;();</span><br><span class="line">        //循环遍历bytes</span><br><span class="line">        for (Byte b : bytes) &#123;</span><br><span class="line">            Integer count = counts.get(b);//通过key获取对应的Integer</span><br><span class="line">            if (count == null) &#123;//说明map中还没key为b的这个字符</span><br><span class="line">                counts.put(b, 1);//把b放入，记为1次</span><br><span class="line">            &#125; else &#123;//说明map中已经有b</span><br><span class="line">                counts.put(b, count + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//循环结束之后就得到了Map，为每个字符对应的次数的键值对</span><br><span class="line">        //遍历Map,把每个键值对转换为Node对象,并加入nodes</span><br><span class="line">        for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(new Node(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        return nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param nodes 传入的Node集合</span><br><span class="line">     * @return 返回的赫夫曼树的root节点</span><br><span class="line">     */</span><br><span class="line">    //通过list创建赫夫曼树</span><br><span class="line">    private static Node createHuffmanTree(List&lt;Node&gt; nodes) &#123;</span><br><span class="line">        while (nodes.size() &gt; 1) &#123;</span><br><span class="line">            Collections.sort(nodes);//从小到大</span><br><span class="line">            //取出第一颗最小二叉树</span><br><span class="line">            Node leftNode = nodes.get(0);</span><br><span class="line">            //取出第二颗最小二叉树</span><br><span class="line">            Node rightNode = nodes.get(1);</span><br><span class="line">            //创建一颗新的二叉树,根节点没有data,只有权值</span><br><span class="line">            Node parent = new Node(null, leftNode.weight + rightNode.weight);</span><br><span class="line">            //挂起</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            //移除已经处理的两个二叉树</span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            //将新的二叉树加入到nodes</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回的就是最后的节点，即赫夫曼树的根节点</span><br><span class="line">        return nodes.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建Node，存数据合权值</span><br><span class="line">class Node implements Comparable&lt;Node&gt; &#123;</span><br><span class="line">    Byte data;//存放数据本身，比如&apos;a&apos;→97  &apos; &apos;→32</span><br><span class="line">    int weight;//权值，为字符出现的次数</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    public Node(Byte data, int weight) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Node o) &#123;</span><br><span class="line">        return this.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Node&#123;&quot; +</span><br><span class="line">                &quot;data=&quot; + data +</span><br><span class="line">                &quot;, weight=&quot; + weight +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前序遍历</span><br><span class="line">    public void preOrder() &#123;</span><br><span class="line">        System.out.println(this);</span><br><span class="line">        if (this.left != null) &#123;</span><br><span class="line">            this.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.right != null) &#123;</span><br><span class="line">            this.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七：算法：赫夫曼解压"><a href="#七：算法：赫夫曼解压" class="headerlink" title="七：算法：赫夫曼解压"></a>七：算法：赫夫曼解压</h3><p>1：赫夫曼解码步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目标：完成用赫夫曼编码过后的字节数组解压成字符串</span><br><span class="line">1：压缩后的结果是：[-44, -33, -12, -33, -12, -33, -12, -18, -21, -109, 118, 121, 77, -1, 106, 119, 14]→转换为赫夫曼编码对应的二进制字符串&quot;10101000...&quot;</span><br><span class="line">2:字符串&quot;10101000...&quot;对照赫夫曼编码=&gt;重新转换为String content = &quot;i like like like java do you like a java&quot;;</span><br><span class="line">3：实际就是压缩的逆向过程</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：树&quot;&gt;&lt;a href=&quot;#1：树&quot; class=&quot;headerlink&quot; title=&quot;1：树&quot;&gt;&lt;/a&gt;1：树&lt;/h1&gt;&lt;h3 id=&quot;一：普通二叉树&quot;&gt;&lt;a href=&quot;#一：普通二叉树&quot; class=&quot;headerlink&quot; title=&quot;一：普通二叉树
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（6）哈希表</title>
    <link href="https://yanyubing.xyz/2018/06/26/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://yanyubing.xyz/2018/06/26/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%886%EF%BC%89%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2018-06-26T13:46:12.000Z</published>
    <updated>2019-12-06T01:21:31.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：哈希表"><a href="#1：哈希表" class="headerlink" title="1：哈希表"></a>1：哈希表</h1><p>1：哈希表概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</span><br><span class="line"></span><br><span class="line">给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1：使用哈希表实现对员工信息的增删改查，注意下列代码没有实现删除功能，因为创建的链表是没有头节点的，不适合删除节点信息</span><br><span class="line">2：class Emp 表示员工</span><br><span class="line">3：class HashTabDemo 主类</span><br><span class="line">4：class EmpLinkedList 表示链表</span><br><span class="line">5：哈希表管理多条链表，聊表之间散列</span><br><span class="line">6：直接使用链表查找慢，使用哈希表可以提高查找效率</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">package com.it.hashTable;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class HashTabDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建哈希表</span><br><span class="line">        HashTable hashTable = new HashTable(7);//7条链表</span><br><span class="line">        //菜单</span><br><span class="line">        String key = &quot;&quot;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;-------------&quot;);</span><br><span class="line">            System.out.println(&quot;add：添加雇员&quot;);</span><br><span class="line">            System.out.println(&quot;list：显示雇员&quot;);</span><br><span class="line">            System.out.println(&quot;find：查找雇员&quot;);</span><br><span class="line">            System.out.println(&quot;exit：退出系统&quot;);</span><br><span class="line"></span><br><span class="line">            key = scanner.next();</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &quot;add&quot;:</span><br><span class="line">                    System.out.println(&quot;输入id&quot;);</span><br><span class="line">                    int id = scanner.nextInt();</span><br><span class="line">                    System.out.println(&quot;输入名字&quot;);</span><br><span class="line">                    String name = scanner.next();</span><br><span class="line">                    //创建雇员</span><br><span class="line">                    Emp emp = new Emp(id, name);</span><br><span class="line">                    hashTable.add(emp);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;list&quot;:</span><br><span class="line">                    hashTable.list();</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;find&quot;:</span><br><span class="line">                    System.out.println(&quot;请输入要查找的id&quot;);</span><br><span class="line">                    id = scanner.nextInt();</span><br><span class="line">                    hashTable.findEmpById(id);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;exit&quot;:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(0);</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建哈希表，管理多条链表</span><br><span class="line">class HashTable &#123;</span><br><span class="line">    //size是链表的条数</span><br><span class="line">    private int size;</span><br><span class="line">    private EmpLinkedList[] empLinkedListArray;</span><br><span class="line">    //构造器</span><br><span class="line"></span><br><span class="line">    public HashTable(int size) &#123;//链表的条数</span><br><span class="line">        this.size = size;</span><br><span class="line">        empLinkedListArray = new EmpLinkedList[size];</span><br><span class="line">        //链表需要指向头指针,分别初始化每一条链表</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i] = new EmpLinkedList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //添加雇员</span><br><span class="line">    public void add(Emp emp) &#123;</span><br><span class="line">        //根据员工的id，得到员工应当添加到哪条链表</span><br><span class="line">        int empLinkedListNO = hashFun(emp.id);</span><br><span class="line">        //将emp添加到对应的链表中</span><br><span class="line">        empLinkedListArray[empLinkedListNO].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历所有链表，遍历哈希表</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i].list(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据输入的id查找雇员</span><br><span class="line">    public void findEmpById(int id) &#123;</span><br><span class="line">        //使用散列函数确定在哪条链表查找</span><br><span class="line">        int empLinkedListNO = hashFun(id);</span><br><span class="line">        Emp emp = empLinkedListArray[empLinkedListNO].findEmpByiId(id);</span><br><span class="line">        if (emp != null) &#123;</span><br><span class="line">            //找到</span><br><span class="line">            System.out.printf(&quot;在第%d条链表找到雇员id=%d\t&quot;, (empLinkedListNO + 1), id);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;在哈希表中没有找到雇员&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    //编写散列函数，使用简单的取模法</span><br><span class="line">    public int hashFun(int id) &#123;</span><br><span class="line">        return id % size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//表示一个员工</span><br><span class="line">class Emp &#123;</span><br><span class="line">    public int id;</span><br><span class="line">    public String name;</span><br><span class="line">    public Emp next;//next默认为null，下一个节点</span><br><span class="line"></span><br><span class="line">    public Emp(int id, String name) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//表示一个链表</span><br><span class="line">class EmpLinkedList &#123;</span><br><span class="line">    //头指针，执行第一个Emp，直接指向第一个Emp</span><br><span class="line">    private Emp head;</span><br><span class="line"></span><br><span class="line">    //添加雇员到链表哦</span><br><span class="line">    //1：假定当添加雇员时，id是自增长的，id的分配总是从下到大的</span><br><span class="line">    //2：因此直接将雇员加载到本链表的最后即可</span><br><span class="line">    public void add(Emp emp) &#123;</span><br><span class="line">        //如果是添加第一个雇员</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            head = emp;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果不是第一个雇员</span><br><span class="line">        Emp curEmp = head;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (curEmp.next == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curEmp.next = emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历链表雇员信息</span><br><span class="line">    public void list(int no) &#123;//no是打印当前条数</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            System.out.println(&quot;第&quot; + (no + 1) + &quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;第&quot; + (no + 1) + &quot;链表的信息为&quot;);</span><br><span class="line">        Emp curEmp = head;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.printf(&quot;=&gt;id =%d name=%s\t&quot;, curEmp.id, curEmp.name);</span><br><span class="line">            if (curEmp.next == null) &#123;//说明已经到了最后</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;//后移</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据id查找雇员</span><br><span class="line">    //如果查找到，就返回emp,如果没找到，就返回null，这里的查找方法是对应的每一条自己的链表，后面hashtable调用的饿时候可以提前判断在哪一条链表中</span><br><span class="line">    public Emp findEmpByiId(int id) &#123;</span><br><span class="line">        //判断链表是否为空</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //辅助指针</span><br><span class="line">        Emp curEmp = head;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (curEmp.id == id) &#123;//说明找到</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //退出</span><br><span class="line">            if (curEmp.next == null) &#123;</span><br><span class="line">                curEmp = null;</span><br><span class="line">                break;</span><br><span class="line">                //说明链表已经遍历完</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;//后移</span><br><span class="line">        &#125;</span><br><span class="line">        return curEmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：哈希表&quot;&gt;&lt;a href=&quot;#1：哈希表&quot; class=&quot;headerlink&quot; title=&quot;1：哈希表&quot;&gt;&lt;/a&gt;1：哈希表&lt;/h1&gt;&lt;p&gt;1：哈希表概述&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（5）查找</title>
    <link href="https://yanyubing.xyz/2018/06/22/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E6%9F%A5%E6%89%BE/"/>
    <id>https://yanyubing.xyz/2018/06/22/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%885%EF%BC%89%E6%9F%A5%E6%89%BE/</id>
    <published>2018-06-22T13:46:12.000Z</published>
    <updated>2019-12-07T15:55:03.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1：线性查找"><a href="#1：线性查找" class="headerlink" title="1：线性查找"></a>1：线性查找</h1><p>1：线性查找思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1：遍历数组，逐一匹配，相等即返回</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">public class SeqSearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] = &#123;1, 9, 11, -1, 34, 89&#125;;</span><br><span class="line">        int value = 9;</span><br><span class="line">        System.out.println(seqSearch(arr, value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int seqSearch(int[] arr, int value) &#123;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (value == arr[i]) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2：二分查找"><a href="#2：二分查找" class="headerlink" title="2：二分查找"></a>2：二分查找</h3><p>1：二分查找思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：要求数组有序（假设从下到大排序）</span><br><span class="line">2：首先确定该数组的中间的下标 mid=(left+right)/2</span><br><span class="line">3：arr[mid]与要查找的数val比较</span><br><span class="line">4：如果arr[mid]&gt;val，则表示val在arr[mid]左边，再次移动left和rigth继续查找</span><br><span class="line">5：相反arr[mid]&lt;val，同理</span><br><span class="line">6：arr[mid]==val则直接返回</span><br><span class="line">7：递归结束条件，rigth-left==1</span><br></pre></td></tr></table></figure><p>2：代码实现（1）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//该代码只能找到只有一个匹配的值的索引</span><br><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">public class BinarySearch &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] = &#123;1, 8, 10, 89, 1000, 1234&#125;;</span><br><span class="line">        int res = binarySearch(arr, 0, arr.length - 1, 10);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int binarySearch(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line">        if (right - left == 0) &#123;</span><br><span class="line">            return -1;//说明递归已经完成，没找到</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right) / 2;</span><br><span class="line">        if (arr[mid] &gt; findVal) &#123;//说明该值在左标</span><br><span class="line">            return binarySearch(arr, left, mid - 1, findVal);</span><br><span class="line">        &#125;</span><br><span class="line">        if (arr[mid] &lt; findVal) &#123;//说明该值在右标</span><br><span class="line">            return binarySearch(arr, mid + 1, right, findVal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mid;//最终找到的结果数据是这句话</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3：代码实现（二）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">//注意：使用二分查找的前提是 该数组是有序的.</span><br><span class="line">public class BinarySearch &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;;</span><br><span class="line">int arr[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 , 11, 12, 13,14,15,16,17,18,19,20 &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//int resIndex = binarySearch(arr, 0, arr.length - 1, 1000);</span><br><span class="line">//System.out.println(&quot;resIndex=&quot; + resIndex);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; resIndexList = binarySearch2(arr, 0, arr.length - 1, 1);</span><br><span class="line">System.out.println(&quot;resIndexList=&quot; + resIndexList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 二分查找算法</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param arr</span><br><span class="line"> *            数组</span><br><span class="line"> * @param left</span><br><span class="line"> *            左边的索引</span><br><span class="line"> * @param right</span><br><span class="line"> *            右边的索引</span><br><span class="line"> * @param findVal</span><br><span class="line"> *            要查找的值</span><br><span class="line"> * @return 如果找到就返回下标，如果没有找到，就返回 -1</span><br><span class="line"> */</span><br><span class="line">public static int binarySearch(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span><br><span class="line">if (left &gt; right) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (left + right) / 2;</span><br><span class="line">int midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">if (findVal &gt; midVal) &#123; // 向 右递归</span><br><span class="line">return binarySearch(arr, mid + 1, right, findVal);</span><br><span class="line">&#125; else if (findVal &lt; midVal) &#123; // 向左递归</span><br><span class="line">return binarySearch(arr, left, mid - 1, findVal);</span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//思考题:</span><br><span class="line">/*</span><br><span class="line"> *  &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中，</span><br><span class="line"> * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</span><br><span class="line"> * </span><br><span class="line"> * 思路分析</span><br><span class="line"> * 1. 在找到mid 索引值，不要马上返回</span><br><span class="line"> * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line"> * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line"> * 4. 将Arraylist返回</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public static List&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;hello~&quot;);</span><br><span class="line">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span><br><span class="line">if (left &gt; right) &#123;</span><br><span class="line">return new ArrayList&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line">int mid = (left + right) / 2;</span><br><span class="line">int midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">if (findVal &gt; midVal) &#123; // 向 右递归</span><br><span class="line">return binarySearch2(arr, mid + 1, right, findVal);</span><br><span class="line">&#125; else if (findVal &lt; midVal) &#123; // 向左递归</span><br><span class="line">return binarySearch2(arr, left, mid - 1, findVal);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// * 思路分析</span><br><span class="line">// * 1. 在找到mid 索引值，不要马上返回</span><br><span class="line">// * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line">// * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line">// * 4. 将Arraylist返回</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; resIndexlist = new ArrayList&lt;Integer&gt;();</span><br><span class="line">//向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line">int temp = mid - 1;</span><br><span class="line">while(true) &#123;</span><br><span class="line">if (temp &lt; 0 || arr[temp] != findVal) &#123;//退出</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//否则，就temp 放入到 resIndexlist</span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp -= 1; //temp左移</span><br><span class="line">&#125;</span><br><span class="line">resIndexlist.add(mid);  //</span><br><span class="line"></span><br><span class="line">//向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span><br><span class="line">temp = mid + 1;</span><br><span class="line">while(true) &#123;</span><br><span class="line">if (temp &gt; arr.length - 1 || arr[temp] != findVal) &#123;//退出</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">//否则，就temp 放入到 resIndexlist</span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp += 1; //temp右移</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return resIndexlist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三：插值查找"><a href="#三：插值查找" class="headerlink" title="三：插值查找"></a>三：插值查找</h3><p>1：插值查找思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：插值查找和二分查找思想是一样，只是中值的确定由原来的二等分改变成了等比值，</span><br><span class="line">例如：mid(索引)=left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left])</span><br><span class="line">2:相当于更加适合线性的数组</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class InsertValueSearch &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">//int [] arr = new int[100];</span><br><span class="line">//for(int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">//arr[i] = i + 1;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;;</span><br><span class="line"></span><br><span class="line">int index = insertValueSearch(arr, 0, arr.length - 1, 1234);</span><br><span class="line">//int index = binarySearch(arr, 0, arr.length, 1);</span><br><span class="line">System.out.println(&quot;index = &quot; + index);</span><br><span class="line"></span><br><span class="line">//System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int binarySearch(int[] arr, int left, int right, int findVal) &#123;</span><br><span class="line">System.out.println(&quot;二分查找被调用~&quot;);</span><br><span class="line">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span><br><span class="line">if (left &gt; right) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (left + right) / 2;</span><br><span class="line">int midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">if (findVal &gt; midVal) &#123; // 向 右递归</span><br><span class="line">return binarySearch(arr, mid + 1, right, findVal);</span><br><span class="line">&#125; else if (findVal &lt; midVal) &#123; // 向左递归</span><br><span class="line">return binarySearch(arr, left, mid - 1, findVal);</span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写插值查找算法</span><br><span class="line">//说明：插值查找算法，也要求数组是有序的</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param arr 数组</span><br><span class="line"> * @param left 左边索引</span><br><span class="line"> * @param right 右边索引</span><br><span class="line"> * @param findVal 查找值</span><br><span class="line"> * @return 如果找到，就返回对应的下标，如果没有找到，返回-1</span><br><span class="line"> */</span><br><span class="line">public static int insertValueSearch(int[] arr, int left, int right, int findVal) &#123; </span><br><span class="line"></span><br><span class="line">System.out.println(&quot;插值查找次数~~&quot;);</span><br><span class="line"></span><br><span class="line">//注意：findVal &lt; arr[0]  和  findVal &gt; arr[arr.length - 1] 必须需要</span><br><span class="line">//否则我们得到的 mid 可能越界</span><br><span class="line">if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1]) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 求出mid, 自适应</span><br><span class="line">int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">int midVal = arr[mid];</span><br><span class="line">if (findVal &gt; midVal) &#123; // 说明应该向右边递归</span><br><span class="line">return insertValueSearch(arr, mid + 1, right, findVal);</span><br><span class="line">&#125; else if (findVal &lt; midVal) &#123; // 说明向左递归查找</span><br><span class="line">return insertValueSearch(arr, left, mid - 1, findVal);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四：斐波那契查找"><a href="#四：斐波那契查找" class="headerlink" title="四：斐波那契查找"></a>四：斐波那契查找</h3><p>1：斐波那契查找思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：斐波那契查找和二分查找也类似，也是在于中值的mid的确定，mid依赖斐波那契数组来实现</span><br><span class="line">2：斐波那契数列1,1,2,3,5,8,13,21,34,55,89...，对应的是取索引需求</span><br><span class="line">3：例如元素组元素个数为10个，因为斐波那契中只有8,13，所有需要创建临时数组长度为13，拷贝原数组，剩余元素用arr[9]填充。</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">package com.it.search;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class FibonacciSearch &#123;</span><br><span class="line"></span><br><span class="line">public static int maxSize = 20;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int [] arr = &#123;1,8, 10, 89, 1000, 1234&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;index=&quot; + fibSearch(arr, 189));// 0</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span><br><span class="line">//非递归方法得到一个斐波那契数列</span><br><span class="line">public static int[] fib() &#123;</span><br><span class="line">int[] f = new int[maxSize];</span><br><span class="line">f[0] = 1;</span><br><span class="line">f[1] = 1;</span><br><span class="line">for (int i = 2; i &lt; maxSize; i++) &#123;</span><br><span class="line">f[i] = f[i - 1] + f[i - 2];</span><br><span class="line">&#125;</span><br><span class="line">return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写斐波那契查找算法</span><br><span class="line">//使用非递归的方式编写算法</span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param a  数组</span><br><span class="line"> * @param key 我们需要查找的关键码(值)</span><br><span class="line"> * @return 返回对应的下标，如果没有-1</span><br><span class="line"> */</span><br><span class="line">public static int fibSearch(int[] a, int key) &#123;</span><br><span class="line">int low = 0;</span><br><span class="line">int high = a.length - 1;</span><br><span class="line">int k = 0; //表示斐波那契分割数值的下标</span><br><span class="line">int mid = 0; //存放mid值</span><br><span class="line">int f[] = fib(); //获取到斐波那契数列</span><br><span class="line">//获取到斐波那契分割数值的下标</span><br><span class="line">while(high &gt; f[k] - 1) &#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span><br><span class="line">//不足的部分会使用0填充</span><br><span class="line">int[] temp = Arrays.copyOf(a, f[k]);</span><br><span class="line">//实际上需求使用a数组最后的数填充 temp</span><br><span class="line">//举例:</span><br><span class="line">//temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125;  =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125;</span><br><span class="line">for(int i = high + 1; i &lt; temp.length; i++) &#123;</span><br><span class="line">temp[i] = a[high];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用while来循环处理，找到我们的数 key</span><br><span class="line">while (low &lt;= high) &#123; // 只要这个条件满足，就可以找</span><br><span class="line">mid = low + f[k - 1] - 1;</span><br><span class="line">if(key &lt; temp[mid]) &#123; //我们应该继续向数组的前面查找(左边)</span><br><span class="line">high = mid - 1;</span><br><span class="line">//为甚是 k--</span><br><span class="line">//说明</span><br><span class="line">//1. 全部元素 = 前面的元素 + 后边元素</span><br><span class="line">//2. f[k] = f[k-1] + f[k-2]</span><br><span class="line">//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]</span><br><span class="line">//即 在 f[k-1] 的前面继续查找 k--</span><br><span class="line">//即下次循环 mid = f[k-1-1]-1</span><br><span class="line">k--;</span><br><span class="line">&#125; else if ( key &gt; temp[mid]) &#123; // 我们应该继续向数组的后面查找(右边)</span><br><span class="line">low = mid + 1;</span><br><span class="line">//为什么是k -=2</span><br><span class="line">//说明</span><br><span class="line">//1. 全部元素 = 前面的元素 + 后边元素</span><br><span class="line">//2. f[k] = f[k-1] + f[k-2]</span><br><span class="line">//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]</span><br><span class="line">//4. 即在f[k-2] 的前面进行查找 k -=2</span><br><span class="line">//5. 即下次循环 mid = f[k - 1 - 2] - 1</span><br><span class="line">k -= 2;</span><br><span class="line">&#125; else &#123; //找到</span><br><span class="line">//需要确定，返回的是哪个下标</span><br><span class="line">if(mid &lt;= high) &#123;</span><br><span class="line">return mid;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return high;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1：线性查找&quot;&gt;&lt;a href=&quot;#1：线性查找&quot; class=&quot;headerlink&quot; title=&quot;1：线性查找&quot;&gt;&lt;/a&gt;1：线性查找&lt;/h1&gt;&lt;p&gt;1：线性查找思路&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法(4)排序算法</title>
    <link href="https://yanyubing.xyz/2018/06/15/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(4)%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://yanyubing.xyz/2018/06/15/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(4)%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2018-06-15T13:46:12.000Z</published>
    <updated>2019-12-06T01:20:59.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：排序"><a href="#一：排序" class="headerlink" title="一：排序"></a>一：排序</h1><h3 id="1：排序的分类"><a href="#1：排序的分类" class="headerlink" title="1：排序的分类"></a>1：排序的分类</h3><p>1：内部排序（使用内存）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：插入排序：直接插入排序，希尔排序</span><br><span class="line">2：选择排序：简单选择排序，堆排序</span><br><span class="line">3：交换排序：冒泡排序，快速排序</span><br><span class="line">4：归并排序</span><br><span class="line">5：基数排序</span><br></pre></td></tr></table></figure><p>2：外部排序：数据量过大的情况</p><h3 id="2：算法的时间复杂度"><a href="#2：算法的时间复杂度" class="headerlink" title="2：算法的时间复杂度"></a>2：算法的时间复杂度</h3><p>1：事后统计法：比较依赖机器性能</p><p>2：事前估算的方法：分析</p><p>3：时间频度：一个算法话费的时间与算法中语句执行次数成正比，哪个算法中语句执行次数多，它花费的时间就多</p><p>4：时间频度简化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1：忽略常数项</span><br><span class="line">2：忽略低次项</span><br></pre></td></tr></table></figure><p>5：时间复杂度(又叫渐进时间复杂度)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：忽略低阶项</span><br><span class="line">2：取出最高阶系数</span><br><span class="line">3：只有常数阶O(1)</span><br></pre></td></tr></table></figure><p>6：常见的时间复杂度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1：常数阶O(1)</span><br><span class="line">2：对数阶O(log2n)</span><br><span class="line">3：线性阶O(n)</span><br><span class="line">4：线性对数阶O(nlog2n)</span><br><span class="line">5：平方阶O(n^2)</span><br><span class="line">6：立方阶O(n^3)</span><br><span class="line">7：k次方阶O(n^k)</span><br><span class="line">8：指数阶O(2^n)</span><br><span class="line">时间复杂度从上到下依次变劣！</span><br></pre></td></tr></table></figure><p>7：对数阶</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">  while (i &lt; n) &#123;</span><br><span class="line">   i = i * 2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>8：平均时间复杂度和最坏时间复杂度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1：平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间</span><br><span class="line">2：一般讨论的时间复杂度是最坏时间复杂度</span><br><span class="line">3：平均时间复杂度和最坏时间复杂度是否一致，和算法有关</span><br></pre></td></tr></table></figure><p>9：常见排序算法的时间复杂度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">排序方法时间复杂度（平均）时间复杂度（最坏)时间复杂度（最好)空间复杂度稳定性 复杂性</span><br><span class="line">直接插入排序  O(n2)O(n2)O(n)   O(1)稳定 简单</span><br><span class="line">希尔排序   O(nlog2n) O(n2) O(n)O(1)不稳定 较复杂</span><br><span class="line">直接选择排序  O(n2)    O(n2)O(n2)   O(1)   不稳定简单</span><br><span class="line">堆排序     O(nlog2n)      O(nlog2n)      O(nlog2n)         O(1) 不稳定  较复杂</span><br><span class="line">冒泡排序   O(n2) O(n2) O(n)O(1) 稳定  简单</span><br><span class="line">快速排序   O(nlog2n) O(n2) O(nlog2n)  O(nlog2n) 不稳定 较复杂</span><br><span class="line">归并排序   O(nlog2n)     O(nlog2n)     O(nlog2n)        O(n) 稳定  较复杂</span><br><span class="line">基数排序   O(d(n+r))    O(d(n+r))     O(d(n+r))      O(n+r)   稳定  较复杂</span><br></pre></td></tr></table></figure><h3 id="三：冒泡排序"><a href="#三：冒泡排序" class="headerlink" title="三：冒泡排序"></a>三：冒泡排序</h3><p>1：冒泡排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过对待排序序列从前向后，下标较小的元素开始，依次比较相邻元素的值；若发现逆序则交换，使值较大的元素逐渐向前移动到后部，就像水滴的气泡一样逐渐向上冒。</span><br><span class="line">第一次遍历完成就实现了最后一个元素是最大值，</span><br><span class="line">第二次遍历完成就实现了最后一个元素是倒数第二大值，</span><br><span class="line">...</span><br><span class="line">最多进行数组长度-1次遍历完成</span><br><span class="line">优化：在某趟排序中，没有发生一次排序，则可以提前完成排序。</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序   O(n2) O(n2) O(n)O(1) 稳定  简单</span><br><span class="line">优化之后：80000数据最终花费时间约10s</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //      int arr[] = &#123;3, 9, -1, 10, 20&#125;;</span><br><span class="line">        //    bubbleSort(arr);</span><br><span class="line">        //测试冒泡排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[80000];</span><br><span class="line">        for (int i = 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 8000000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start =System.currentTimeMillis();</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        long end =System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot;+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //排序方式</span><br><span class="line">    public static void bubbleSort(int[] arr) &#123;</span><br><span class="line">        boolean flag = false;//优化：定义标志位，判断是否交换过</span><br><span class="line">        int tmp = 0;//临时变量，用于交换</span><br><span class="line">        for (int j = 0; j &lt; arr.length - 1; j++) &#123;</span><br><span class="line">            //一次内层循环完成最后一个数的确定</span><br><span class="line">            for (int i = 0; i &lt; arr.length - j - 1; i++) &#123;</span><br><span class="line">                //满足交换条件</span><br><span class="line">                if (arr[i] &gt; arr[i + 1]) &#123;</span><br><span class="line">                    tmp = arr[i + 1];</span><br><span class="line">                    arr[i + 1] = arr[i];</span><br><span class="line">                    arr[i] = tmp;</span><br><span class="line">                    flag = true;//交换之后就置为true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //一次循环结束，flag如果还是false，证明上次循环未交换，则证明已经有序，提前退出</span><br><span class="line">            if (!flag) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //重置flag，否则flag变为true之后无法起到再次验证的效果</span><br><span class="line">                flag = false;</span><br><span class="line">            &#125;</span><br><span class="line">//            System.out.printf(&quot;第%d趟排序之后\n&quot;, (j + 1));</span><br><span class="line">//            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">//        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四：选择排序"><a href="#四：选择排序" class="headerlink" title="四：选择排序"></a>四：选择排序</h3><p>1：选择排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：第一次遍历(从arr[0]-arr[n-1])完成之后找到最小值，然后与arr[0]交换</span><br><span class="line">2：第二次遍历(从arr[1]-arr[n-1])完成之后找到这里面的最小值，然后与arr[1]交换</span><br><span class="line">...</span><br><span class="line">3：经过n-1次遍历，最终完成排序</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接选择排序  O(n2)    O(n2)O(n2)   O(1)   不稳定简单</span><br><span class="line">时间花费：80000数据最终花费时间约2s，</span><br><span class="line">时间较冒泡排序短：循环语句少，交换次数少</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class SelectSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        int[] arr = &#123;101, 34, 119, 1&#125;;</span><br><span class="line">//        selectSort(arr);</span><br><span class="line">//        System.out.println(Arrays.toString(arr));</span><br><span class="line">        //测试冒泡排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[80000];</span><br><span class="line">        for (int i = 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 8000000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        selectSort(arr);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot; + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //选择排序</span><br><span class="line">    public static void selectSort(int[] arr) &#123;</span><br><span class="line">        //逐步推到</span><br><span class="line">        //原始数组 101，34，119，1</span><br><span class="line">        //第一轮 1，34，119，101</span><br><span class="line">        int min = arr[0];</span><br><span class="line">        int minIndex = 0;</span><br><span class="line">        int temp = 0;//用于交换</span><br><span class="line">        for (int j = 0; j &lt; arr.length; j++) &#123;//外层循环表示第几轮循环</span><br><span class="line">            minIndex = j;//最小值的索引置为j，因为每次内层循环从J开始</span><br><span class="line">            min = arr[j];//最小值置为arr[j]，因为每次内层循环从J开始</span><br><span class="line">            for (int i = j + 1; i &lt; arr.length; i++) &#123;//内层表示当前轮循环的遍历</span><br><span class="line">                if (arr[i] &lt;= min) &#123;//满足条件</span><br><span class="line">                    min = arr[i];//</span><br><span class="line">                    minIndex = i;//记录最小值的索引</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //一次循环之后找到了最小值的所有minIndex,arr[0]交换</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[minIndex];</span><br><span class="line">            arr[minIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五：插入排序一：直接插入排序"><a href="#五：插入排序一：直接插入排序" class="headerlink" title="五：插入排序一：直接插入排序"></a>五：插入排序一：直接插入排序</h3><p>1：插入排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1：把n个待排序的元素看成一张有序表和一张无序表</span><br><span class="line">2：开始有序表中只包含一个元素，即arr[0]</span><br><span class="line">3:无序表中包含n-1个元素</span><br><span class="line">4：排序过程中，每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序码进行比较，将它插入到有序表的适当位置，使之成为新的有序表</span><br><span class="line">5：具体的比较过程</span><br><span class="line">例如：arr[3]为无序表的第一个元素，则将arr[3]与arr[2]进行比较，如果arr[2]&gt;arr[3]则将arr[2]后移一位；再将arr[3]与arr[1]比较，如果arr[3]&gt;arr[1]，则将arr[3]放在arr[2]的位置</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接插入排序  O(n2)O(n2)O(n)   O(1)稳定 简单</span><br><span class="line">时间花费：80000数据最终花费时间约1s，</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class InsertSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;   //测试冒泡排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[80000];</span><br><span class="line">        for (int i = 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 8000000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start =System.currentTimeMillis();</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        long end =System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot;+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //插入排序</span><br><span class="line">    public static void insertSort(int[] arr) &#123;</span><br><span class="line">        //逐步推导</span><br><span class="line">        //第一轮&#123;101，34，119，1&#125;=&gt;&#123;34,101,119,1&#125;</span><br><span class="line">        //定义待插入数</span><br><span class="line">        for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            //每次待插入的元素往后移</span><br><span class="line">            int insertVal = arr[i];</span><br><span class="line">            //需要一个变量记录待插入的元素，不能使用arr[i]来记录，因为值可能会改变</span><br><span class="line">            //每次循环就把待插入的元素索引n与前n个元素从后往前比较</span><br><span class="line">            for (int j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">                if (insertVal &lt;= arr[j]) &#123;</span><br><span class="line">                    //将arr[j]后移</span><br><span class="line">                    arr[j + 1] = arr[j];</span><br><span class="line">                    if (j == 0) &#123;</span><br><span class="line">                        arr[j] = insertVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (insertVal &gt; arr[j]) &#123;</span><br><span class="line">                    //代表可以插入！直接将insertVal放在arr[j]的后面，注意此时需要结束当前内层循环</span><br><span class="line">                    arr[j + 1] = insertVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六：插入排序二：希尔排序"><a href="#六：插入排序二：希尔排序" class="headerlink" title="六：插入排序二：希尔排序"></a>六：插入排序二：希尔排序</h3><p>1：希尔排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：设待排序元素序列有n个元素，首先取一个整数increment（n/2取整）作为间隔将全部元素分为increment个子序列，所有距离为increment的元素放在同一个子序列中，在每一个子序列中分别实行直接插入排序。然后缩小间隔increment（上述的然后缩小间隔increment/2），重复上述子序列划分和排序工作。直到最后取increment=1，将所有元素放在同一个子序列中排序为止。</span><br><span class="line">2：由于开始时，increment的取值较大，每个子序列中的元素较少，排序速度较快，到排序后期increment取值逐渐变小，子序列中元素个数逐渐增多，但由于前面工作的基础，大多数元素已经基本有序，所以排序速度仍然很快。</span><br><span class="line">3：困难点是：步长x与循环轮数k之间的关系并且和arr.length的关系，以及每次插入排序尽头的判断</span><br><span class="line">4：希尔排序的关键在于提前通过步长把N组数据已经变成有序了，最后当步长=1的时候才是最终的方式，也就是插入排序！</span><br><span class="line">5：可以把希尔排序方式理解成一种化繁为简的思想，具体内部用哪种排序方式自己定（例如冒泡：交换，或者插入）</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">希尔排序   O(nlog2n) O(n2) O(n)O(1)不稳定 较复杂</span><br><span class="line">测试80000条数据花费60ms左右</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import sun.rmi.runtime.Log;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class ShellSort &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        int[] arr = &#123;6, 2314, 314, 234134, 3145132, 8, 9, 1, 7, 2, 1273, 4, 5&#125;;</span><br><span class="line">//        System.out.println(&quot;原始数据是：&quot; + Arrays.toString(arr));</span><br><span class="line">//        shellSort(arr);</span><br><span class="line">//        System.out.println(Arrays.toString(arr));</span><br><span class="line">        //测试希尔排序时间复杂度，80000个数据，测试</span><br><span class="line">        int[] arr = new int[80000];</span><br><span class="line">        for (int i = 0; i &lt; 80000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 800000);//生成一个【0，8000000)数</span><br><span class="line">        &#125;</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        shellSort(arr);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;花费时间/（ms）：&quot; + (end - start));</span><br><span class="line">//        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用逐步推导</span><br><span class="line">    public static void shellSort(int[] arr) &#123;</span><br><span class="line">        //希尔排序的第一轮排序</span><br><span class="line">        //因为第一轮排序，是将10个数据分成了5组</span><br><span class="line">        //三层，第一层表示一共要进行多少轮的分组  9个数，</span><br><span class="line">        // 则第一轮分组为 1，5，9   2，6   3，7   4，8</span><br><span class="line">        //k为插入排序的轮数，</span><br><span class="line">        int kMax = (int) (Math.log(arr.length)/Math.log(2));//表示需要进行插入排序的轮数</span><br><span class="line">        //每轮的步长为1- arr.length/2   2-arr.length/2/2  3-arr.length/2/2/2</span><br><span class="line">        System.out.println(&quot;插入排序的轮数：&quot;+kMax);</span><br><span class="line">        for (int k = 1; k &lt;= kMax; k++) &#123;</span><br><span class="line">            int x = (int) (arr.length / Math.pow(2, k));//步长</span><br><span class="line">            System.out.printf(&quot;第%d轮的步长:%d\n&quot;,k,x);</span><br><span class="line">                for (int i = x; i &lt; arr.length; i++) &#123;//从步长x开始</span><br><span class="line">                    //每次待插入的元素往后移</span><br><span class="line">                    int insertVal = arr[i];</span><br><span class="line">                    //需要一个变量记录待插入的元素，不能使用arr[i]来记录，因为值可能会改变</span><br><span class="line">                    //每次循环就把待插入的元素索引n与前n/x个元素从后往前比较</span><br><span class="line">                    for (int j = i - x; j &gt;= i % x; j -= x) &#123;</span><br><span class="line">                        //每次只与前面步长差为x的比较，注意此时的左边尽头是i对步长取模</span><br><span class="line">                        if (insertVal &lt;= arr[j]) &#123;</span><br><span class="line">                            //将arr[j]后移</span><br><span class="line">                            arr[j + x] = arr[j];</span><br><span class="line">                            if (j == i % x) &#123;//判断已经到头了</span><br><span class="line">                                arr[j] = insertVal;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (insertVal &gt; arr[j]) &#123;</span><br><span class="line">//代表可以插入！直接将insertVal放在arr[j]的后面，注意此时需要结束当前内层循环</span><br><span class="line">                            arr[j + x] = insertVal;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">//                System.out.printf(&quot;第%d轮的步长是%d：&quot;, k, x);</span><br><span class="line">//                System.out.printf(&quot;第%d轮的排序是：&quot;, k);</span><br><span class="line">//                System.out.println(Arrays.toString(arr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="七：快速排序"><a href="#七：快速排序" class="headerlink" title="七：快速排序"></a>七：快速排序</h3><p>1：快速排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：通过一趟排序将要排序的数据分割成独立的两部分，基准值M=arr[(indexStart+indexEnd)/2]自己确定，其中一部分的所有数据都比另外一部分的所有数据小</span><br><span class="line">2：然后再按照此方法对这两部分数据分别进行快速排序</span><br><span class="line">3：整个排序过程可以递归进行，以此达到整个数据变成有序序列，递归的尽头是每个部分中只有一个元素</span><br><span class="line">4：具体的交换过程是一个方法（），左边索引indexStart向右移动，右边所有indexEnd向左移动；当arr[indexStart]&gt;M(基准值)&amp;&amp;arr[indexEnd]&lt;M时，进行交换；这样左边的所有元素就小于了基准值，右边的所有元素大于基准值,方法的参参数是数组，左索引值，右索引值</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class QuickSort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//int[] arr = &#123;-9,78,0,23,-567,70, -1,900, 4561&#125;;</span><br><span class="line"></span><br><span class="line">//测试快排的执行速度</span><br><span class="line">// 创建要给80000个的随机的数组</span><br><span class="line">int[] arr = new int[8000000];</span><br><span class="line">for (int i = 0; i &lt; 8000000; i++) &#123;</span><br><span class="line">arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;排序前&quot;);</span><br><span class="line">Date data1 = new Date();</span><br><span class="line">SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">System.out.println(&quot;排序前的时间是=&quot; + date1Str);</span><br><span class="line"></span><br><span class="line">quickSort(arr, 0, arr.length-1);</span><br><span class="line"></span><br><span class="line">Date data2 = new Date();</span><br><span class="line">String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">System.out.println(&quot;排序前的时间是=&quot; + date2Str);</span><br><span class="line">//System.out.println(&quot;arr=&quot; + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void quickSort(int[] arr,int left, int right) &#123;</span><br><span class="line">int l = left; //左下标</span><br><span class="line">int r = right; //右下标</span><br><span class="line">//pivot 中轴值</span><br><span class="line">int pivot = arr[(left + right) / 2];</span><br><span class="line">int temp = 0; //临时变量，作为交换时使用</span><br><span class="line">//while循环的目的是让比pivot 值小放到左边</span><br><span class="line">//比pivot 值大放到右边</span><br><span class="line">while( l &lt; r) &#123;</span><br><span class="line">//在pivot的左边一直找,找到大于等于pivot值,才退出</span><br><span class="line">while( arr[l] &lt; pivot) &#123;</span><br><span class="line">l += 1;</span><br><span class="line">&#125;</span><br><span class="line">//在pivot的右边一直找,找到小于等于pivot值,才退出</span><br><span class="line">while(arr[r] &gt; pivot) &#123;</span><br><span class="line">r -= 1;</span><br><span class="line">&#125;</span><br><span class="line">//如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是</span><br><span class="line">//小于等于pivot值，右边全部是大于等于pivot值</span><br><span class="line">if( l &gt;= r) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//交换</span><br><span class="line">temp = arr[l];</span><br><span class="line">arr[l] = arr[r];</span><br><span class="line">arr[r] = temp;</span><br><span class="line"></span><br><span class="line">//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移</span><br><span class="line">if(arr[l] == pivot) &#123;</span><br><span class="line">r -= 1;</span><br><span class="line">&#125;</span><br><span class="line">//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移</span><br><span class="line">if(arr[r] == pivot) &#123;</span><br><span class="line">l += 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span><br><span class="line">if (l == r) &#123;</span><br><span class="line">l += 1;</span><br><span class="line">r -= 1;</span><br><span class="line">&#125;</span><br><span class="line">//向左递归</span><br><span class="line">if(left &lt; r) &#123;</span><br><span class="line">quickSort(arr, left, r);</span><br><span class="line">&#125;</span><br><span class="line">//向右递归</span><br><span class="line">if(right &gt; l) &#123;</span><br><span class="line">quickSort(arr, l, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八：基数排序：桶排序"><a href="#八：基数排序：桶排序" class="headerlink" title="八：基数排序：桶排序"></a>八：基数排序：桶排序</h3><p>1：基数排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基数排序第i趟将待排数组里的每个数的i位数放到tempj（j=1-10）队列中，然后再从这十个队列中取出数据，重新放到原数组里，直到i大于待排数的最大位数。</span><br><span class="line">1.数组里的数最大位数是n位，就需要排n趟，例如数组里最大的数是3位数，则需要排3趟。</span><br><span class="line">2.若数组里共有m个数，则需要十个长度为m的数组tempj（j=0-9）用来暂存i位上数为j的数，例如，第1趟，各位数为0的会被分配到temp0数组里，各位数为1的会被分配到temp1数组里......</span><br><span class="line">3.分配结束后，再依次从tempj数组中取出数据，遵循先进先进原则，例如对数组&#123;1，11，2，44，4&#125;，进行第1趟分配后，temp1=&#123;1,11&#125;，temp2=&#123;2&#125;，temp4=&#123;44，4&#125;，依次取出元素后&#123;1，11，2，44，4&#125;，第一趟结束</span><br><span class="line">4.循环到n趟后结束，排序完成</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基数排序   O(d(n+r))    O(d(n+r))     O(d(n+r))      O(n+r)   稳定  较复杂</span><br><span class="line">80000数据耗时：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class RadixSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int arr[] = &#123; 53, 3, 542, 748, 14, 214&#125;;</span><br><span class="line"></span><br><span class="line">        // 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G </span><br><span class="line">//int[] arr = new int[8000000];</span><br><span class="line">//for (int i = 0; i &lt; 8000000; i++) &#123;</span><br><span class="line">//arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span><br><span class="line">//&#125;</span><br><span class="line">        System.out.println(&quot;排序前&quot;);</span><br><span class="line">        Date data1 = new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">        System.out.println(&quot;排序前的时间是=&quot; + date1Str);</span><br><span class="line"></span><br><span class="line">        radixSort(arr);</span><br><span class="line"></span><br><span class="line">        Date data2 = new Date();</span><br><span class="line">        String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">        System.out.println(&quot;排序前的时间是=&quot; + date2Str);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;基数排序后 &quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //基数排序方法</span><br><span class="line">    public static void radixSort(int[] arr) &#123;</span><br><span class="line"></span><br><span class="line">        //根据前面的推导过程，我们可以得到最终的基数排序代码</span><br><span class="line"></span><br><span class="line">        //1. 得到数组中最大的数的位数</span><br><span class="line">        int max = arr[0]; //假设第一数就是最大数</span><br><span class="line">        for(int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">            if (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //得到最大数是几位数</span><br><span class="line">        int maxLength = (max + &quot;&quot;).length();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span><br><span class="line">        //说明</span><br><span class="line">        //1. 二维数组包含10个一维数组</span><br><span class="line">        //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span><br><span class="line">        //3. 名明确，基数排序是使用空间换时间的经典算法</span><br><span class="line">        int[][] bucket = new int[10][arr.length];</span><br><span class="line"></span><br><span class="line">        //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span><br><span class="line">        //可以这里理解</span><br><span class="line">        //比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span><br><span class="line">        int[] bucketElementCounts = new int[10];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //这里我们使用循环将代码处理</span><br><span class="line"></span><br><span class="line">        for(int i = 0 , n = 1; i &lt; maxLength; i++, n *= 10) &#123;</span><br><span class="line">            //(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span><br><span class="line">            for(int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">                //取出每个元素的对应位的值</span><br><span class="line">                int digitOfElement = arr[j] / n % 10;</span><br><span class="line">                //放入到对应的桶中</span><br><span class="line">                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">                bucketElementCounts[digitOfElement]++;</span><br><span class="line">            &#125;</span><br><span class="line">            //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">            int index = 0;</span><br><span class="line">            //遍历每一桶，并将桶中是数据，放入到原数组</span><br><span class="line">            for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">                //如果桶中，有数据，我们才放入到原数组</span><br><span class="line">                if(bucketElementCounts[k] != 0) &#123;</span><br><span class="line">                    //循环该桶即第k个桶(即第k个一维数组), 放入</span><br><span class="line">                    for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                        //取出元素放入到arr</span><br><span class="line">                        arr[index++] = bucket[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span><br><span class="line">                bucketElementCounts[k] = 0;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            //System.out.println(&quot;第&quot;+(i+1)+&quot;轮，对个位的排序处理 arr =&quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">//第1轮(针对每个元素的个位进行排序处理)</span><br><span class="line">for(int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">//取出每个元素的个位的值</span><br><span class="line">int digitOfElement = arr[j] / 1 % 10;</span><br><span class="line">//放入到对应的桶中</span><br><span class="line">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">bucketElementCounts[digitOfElement]++;</span><br><span class="line">&#125;</span><br><span class="line">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">int index = 0;</span><br><span class="line">//遍历每一桶，并将桶中是数据，放入到原数组</span><br><span class="line">for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">//如果桶中，有数据，我们才放入到原数组</span><br><span class="line">if(bucketElementCounts[k] != 0) &#123;</span><br><span class="line">//循环该桶即第k个桶(即第k个一维数组), 放入</span><br><span class="line">for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">//取出元素放入到arr</span><br><span class="line">arr[index++] = bucket[k][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//第l轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span><br><span class="line">bucketElementCounts[k] = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;第1轮，对个位的排序处理 arr =&quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//==========================================</span><br><span class="line"></span><br><span class="line">//第2轮(针对每个元素的十位进行排序处理)</span><br><span class="line">for (int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">// 取出每个元素的十位的值</span><br><span class="line">int digitOfElement = arr[j] / 10  % 10; //748 / 10 =&gt; 74 % 10 =&gt; 4</span><br><span class="line">// 放入到对应的桶中</span><br><span class="line">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">bucketElementCounts[digitOfElement]++;</span><br><span class="line">&#125;</span><br><span class="line">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">index = 0;</span><br><span class="line">// 遍历每一桶，并将桶中是数据，放入到原数组</span><br><span class="line">for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">// 如果桶中，有数据，我们才放入到原数组</span><br><span class="line">if (bucketElementCounts[k] != 0) &#123;</span><br><span class="line">// 循环该桶即第k个桶(即第k个一维数组), 放入</span><br><span class="line">for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">// 取出元素放入到arr</span><br><span class="line">arr[index++] = bucket[k][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//第2轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span><br><span class="line">bucketElementCounts[k] = 0;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;第2轮，对个位的排序处理 arr =&quot; + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第3轮(针对每个元素的百位进行排序处理)</span><br><span class="line">for (int j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">// 取出每个元素的百位的值</span><br><span class="line">int digitOfElement = arr[j] / 100 % 10; // 748 / 100 =&gt; 7 % 10 = 7</span><br><span class="line">// 放入到对应的桶中</span><br><span class="line">bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">bucketElementCounts[digitOfElement]++;</span><br><span class="line">&#125;</span><br><span class="line">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span><br><span class="line">index = 0;</span><br><span class="line">// 遍历每一桶，并将桶中是数据，放入到原数组</span><br><span class="line">for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">// 如果桶中，有数据，我们才放入到原数组</span><br><span class="line">if (bucketElementCounts[k] != 0) &#123;</span><br><span class="line">// 循环该桶即第k个桶(即第k个一维数组), 放入</span><br><span class="line">for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">// 取出元素放入到arr</span><br><span class="line">arr[index++] = bucket[k][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//第3轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span><br><span class="line">bucketElementCounts[k] = 0;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;第3轮，对个位的排序处理 arr =&quot; + Arrays.toString(arr)); */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九：归并排序"><a href="#九：归并排序" class="headerlink" title="九：归并排序"></a>九：归并排序</h3><p>1：归并排序思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2</span><br><span class="line">求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1</span><br><span class="line">合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">package com.it.sort;</span><br><span class="line"></span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class MergetSort &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //int arr[] = &#123; 8, 4, 5, 7, 1, 3, 6, 2 &#125;; //</span><br><span class="line"></span><br><span class="line">        //测试快排的执行速度</span><br><span class="line">        // 创建要给80000个的随机的数组</span><br><span class="line">        int[] arr = new int[8000000];</span><br><span class="line">        for (int i = 0; i &lt; 8000000; i++) &#123;</span><br><span class="line">            arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;排序前&quot;);</span><br><span class="line">        Date data1 = new Date();</span><br><span class="line">        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">        String date1Str = simpleDateFormat.format(data1);</span><br><span class="line">        System.out.println(&quot;排序前的时间是=&quot; + date1Str);</span><br><span class="line"></span><br><span class="line">        int temp[] = new int[arr.length]; //归并排序需要一个额外空间</span><br><span class="line">        mergeSort(arr, 0, arr.length - 1, temp);</span><br><span class="line"></span><br><span class="line">        Date data2 = new Date();</span><br><span class="line">        String date2Str = simpleDateFormat.format(data2);</span><br><span class="line">        System.out.println(&quot;排序前的时间是=&quot; + date2Str);</span><br><span class="line"></span><br><span class="line">        //System.out.println(&quot;归并排序后=&quot; + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //分+合方法</span><br><span class="line">    public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123;</span><br><span class="line">        if(left &lt; right) &#123;</span><br><span class="line">            int mid = (left + right) / 2; //中间索引</span><br><span class="line">            //向左递归进行分解</span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            //向右递归进行分解</span><br><span class="line">            mergeSort(arr, mid + 1, right, temp);</span><br><span class="line">            //合并</span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //合并的方法</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param arr 排序的原始数组</span><br><span class="line">     * @param left 左边有序序列的初始索引</span><br><span class="line">     * @param mid 中间索引</span><br><span class="line">     * @param right 右边索引</span><br><span class="line">     * @param temp 做中转的数组</span><br><span class="line">     */</span><br><span class="line">    public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123;</span><br><span class="line"></span><br><span class="line">        int i = left; // 初始化i, 左边有序序列的初始索引</span><br><span class="line">        int j = mid + 1; //初始化j, 右边有序序列的初始索引</span><br><span class="line">        int t = 0; // 指向temp数组的当前索引</span><br><span class="line"></span><br><span class="line">        //(一)</span><br><span class="line">        //先把左右两边(有序)的数据按照规则填充到temp数组</span><br><span class="line">        //直到左右两边的有序序列，有一边处理完毕为止</span><br><span class="line">        while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;//继续</span><br><span class="line">            //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span><br><span class="line">            //即将左边的当前元素，填充到 temp数组</span><br><span class="line">            //然后 t++, i++</span><br><span class="line">            if(arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t += 1;</span><br><span class="line">                i += 1;</span><br><span class="line">            &#125; else &#123; //反之,将右边有序序列的当前元素，填充到temp数组</span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t += 1;</span><br><span class="line">                j += 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //(二)</span><br><span class="line">        //把有剩余数据的一边的数据依次全部填充到temp</span><br><span class="line">        while( i &lt;= mid) &#123; //左边的有序序列还有剩余的元素，就全部填充到temp</span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += 1;</span><br><span class="line">            i += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while( j &lt;= right) &#123; //右边的有序序列还有剩余的元素，就全部填充到temp</span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += 1;</span><br><span class="line">            j += 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //(三)</span><br><span class="line">        //将temp数组的元素拷贝到arr</span><br><span class="line">        //注意，并不是每次都拷贝所有</span><br><span class="line">        t = 0;</span><br><span class="line">        int tempLeft = left; //</span><br><span class="line">        //第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3</span><br><span class="line">        //最后一次 tempLeft = 0  right = 7</span><br><span class="line">        while(tempLeft &lt;= right) &#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            t += 1;</span><br><span class="line">            tempLeft += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：排序&quot;&gt;&lt;a href=&quot;#一：排序&quot; class=&quot;headerlink&quot; title=&quot;一：排序&quot;&gt;&lt;/a&gt;一：排序&lt;/h1&gt;&lt;h3 id=&quot;1：排序的分类&quot;&gt;&lt;a href=&quot;#1：排序的分类&quot; class=&quot;headerlink&quot; title=&quot;1：排
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法（3）递归</title>
    <link href="https://yanyubing.xyz/2018/06/05/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E9%80%92%E5%BD%92/"/>
    <id>https://yanyubing.xyz/2018/06/05/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E9%80%92%E5%BD%92/</id>
    <published>2018-06-05T13:46:12.000Z</published>
    <updated>2019-12-06T01:20:43.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：递归"><a href="#一：递归" class="headerlink" title="一：递归"></a>一：递归</h1><h3 id="1：递归介绍"><a href="#1：递归介绍" class="headerlink" title="1：递归介绍"></a>1：递归介绍</h3><p>1：递归的应用场景，迷宫问题（回溯），递归</p><p>2：概念，递归就是自己调用自己，每次传入一个不一样的参数</p><p>3：递归可以解决的问题：8皇后，汉若塔，阶乘问题，迷宫问题，球和篮子</p><p>4：各种算法，快排，归并，二分查找，分治算法等</p><p>5：将用栈解决的问题使用递归解决</p><p>6：递归使用遵守规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：执行一个方法时，就春季了一个新的受保护的独立空间（栈空间）</span><br><span class="line">2：方法的局部变量是独立的，不会相互影响</span><br><span class="line">3：如果方法中使用的是引用类型的变量，例如迷宫问题是的数组，就会共享该类型的数据</span><br><span class="line">4：递归必须向退出递归的条件逼近，否则就是无线递归，栈溢出stackOverflowError</span><br><span class="line">5：当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用就把结果返回给谁；同时当方法执行完毕或者返回时，该方法也就执行完毕</span><br></pre></td></tr></table></figure><h3 id="2：递归-迷宫问题"><a href="#2：递归-迷宫问题" class="headerlink" title="2：递归-迷宫问题"></a>2：递归-迷宫问题</h3><p>1：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">package com.it.rescursion;</span><br><span class="line"></span><br><span class="line">public class MiGong &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //二维数组创建一个迷宫</span><br><span class="line">        int[][] map = new int[8][7];</span><br><span class="line">        //使用1表示墙</span><br><span class="line">        // 上下全置为1</span><br><span class="line">        for (int i = 0; i &lt; 7; i++) &#123;</span><br><span class="line">            map[0][i] = 1;</span><br><span class="line">            map[7][i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        //左右置为1</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            map[i][0] = 1;</span><br><span class="line">            map[i][6] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        //设置相应挡板，1</span><br><span class="line">        map[3][1] = 1;</span><br><span class="line">        map[3][2] = 1;</span><br><span class="line">        //输出地图</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 7; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;迷宫问题&quot;);</span><br><span class="line">        //使用递归回溯给小球找路</span><br><span class="line">        setWay(map, 1, 1);</span><br><span class="line">        //使用新的地图，小球走过，并表示过得地图</span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 7; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*说明：</span><br><span class="line">        map表示地图，i，j 表示从地图哪个位置开始出发（1,1）</span><br><span class="line">     *如果小球能到map[6][5]位置，则说明通路找到</span><br><span class="line">     约定：当map[i][j]为</span><br><span class="line">     0表示没有走过</span><br><span class="line">     1表示墙，</span><br><span class="line">     2表示通路，可以走</span><br><span class="line">     3表示该位置已经走过，但是走不通。</span><br><span class="line">     在走迷宫时先确定一个策略（方法）下→右→上→左；如果该路走不通则回溯</span><br><span class="line">     * */</span><br><span class="line">    //使用递归回溯来给小球找路</span><br><span class="line">    public static boolean setWay(int[][] map, int i, int j) &#123;</span><br><span class="line">        if (map[6][5] == 2) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (map[i][j] == 0) &#123;</span><br><span class="line">                //按照策略开始走   下→右→上→左</span><br><span class="line">                map[i][j] = 2;//假定可以走通</span><br><span class="line">                if (setWay(map, i + 1, j)) &#123;//向下走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (setWay(map, i, j + 1)) &#123;//向右走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (setWay(map, i - 1, j)) &#123;//向上走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (setWay(map, i, j - 1)) &#123;//向左走</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //都走不通，说明是死路</span><br><span class="line">                    map[i][j] = 3;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果map[i][j]!=0;可能是1,2,3</span><br><span class="line">            else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3：递归-八皇后问题"><a href="#3：递归-八皇后问题" class="headerlink" title="3：递归-八皇后问题"></a>3：递归-八皇后问题</h3><p>1：思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1：第一个皇后放在第一行第一列</span><br><span class="line">2：第二个皇后放在第二行第一列，然后判断是否ok,如果不Ok,继续放在第二列、第三列...依次把所有列放完，找到一个合适的</span><br><span class="line">3：继续第三个皇后，还是第一列，第二列...直到第8个皇后也能放在一个不冲突的位置，算是找到一个正确解</span><br><span class="line">4：当得到一个正确时，在栈回退到上一个栈，就会开始回溯，即将第一个皇后放在第一列的所有正确解全部都得到</span><br><span class="line">5：然后回头继续第一个皇后放在第二列，后面继续执行1,2,3,4的步骤</span><br><span class="line">说明：理论上需要二维数组，但是实际上可以用一位数组的索引（index+1）表示第几行</span><br><span class="line">6：合计92种</span><br></pre></td></tr></table></figure><p>2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package com.it.rescursion;</span><br><span class="line"></span><br><span class="line">public class Queue8 &#123;</span><br><span class="line">    //先定义一个max表示共有多少个皇后</span><br><span class="line">    int max = 8;</span><br><span class="line">    //定义一个数组，保存皇后防止位置的结果，比如arr=&#123;0,4,7,5,2,6,1,3&#125;</span><br><span class="line">    int array[] = new int[max];</span><br><span class="line">    static int count = 0;</span><br><span class="line">    static int judgeCount = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试</span><br><span class="line">        Queue8 queue8 = new Queue8();</span><br><span class="line">        queue8.check(0);</span><br><span class="line">        System.out.printf(&quot;一共有%d解法&quot;, count);</span><br><span class="line">        System.out.printf(&quot;一共判断冲突的次数%d次&quot;, judgeCount); // 1.5w</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //编写一个方法，放置第n个皇后</span><br><span class="line">    private void check(int n) &#123;</span><br><span class="line">        //n=8代表已经放完了8个皇后</span><br><span class="line">        if (n == max) &#123;</span><br><span class="line">            print();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //依次测试第n个皇后的放入，并判断是否冲突</span><br><span class="line">        for (int i = 0; i &lt; max; i++) &#123;</span><br><span class="line">            //i=0时，表示放置在第一列，i=1表示放置在第二列...</span><br><span class="line">            array[n] = i;</span><br><span class="line">            //判断当放置第N个皇后到i列时是否冲突；</span><br><span class="line">            if (judge(n)) &#123;</span><br><span class="line">                //接着放n+1个皇后</span><br><span class="line">                check(n + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            //如果冲突，则继续执行循环，放置在i+1列</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查看当我们放置第N个皇后时，就去检查该皇后是否和前面已经放置的皇后冲突</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param n 表示第N个皇后</span><br><span class="line">     */</span><br><span class="line">    private boolean judge(int n) &#123;</span><br><span class="line">        judgeCount++;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            //array[i] == array[n]这里表示是不是在同一列</span><br><span class="line">            // Math.abs(n - 1) == Math.abs(array[n] - array[i])表示第n个皇后是不是和第i个皇后在45°线上</span><br><span class="line">            if (array[i] == array[n] || Math.abs(n -i ) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">                return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //写一个方法可以将皇后摆放的位置输出</span><br><span class="line">        private void print () &#123;</span><br><span class="line">            count++;</span><br><span class="line">            for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">                System.out.print(array[i] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：递归&quot;&gt;&lt;a href=&quot;#一：递归&quot; class=&quot;headerlink&quot; title=&quot;一：递归&quot;&gt;&lt;/a&gt;一：递归&lt;/h1&gt;&lt;h3 id=&quot;1：递归介绍&quot;&gt;&lt;a href=&quot;#1：递归介绍&quot; class=&quot;headerlink&quot; title=&quot;1：递归介
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法(2)栈</title>
    <link href="https://yanyubing.xyz/2018/06/02/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(2)%E6%A0%88/"/>
    <id>https://yanyubing.xyz/2018/06/02/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95(2)%E6%A0%88/</id>
    <published>2018-06-02T12:46:12.000Z</published>
    <updated>2019-12-01T15:07:43.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：栈"><a href="#一：栈" class="headerlink" title="一：栈"></a>一：栈</h1><h3 id="1：栈的应用场景"><a href="#1：栈的应用场景" class="headerlink" title="1：栈的应用场景"></a>1：栈的应用场景</h3><p>1：子程序的调用</p><p>2：处理递归调用</p><p>3：表达式的转换</p><p>4：二叉树的遍历</p><p>5：图形的深度优先搜索法</p><h3 id="2：用数组模拟栈，代码实现出栈与入栈思路"><a href="#2：用数组模拟栈，代码实现出栈与入栈思路" class="headerlink" title="2：用数组模拟栈，代码实现出栈与入栈思路"></a>2：用数组模拟栈，代码实现出栈与入栈思路</h3><p>1：需要栈的大小</p><p>2：需要定义栈顶top,初始化为-1</p><p>3：入栈，当有数据加入栈pop()，top++，加入数据</p><p>4：出栈，当有数据取出时push()，top–，取出数据</p><p>5：注意：出栈之后数组的元素并没有改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">package com.it.stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayStackDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试ArrayStack</span><br><span class="line">        ArrayStack stack = new ArrayStack(4);</span><br><span class="line">        String key = &quot;&quot;;//控制输入字符</span><br><span class="line">        boolean loop = true;//控制退出菜单</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            System.out.println(&quot;----------------&quot;);</span><br><span class="line">            System.out.println(&quot;show:表示显示栈&quot;);</span><br><span class="line">            System.out.println(&quot;exit:退出程序&quot;);</span><br><span class="line">            System.out.println(&quot;push:表示添加数据到栈&quot;);</span><br><span class="line">            System.out.println(&quot;pop:表示从栈取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;请输入你的选择&quot;);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &quot;show&quot;:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;push&quot;:</span><br><span class="line">                    System.out.println(&quot;请输入要加入的数&quot;);</span><br><span class="line">                    int value = scanner.nextInt();</span><br><span class="line">                    stack.push(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;pop&quot;:</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int pop = stack.pop();</span><br><span class="line">                        System.out.printf(&quot;出栈的数据是%d\n&quot;, pop);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;exit&quot;:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个类表示栈结构</span><br><span class="line">class ArrayStack &#123;</span><br><span class="line">    private int mazSize;//栈的最大大小</span><br><span class="line">    private int[] stack;//数组模拟战，数据放在该数组中</span><br><span class="line">    private int top = -1;//初始化栈顶为-1</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public ArrayStack(int mazSize) &#123;</span><br><span class="line">        this.mazSize = mazSize;</span><br><span class="line">        //初始化数组</span><br><span class="line">        stack = new int[this.mazSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈空</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return top == mazSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return top == -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public void push(int value) &#123;</span><br><span class="line">        //先判断是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;栈满&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;栈空，没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历栈,需要从栈顶开始显示数据</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;栈空，没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = top; i &gt;= 0; i--) &#123;</span><br><span class="line">            System.out.printf(&quot;stack[%d]=%d\n&quot;, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3：栈实现综合计算器：中缀表达式"><a href="#3：栈实现综合计算器：中缀表达式" class="headerlink" title="3：栈实现综合计算器：中缀表达式"></a>3：栈实现综合计算器：中缀表达式</h3><p>1：创建一个数栈numStack，存放数</p><p>2：创建一个符号栈operStack，存放运算符</p><p>3：通过index值（索引），遍历我们的表达式</p><p>4：如果我们发现的是一个数字，就直接放入数栈</p><p>5：如果扫描的是一个符号</p><p>​    1：如果发现目前的符号栈为空，就直接入栈</p><p>​    2：如果符号栈有操作符，就进行比较。如果当前的操作符优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数再从符号栈中pop出一个符号，进行运算，将得到的结构再入数栈，然后再把当前符号入符号栈；如果当前的操作符优先级大于栈中的操作符，就直接入符号栈。</p><p>6：当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并进行运算，最后在数栈中只有一个数字，就是表达式的结果</p><p>7：注意：栈的判断条件，如操作符栈最多只能有两个字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">package com.it.stack;</span><br><span class="line"></span><br><span class="line">import javax.jws.soap.SOAPMessageHandlers;</span><br><span class="line"></span><br><span class="line">public class Calculator &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //表达式</span><br><span class="line">        String expression = &quot;5+9+297-1&quot;;</span><br><span class="line">        //创建两个栈,这里大小设置为10，实际上应该只能用到2-3左右</span><br><span class="line">        ArrayStack2 numStack = new ArrayStack2(10);</span><br><span class="line">        ArrayStack2 operStack = new ArrayStack2(10);</span><br><span class="line">        //定义相关变量</span><br><span class="line">        int index = 0;//用于扫描</span><br><span class="line">        int num1 = 0;</span><br><span class="line">        int num2 = 0;</span><br><span class="line">        int oper = 0;</span><br><span class="line">        int res = 0;</span><br><span class="line">        char ch = &apos; &apos;;//将每次扫描的char保存到ch</span><br><span class="line">        String keepNum = &quot;&quot;;//用于拼接多位数</span><br><span class="line">        //        开始while循环扫描expression</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //依次得到expression的每一个字符</span><br><span class="line">            ch = expression.substring(index, index + 1).charAt(0);</span><br><span class="line">            //判断ch，不同处理</span><br><span class="line">            //如果是符号</span><br><span class="line">            if (operStack.isOper(ch)) &#123;</span><br><span class="line">                if (!operStack.isEmpty()) &#123;</span><br><span class="line">                    //满足该条件时运算</span><br><span class="line">                    if (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        res = numStack.cal(num1, num2, oper);</span><br><span class="line">                        //把运算结果入数栈</span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        //然后将当前的操作符入符号栈</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //如果为空，直接入符号栈</span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果是数，则直接入栈，注意此时传入的是字符‘1’；需要对照ascii表转换为数字1， -48</span><br><span class="line">            //注意这里有问题，不能处理多位数</span><br><span class="line">            //需要进行拼接</span><br><span class="line">            else &#123;</span><br><span class="line">                //处理多位数</span><br><span class="line">                keepNum += ch;</span><br><span class="line">                //如果ch已经是expression最后一位，直接入栈</span><br><span class="line">                if (index == expression.length() - 1) &#123;</span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                &#125; else &#123;//判断下一个字符是不是数字，如果是数字，则继续扫描，如果是字符，则入栈</span><br><span class="line">                    if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) &#123;</span><br><span class="line">                        //如果后一位是操作符，则入栈，keepNum=&quot;123&quot;，转为数字</span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        //重要，情况keepNum</span><br><span class="line">                        keepNum = &quot;&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //让index+1，并判断是否扫描到expression最后</span><br><span class="line">            index++;</span><br><span class="line">            if (index == expression.length()) &#123;</span><br><span class="line">                //扫描结束</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //开始计算后面的情况</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //如果符号栈为空，则计算到最后的结果，数栈中只有一个数字【结果】</span><br><span class="line">            if (operStack.isEmpty()) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            res = numStack.cal(num1, num2, oper);</span><br><span class="line">            //把运算结果入数栈</span><br><span class="line">            numStack.push(res);</span><br><span class="line">        &#125;</span><br><span class="line">        //将最后的数，pop出就是结果</span><br><span class="line">        int res2 = numStack.pop();</span><br><span class="line">        System.out.printf(&quot;表达式%s=%d&quot;, expression, res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个类表示栈结构</span><br><span class="line">class ArrayStack2 &#123;</span><br><span class="line">    private int mazSize;//栈的最大大小</span><br><span class="line">    private int[] stack;//数组模拟战，数据放在该数组中</span><br><span class="line">    private int top = -1;//初始化栈顶为-1</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public ArrayStack2(int mazSize) &#123;</span><br><span class="line">        this.mazSize = mazSize;</span><br><span class="line">        //初始化数组</span><br><span class="line">        stack = new int[this.mazSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈空</span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        return top == mazSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //栈空</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return top == -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //入栈</span><br><span class="line">    public void push(int value) &#123;</span><br><span class="line">        //先判断是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;栈满&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //出栈</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;栈空，没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历栈,需要从栈顶开始显示数据</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;栈空，没有数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = top; i &gt;= 0; i--) &#123;</span><br><span class="line">            System.out.printf(&quot;stack[%d]=%d\n&quot;, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回运算符的优先级，优先级使用数字表示，数字越大则优先级越高</span><br><span class="line">    public int priority(int oper) &#123;</span><br><span class="line">        if (oper == &apos;*&apos; || oper == &apos;/&apos;) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (oper == &apos;+&apos; || oper == &apos;-&apos;) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1;//假定目前的表达式只有+，-，*，/</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是不是一个运算符</span><br><span class="line">    public boolean isOper(char val) &#123;</span><br><span class="line">        return val == &apos;+&apos; || val == &apos;-&apos; || val == &apos;*&apos; || val == &apos;/&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算方法</span><br><span class="line">    public int cal(int num1, int num2, int oper) &#123;</span><br><span class="line">        int res = 0;//用于存放计算的结果</span><br><span class="line">        switch (oper) &#123;</span><br><span class="line">            case &apos;+&apos;:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                break;</span><br><span class="line">            case &apos;-&apos;:</span><br><span class="line">                res = num2 - num1;//注意顺序</span><br><span class="line">                break;</span><br><span class="line">            case &apos;*&apos;:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                break;</span><br><span class="line">            case &apos;/&apos;:</span><br><span class="line">                res = num2 / num1;//注意顺序</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //增加返回栈顶值的方法</span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        return stack[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4：波兰表达式：前缀表达式"><a href="#4：波兰表达式：前缀表达式" class="headerlink" title="4：波兰表达式：前缀表达式"></a>4：波兰表达式：前缀表达式</h3><p>1：举例：     - * + 3 4 5 8</p><p>2：计算步骤，从右至左扫描，将8 5 4 3 压入栈</p><p>3：遇到+运算符，因此弹出3 和 4 进行运算，计算出3+4的值7，然后入栈</p><p>4：遇到*运算符，弹出7和5 计算得出得出7X5=35，将35入栈</p><p>5：最后-运算符，计算出35-8的值，即27，由此得到最终结果</p><h3 id="5：逆波兰表达式：后缀表达式"><a href="#5：逆波兰表达式：后缀表达式" class="headerlink" title="5：逆波兰表达式：后缀表达式"></a>5：逆波兰表达式：后缀表达式</h3><p>1：举例：    3 4 + 5 * 6 -</p><p>2：计算步骤，从左至右扫描，将3和4压入栈</p><p>3：遇到+运算符，因此弹出4和3 ，计算出3+4的值，得7，将7入栈</p><p>5：将5入栈</p><p>6：接下来是X运算符，因此弹出5和7，计算出7*5=35，将35入栈</p><p>7：将6入栈</p><p>8：弹出6（栈顶）和35（栈顶下一个元素），计算35-6，即29</p><p>9：逆波兰表达式计算器的代码实现</p><p>​    1：需要输入一个逆波兰表达式</p><p>​    2：使用系统提供的栈(stack)</p><p>​    3：支持小括号和多位整数</p><p>​    4：思路如上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.it.stack;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class PolandNotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //定义一个逆波兰表达式</span><br><span class="line">        //(3+4)*5-6 =&gt; 3 4 + 5 * 6 -</span><br><span class="line">        //为了方便，逆波兰表达式的数字和符号用空格隔开</span><br><span class="line">        String suffixExpression = &quot;30 4 + 5 * 6 -&quot;;</span><br><span class="line">        //思路</span><br><span class="line">        //1：先将&quot;3 4 + 5 * 6 -&quot;放入ArrayList中，这里是为了方便根据索引扫描</span><br><span class="line">        //2：将ArrayList传递给一个方法，遍历ArrayList，配合栈，完成计算</span><br><span class="line">        List&lt;String&gt; list = getListString(suffixExpression);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        int res = calculate(list);</span><br><span class="line">        System.out.println(&quot;计算的结果是=&quot; + res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;String&gt; getListString(String suffixExpression) &#123;</span><br><span class="line">        String[] split = suffixExpression.split(&quot; &quot;);</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        for (String s : split) &#123;</span><br><span class="line">            //遍历添加元素到集合</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //运算</span><br><span class="line">    public static int calculate(List&lt;String&gt; ls) &#123;</span><br><span class="line">        //创建栈</span><br><span class="line">        Stack&lt;String&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (String item : ls) &#123;</span><br><span class="line">            //使用正则表达式取出数,匹配的是多位数</span><br><span class="line">            if (item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">                //入栈</span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int pop2 = Integer.parseInt(stack.pop());</span><br><span class="line">                int pop1 = Integer.parseInt(stack.pop());</span><br><span class="line">                int res = 0;</span><br><span class="line">                if (item.equals(&quot;+&quot;)) &#123;</span><br><span class="line">                    res = pop1 + pop2;</span><br><span class="line">                &#125; else if (item.equals(&quot;-&quot;)) &#123;</span><br><span class="line">                    res = pop1 - pop2;//先弹出的是pop2</span><br><span class="line">                &#125; else if (item.equals(&quot;*&quot;)) &#123;</span><br><span class="line">                    res = pop1 * pop2;</span><br><span class="line">                &#125; else if (item.equals(&quot;/&quot;)) &#123;</span><br><span class="line">                    res = pop1 / pop2;//先弹出的是pop2</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;运算符有误！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(&quot;&quot; + res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最后留在栈中的就是运算结果</span><br><span class="line">        return Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六：中缀表达式转换为后缀表达式"><a href="#六：中缀表达式转换为后缀表达式" class="headerlink" title="六：中缀表达式转换为后缀表达式"></a>六：中缀表达式转换为后缀表达式</h3><p>1：中缀表达式适合人的理解</p><p>2：后缀表达式适合计算机的运行</p><p>3：思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.初始化两个栈：运算符栈s1和储存中间结果的栈s2；</span><br><span class="line">2.从左至右扫描中缀表达式；</span><br><span class="line">3.遇到操作数时，将其压s2；</span><br><span class="line">4.遇到运算符时，比较其与s1栈顶运算符的优先级：</span><br><span class="line">　（1）如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</span><br><span class="line">　（2）否则，若优先级比栈顶运算符的高，也将运算符压入s1；</span><br><span class="line">　（3）否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较； </span><br><span class="line">5.遇到括号时：　</span><br><span class="line">（1）如果是左括号&quot;(&quot;，则直接压入s1　</span><br><span class="line">（2）如果是右括号&quot;)&quot;，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span><br><span class="line">6.重复步骤2至5，直到表达式的最右边</span><br><span class="line">7.将s1中剩余的运算符依次弹出并压入s2</span><br><span class="line">8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</span><br></pre></td></tr></table></figure><p>4：算法的层面</p><p>​    理解算法→灵活运用算法→自己设计算法</p><p>5：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">package com.it.stack;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class PolandNotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //定义一个逆波兰表达式</span><br><span class="line">        //(3+4)*5-6 =&gt; 3 4 + 5 * 6 -</span><br><span class="line">        //为了方便，逆波兰表达式的数字和符号用空格隔开</span><br><span class="line">/*        String suffixExpression = &quot;30 4 + 5 * 6 -&quot;;</span><br><span class="line">        //思路</span><br><span class="line">        //1：先将&quot;3 4 + 5 * 6 -&quot;放入ArrayList中，这里是为了方便根据索引扫描</span><br><span class="line">        //2：将ArrayList传递给一个方法，遍历ArrayList，配合栈，完成计算</span><br><span class="line">        List&lt;String&gt; list = getListString(suffixExpression);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        int res = calculate(list);</span><br><span class="line">        System.out.println(&quot;计算的结果是=&quot; + res);*/</span><br><span class="line"></span><br><span class="line">        //测试中缀表达式转换成list</span><br><span class="line">        String expression = &quot;1+((2+3)*4)-5&quot;;</span><br><span class="line">        List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);</span><br><span class="line">        System.out.println(&quot;中缀表达式\n&quot; + expression);</span><br><span class="line">        System.out.println(&quot;中缀表达式对应的list\n&quot; + infixExpressionList);</span><br><span class="line">        //将中缀表达式得到的list转换为逆波兰表达式的字符串</span><br><span class="line">        List&lt;String&gt; suffixExpressionList = parseSuffixExpressionList(infixExpressionList);</span><br><span class="line">        System.out.println(&quot;后缀表达式对应的list\n&quot; + suffixExpressionList);</span><br><span class="line">        //验算逆序表达式的结果</span><br><span class="line">        System.out.printf(&quot;expression=%d&quot;, calculate(suffixExpressionList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;String&gt; getListString(String suffixExpression) &#123;</span><br><span class="line">        String[] split = suffixExpression.split(&quot; &quot;);</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        for (String s : split) &#123;</span><br><span class="line">            //遍历添加元素到集合</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //运算</span><br><span class="line">    public static int calculate(List&lt;String&gt; ls) &#123;</span><br><span class="line">        //创建栈</span><br><span class="line">        Stack&lt;String&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (String item : ls) &#123;</span><br><span class="line">            //使用正则表达式取出数,匹配的是多位数</span><br><span class="line">            if (item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">                //入栈</span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int pop2 = Integer.parseInt(stack.pop());</span><br><span class="line">                int pop1 = Integer.parseInt(stack.pop());</span><br><span class="line">                int res = 0;</span><br><span class="line">                if (item.equals(&quot;+&quot;)) &#123;</span><br><span class="line">                    res = pop1 + pop2;</span><br><span class="line">                &#125; else if (item.equals(&quot;-&quot;)) &#123;</span><br><span class="line">                    res = pop1 - pop2;//先弹出的是pop2</span><br><span class="line">                &#125; else if (item.equals(&quot;*&quot;)) &#123;</span><br><span class="line">                    res = pop1 * pop2;</span><br><span class="line">                &#125; else if (item.equals(&quot;/&quot;)) &#123;</span><br><span class="line">                    res = pop1 / pop2;//先弹出的是pop2</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;运算符有误！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(&quot;&quot; + res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //最后留在栈中的就是运算结果</span><br><span class="line">        return Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将中缀表达式转出对应的list</span><br><span class="line">    public static List&lt;String&gt; toInfixExpressionList(String s) &#123;</span><br><span class="line">        //定义一个list，存放中缀表达式的内容</span><br><span class="line">        List&lt;String&gt; ls = new ArrayList&lt;String&gt;();</span><br><span class="line">        int i = 0;//指针，用于遍历s</span><br><span class="line">        String str;//对多位数的拼接工作</span><br><span class="line">        char c;//每遍历一个字符，放在char中</span><br><span class="line">        do &#123;</span><br><span class="line">            //如果c是一个非数字，直接加入到ls</span><br><span class="line">            if ((c = s.charAt(i)) &lt; 48 || (c = s.charAt(i)) &gt; 57) &#123;</span><br><span class="line">                ls.add(&quot;&quot; + c);</span><br><span class="line">                i++;//i 需要后移</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //如果是一个数，需要考虑多位数问题</span><br><span class="line">                str = &quot;&quot;;//先将str置空</span><br><span class="line">                //‘0’ 【48】 ‘9’【57】</span><br><span class="line">                while (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= 48 &amp;&amp; (c = s.charAt(i)) &lt;= 57) &#123;</span><br><span class="line">                    str += c;//拼接</span><br><span class="line">                    i++;</span><br><span class="line">                    //while循环结束之后多位数就拼接完成</span><br><span class="line">                &#125;</span><br><span class="line">                ls.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (i &lt; s.length());</span><br><span class="line">        return ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将得到的中缀表达式转换成为的list=&gt;后缀表达式对应的list</span><br><span class="line">    public static List&lt;String&gt; parseSuffixExpressionList(List&lt;String&gt; ls) &#123;</span><br><span class="line">        //定义两个栈</span><br><span class="line">        Stack&lt;String&gt; s1 = new Stack&lt;String&gt;();//定义符号栈</span><br><span class="line">        //说明：因为S2这个栈，在整个过程中没有pop操作，而且后面我们还需要逆序输出，因此直接用ArrayList操作</span><br><span class="line">        //Stack stack2=new Stack();</span><br><span class="line">        List&lt;String&gt; s2 = new ArrayList&lt;&gt;();//储存中间结果的list</span><br><span class="line">        for (String item : ls) &#123;</span><br><span class="line">            if (item.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125; else if (item.equals(&quot;(&quot;)) &#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125; else if (item.equals(&quot;)&quot;)) &#123;</span><br><span class="line">                //（2）如果是右括号&quot;)&quot;</span><br><span class="line">                while (!s1.peek().equals(&quot;(&quot;)) &#123;</span><br><span class="line">//                    则依次弹出s1栈顶的运算符，并压入s2</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                //直到遇到左括号为止，此时将这一对括号丢弃</span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //当item的优先级小于或等于栈顶运算符的优先级，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；</span><br><span class="line">                //需要加入优先级高低的方法</span><br><span class="line">                while (s1.size() != 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item)) &#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //for循环完成之后，将item压入栈中</span><br><span class="line">        while (s1.size() != 0) &#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return s2;//因为是存放到list中，按照顺序输出就是后缀表达式对应的list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编写一个类，可以返回一个运算符对应的优先级</span><br><span class="line">class Operation &#123;</span><br><span class="line">    private static int ADD = 1;</span><br><span class="line">    private static int SUB = 1;</span><br><span class="line">    private static int MUL = 2;</span><br><span class="line">    private static int DIV = 2;</span><br><span class="line"></span><br><span class="line">    public static int getValue(String operation) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        switch (operation) &#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                result = ADD;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                result = SUB;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                result = MUL;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;/&quot;:</span><br><span class="line">                result = DIV;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">//                System.out.println(&quot;不存在操作符&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一：栈&quot;&gt;&lt;a href=&quot;#一：栈&quot; class=&quot;headerlink&quot; title=&quot;一：栈&quot;&gt;&lt;/a&gt;一：栈&lt;/h1&gt;&lt;h3 id=&quot;1：栈的应用场景&quot;&gt;&lt;a href=&quot;#1：栈的应用场景&quot; class=&quot;headerlink&quot; title=&quot;1：栈的应
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java数据结构和算法(1）数组，队列，链表</title>
    <link href="https://yanyubing.xyz/2018/05/28/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89%E6%95%B0%E7%BB%84%EF%BC%8C%E9%98%9F%E5%88%97%EF%BC%8C%E9%93%BE%E8%A1%A8/"/>
    <id>https://yanyubing.xyz/2018/05/28/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89%E6%95%B0%E7%BB%84%EF%BC%8C%E9%98%9F%E5%88%97%EF%BC%8C%E9%93%BE%E8%A1%A8/</id>
    <published>2018-05-28T13:46:12.000Z</published>
    <updated>2019-12-07T15:55:13.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1：数据结构分类https-leetcode-cn-com-interview"><a href="#1：数据结构分类https-leetcode-cn-com-interview" class="headerlink" title="1：数据结构分类https://leetcode-cn.com/interview/"></a>1：数据结构分类<a href="https://leetcode-cn.com/interview/" target="_blank" rel="noopener">https://leetcode-cn.com/interview/</a></h2><p>线性结构</p><p>线性结构分类：数组，队列，链表，栈</p><p>储存结构分类：顺序储存结构和链式储存结构</p><p>非线性结构</p><p>非线性结构分类：二维数组，多维数组，广义表，树结构，图结构</p><h2 id="2：稀疏数组"><a href="#2：稀疏数组" class="headerlink" title="2：稀疏数组"></a>2：稀疏数组</h2><p>1：基本介绍博客：<a href="https://www.cnblogs.com/blizzawang/p/11411602.html" target="_blank" rel="noopener">https://www.cnblogs.com/blizzawang/p/11411602.html</a> </p><p>2：逻辑：稀疏数组第一行第一列表示二维数组的行数，第一行第二列表示二维数组的列数，第一行第三列表示二维数组非0的个数，下列每一行的三个数分别表示哪一行，哪一列，对应的数是多少。</p><p>3：转换为稀疏数组主要用于对数据的压缩</p><p>4：二维数组与稀疏数组转换代码实现，核心思想为数据的对应转换！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">1：二维数组转换为稀疏数组思路：</span><br><span class="line">1.遍历原始的二维数组，得到有数据的个数n</span><br><span class="line">2.根据sum就可以创建稀疏数组sparseArr int[n+1][3]</span><br><span class="line">3.将二维数组的有效数据存入到稀疏数组</span><br><span class="line"></span><br><span class="line">2：稀疏数组转换为二维数组：</span><br><span class="line">1：先读取稀疏数组的第一行</span><br><span class="line">2：根据第一行的数据创建原始二位数组</span><br><span class="line">3：在读取稀疏数组后几行的数据，并赋给原始二维数组即可</span><br><span class="line"></span><br><span class="line">package com.it.sparsearray;</span><br><span class="line"></span><br><span class="line">//棋盘二维数组转换为稀疏数组</span><br><span class="line">public class SparseArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //先创建一个原始的二维数组 11*11</span><br><span class="line">        //0表示没有棋子，1表示黑子，2表示白子</span><br><span class="line">        int[][] chessArr1 = new int[11][11];</span><br><span class="line">        chessArr1[1][2] = 1;</span><br><span class="line">        chessArr1[2][3] = 2;</span><br><span class="line">        //原始的二维数组</span><br><span class="line">        for (int[] ints : chessArr1) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        //将二维数组转为稀疏数组的思路</span><br><span class="line">        //1：先遍历二维数组，得到非0的个数</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; 11; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 11; j++) &#123;</span><br><span class="line">                if (chessArr1[i][j] != 0) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //2：创建对应的稀疏数组</span><br><span class="line">        int sparseArr[][] = new int[sum + 1][3];</span><br><span class="line">        //给稀疏数字赋值</span><br><span class="line">        sparseArr[0][0] = 11;</span><br><span class="line">        sparseArr[0][1] = 11;</span><br><span class="line">        sparseArr[0][2] = sum;</span><br><span class="line">        //遍历二维数组，将非0的值存放到稀疏数组中</span><br><span class="line">        int count = 0;//count用于记录是第几个非0数字</span><br><span class="line">        for (int i = 0; i &lt; 11; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 11; j++) &#123;</span><br><span class="line">                if (chessArr1[i][j] != 0) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][0] = i;</span><br><span class="line">                    sparseArr[count][1] = j;</span><br><span class="line">                    sparseArr[count][2] = chessArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //输出稀疏数组</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;得到的稀疏数组如下&quot;);</span><br><span class="line">        for (int i = 0; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;%d\t%d\t%d\t\n&quot;, sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);</span><br><span class="line">        &#125;</span><br><span class="line">        //根据稀疏数组的第一行数据，创建元素二维数组</span><br><span class="line">        int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];</span><br><span class="line">        //输出恢复后的二维数组</span><br><span class="line">        System.out.println(&quot;转换为二维数组如下&quot;);</span><br><span class="line">        for (int i = 1; i &lt; sparseArr[0][2] + 1; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int[] ints : chessArr2) &#123;</span><br><span class="line">            for (int anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3：队列"><a href="#3：队列" class="headerlink" title="3：队列"></a>3：队列</h1><p>1：队列基本介绍</p><p>​    队列是一个有序表，可以用数组或者链表来实现</p><p>​    队列为先入先出原则</p><p>​    队列加数据从尾部开始加，首部不变；取数据从首部开始取，尾部不变</p><p>​    核心思想：普通队列，如队列大小为10，那么只能add10次数据，因为数组索引用过已经无法再次使用；而环形队列判断队列是否满的依据则是队列中是否已经占满数据。</p><p>​    注意：取出数据之后数组元素并未被移除，环形队列也是</p><p>2：普通队列实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">package com.it.queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ArrayQueueDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayQueue queue = new ArrayQueue(5);</span><br><span class="line">        char key = &apos; &apos;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        boolean loop = true;</span><br><span class="line">        //输出一个菜单</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">            System.out.println(&quot;e(exit):退出队列&quot;);</span><br><span class="line">            System.out.println(&quot;a(add):添加数据到队列&quot;);</span><br><span class="line">            System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;h(head):查看队列的数据&quot;);</span><br><span class="line">            key = scanner.next().charAt(0);//接收一个字符</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &apos;s&apos;://显示队列</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;a&apos;://添加数据</span><br><span class="line">                    System.out.println(&quot;请输入一个数&quot;);</span><br><span class="line">                    int value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;g&apos;://取出数据</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = queue.getQueue();</span><br><span class="line">                        System.out.printf(&quot;取出的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;h&apos;://查看队列头的数据是什么</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = queue.headQueue();</span><br><span class="line">                        System.out.printf(&quot;队列头的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;e&apos;://退出</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;--------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用数组模拟队列，编写一个ArrayQueue类</span><br><span class="line">class ArrayQueue &#123;</span><br><span class="line">    private int maxSize;//表示数组最大容量</span><br><span class="line">    private int front;//队列头</span><br><span class="line">    private int rear;//队列尾</span><br><span class="line">    private int[] arr;//该数据用于队列存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    //创建队列的构造器,数组最大容量</span><br><span class="line">    public ArrayQueue(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = -1;//指向队列头部的前一个位置</span><br><span class="line">        rear = -1;//指向队列尾部</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        //当尾部到达了队列最后一个无法添加数据</span><br><span class="line">        return rear == maxSize - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        //当队列头与队列尾相等时为空</span><br><span class="line">        return rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;队列满，无法加入数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //未满，可以加入数据</span><br><span class="line">        rear++;//让rear后移</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getQueue() &#123;</span><br><span class="line">        //判断队列是否空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            //通过抛出异常处理</span><br><span class="line">            throw new RuntimeException(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //front后移</span><br><span class="line">        front++;</span><br><span class="line">        //获取数据</span><br><span class="line">        return arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showQueue() &#123;</span><br><span class="line">        //遍历</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;队列空的，没数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d]=%d\n&quot;, i, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int headQueue() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列空的，没数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //front指向数组头部前一位</span><br><span class="line">        return arr[front + 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3：环形队列实现思路</p><p>​    1：front变量的含义调整，front指向队列的第一个元素，也就是arr[front]就是队列的第一个元素，front初始值默认为0，rear的初始值为0</p><p>​    2：rear变量的含义做一个调整，rear指向队列最后一个元素的后一个位置，因为希望空出一个空间作为约定</p><p>​    3：当队列满时，条件是（rear+1）%maxSize=front</p><p>​    4：当队列为空的条件：rear=front</p><p>​    5：当我们这样分析，队列中有效的数据个数（rear+maxSize-front)%maxSize</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">//环形队列</span><br><span class="line">package com.it.queue;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class CircleArrayQueue &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CircleArray circleArray = new CircleArray(5);</span><br><span class="line">        char key = &apos; &apos;;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        boolean loop = true;</span><br><span class="line">        System.out.println(&quot;测试环形队列！&quot;);</span><br><span class="line">        //输出一个菜单</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            System.out.println(&quot;s(show):显示队列&quot;);</span><br><span class="line">            System.out.println(&quot;e(exit):退出队列&quot;);</span><br><span class="line">            System.out.println(&quot;a(add):添加数据到队列&quot;);</span><br><span class="line">            System.out.println(&quot;g(get):从队列取出数据&quot;);</span><br><span class="line">            System.out.println(&quot;h(head):查看队列的数据&quot;);</span><br><span class="line">            key = scanner.next().charAt(0);//接收一个字符</span><br><span class="line">            switch (key) &#123;</span><br><span class="line">                case &apos;s&apos;://显示队列</span><br><span class="line">                    circleArray.showQueue();</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;a&apos;://添加数据</span><br><span class="line">                    System.out.println(&quot;请输入一个数&quot;);</span><br><span class="line">                    int value = scanner.nextInt();</span><br><span class="line">                    circleArray.addQueue(value);</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;g&apos;://取出数据</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.getQueue();</span><br><span class="line">                        System.out.printf(&quot;取出的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;h&apos;://查看队列头的数据是什么</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int res = circleArray.headQueue();</span><br><span class="line">                        System.out.printf(&quot;队列头的数据是%d\n：&quot;, res);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                case &apos;e&apos;://退出</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = false;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;--------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序退出&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用数组模拟队列，编写一个ArrayQueue类</span><br><span class="line">class CircleArray &#123;</span><br><span class="line">    private int maxSize;//表示数组最大容量</span><br><span class="line">    //    front变量的含义调整，front指向队列的第一个元素，也就是arr[front]就是队列的第一个元素，front初始值默认为0，rear的初始值为0</span><br><span class="line">    private int front;//队列头</span><br><span class="line">    //    rear变量的含义做一个调整，rear指向队列最后一个元素的后一个位置，因为希望空出一个空间作为约定</span><br><span class="line">    private int rear;//队列尾</span><br><span class="line">    private int[] arr;//该数据用于队列存放数据，模拟队列</span><br><span class="line"></span><br><span class="line">    //创建队列的构造器,数组最大容量</span><br><span class="line">    public CircleArray(int arrMaxSize) &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = new int[maxSize];</span><br><span class="line">        front = 0;//指向队列头部的前一个位置</span><br><span class="line">        rear = 0;//指向队列尾部</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isFull() &#123;</span><br><span class="line">        //判断是否满</span><br><span class="line">        return (rear + 1) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        //当队列头与队列尾相等时为空</span><br><span class="line">        return rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addQueue(int n) &#123;</span><br><span class="line">        //判断队列是否满</span><br><span class="line">        if (isFull()) &#123;</span><br><span class="line">            System.out.println(&quot;队列满，无法加入数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //未满，可以加入数据</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        rear = (rear + 1) % maxSize;//让rear后移，这里必须考虑取模</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getQueue() &#123;</span><br><span class="line">        //判断队列是否空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            //通过抛出异常处理</span><br><span class="line">            throw new RuntimeException(&quot;队列为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //这里分析出front对应的值保留到一个临时变量</span><br><span class="line">        //将front后移,考虑取模</span><br><span class="line">        //将临时变量的变量返回</span><br><span class="line">        int value = arr[front];</span><br><span class="line">        front = (front + 1) % maxSize;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showQueue() &#123;</span><br><span class="line">        //遍历</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;队列空的，没数据&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //思路，从front开始遍历</span><br><span class="line">        for (int i = front; i &lt; (front + size()); i++) &#123;</span><br><span class="line">            System.out.printf(&quot;arr[%d]=%d\n&quot;, i % maxSize, arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //求出当前队列有效数据的个数，为了遍历</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int headQueue() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;队列空的，没数据&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //front指向数组头部前一位</span><br><span class="line">        return arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4：单向链表"><a href="#4：单向链表" class="headerlink" title="4：单向链表"></a>4：单向链表</h1><p>1：链表基本介绍</p><p>​    链表是以节点的方式来储存，链式储存</p><p>​    每个节点包含data域，next域：指向下一个节点</p><p>​    链表的各个节点不一定是连续储存</p><p>​    链表分带头节点的链表和没有头节点的链表，根据实际需求来确定</p><p>2：单链表的创建（添加），显示单向链表的分析</p><p>​    head节点：不存放具体的数据，作用就是表示单链表头</p><p>​    先创建一个head头节点，作用就是单链表的头</p><p>​    后面我们每添加一个节点，就直接加入到链表的最后</p><p>​    通过一个辅助的指针，帮助遍历</p><p>3：单链表代码实现</p><p>​    1：直接添加到英雄的尾部</p><p>​    2：考虑节点排名添加（插入）</p><p>​    思路：</p><p>​        1：首先找到新添加的节点位置，通过辅助变量（指针）</p><p>​        2：新的节点.next=temp.next</p><p>​        3：将temp.next=新的节点</p><p>​        4：可以在内存中实现排序</p><p>​    3：修改节点</p><p>​    4：删除节点</p><p>​        1：找到需要删除节点的前一个节点</p><p>​        2：temp.next=temp.next.next</p><p>​        3：被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收</p><p>​    5：求单链表的节点个数</p><p>​        1：遍历（temp后移）并且length++；</p><p>​    6：查找单链表中的倒数第k个节点</p><p>​        1：编写一个方法，接收head节点，同时接收一个index</p><p>​        2：index表示倒数第index的索引</p><p>​        3：先遍历链表，拿到链表所有个数getLength，再获取第n-index节点信息</p><p>​    7：链表的反转</p><p>​        1：创建新的链表（定义一个新的链表头reverse）</p><p>​        2：遍历原链表可以获取顺数每个节点的信息</p><p>​        3：每遍历一个节点就将其取出并放在新链表的最前方</p><p>​        4：原来链表的head.next=reverse.next</p><p>​    8：链表的逆序打印</p><p>​        1：方法一：单链表反转之后打印</p><p>​        2：方法二：利用栈这个数据结构，将各个节点压入栈中，然后利用栈的先进后出的特点，实现逆序打印效果</p><p>​        3：方法三：循环，判断temp是否是尾结点，打印尾结点，把尾结点前一结点.next赋值为null，并且重置temp=head.next；如果最后只有一个节点，即head.next=temp，且temp.next==null，则打印temp然后退出循环</p><p>​        4：方法四：递归</p><p>​        注意：操作链表时，一定要注意链表是否已经改变！</p><p>​    9：多个链表的合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line">package com.it.com.it.linkedlist;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">//链表实现水浒英雄的增删改查</span><br><span class="line">public class SingleLinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //测试，先创建节点</span><br><span class="line">        HeroNode hero1 = new HeroNode(1, &quot;宋江&quot;, &quot;及时雨&quot;);</span><br><span class="line">        HeroNode hero2 = new HeroNode(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode hero3 = new HeroNode(3, &quot;吴用&quot;, &quot;智多星&quot;);</span><br><span class="line">        HeroNode hero4 = new HeroNode(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line">        //创建链表</span><br><span class="line">        SingleLinkedList singleLinkedList = new SingleLinkedList();</span><br><span class="line">        //直接加入</span><br><span class="line">//        singleLinkedList.add(hero1);</span><br><span class="line">//        singleLinkedList.add(hero4);</span><br><span class="line">//        singleLinkedList.add(hero2);</span><br><span class="line">//        singleLinkedList.add(hero3);</span><br><span class="line">        //按照编号添加</span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line">        //测试修改代码</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        HeroNode heroNode = new HeroNode(2, &quot;小卢&quot;, &quot;玉麒麟~~~&quot;);</span><br><span class="line">        singleLinkedList.update(heroNode);</span><br><span class="line">        //打印</span><br><span class="line">        System.out.println(&quot;修改之后链表的情况&quot;);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        //删除节点</span><br><span class="line">        singleLinkedList.del(1);</span><br><span class="line">//        singleLinkedList.del(4);</span><br><span class="line">//        singleLinkedList.del(2);</span><br><span class="line">//        singleLinkedList.del(3);</span><br><span class="line">        System.out.println(&quot;删除之后链表的情况&quot;);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        //测试链表节点个数</span><br><span class="line">//        System.out.println(&quot;有效节点个数&quot; + getLength(singleLinkedList.getHead()));</span><br><span class="line">        //测试倒数第k个节点</span><br><span class="line">//        int index = 3;</span><br><span class="line">//        HeroNode res = findLastIndexNode(singleLinkedList.getHead(), index);</span><br><span class="line">//        System.out.println(&quot;res=&quot; + res);</span><br><span class="line">        //测试反转链表</span><br><span class="line">//        System.out.println(&quot;反转之后链表是：&quot;);//这个方法改变了链表的结构</span><br><span class="line">//        reverseList(singleLinkedList.getHead());</span><br><span class="line">        //测试反转打印</span><br><span class="line">        System.out.println(&quot;反转打印方式二，栈方法：&quot;);</span><br><span class="line">        singleLinkedList.reversePrint();</span><br><span class="line">        System.out.println(&quot;反转打印方式一：&quot;);//这个方法该表了链表的结构</span><br><span class="line">        singleLinkedList.printReverse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义singleLinkedList管理英雄</span><br><span class="line">class SingleLinkedList &#123;</span><br><span class="line">    //初始化一个头结点，头结点不要动,不存放具体数据</span><br><span class="line">    private HeroNode head = new HeroNode(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    public HeroNode getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //添加节点到单向链表,这里没考虑排名</span><br><span class="line">    //1:找到最后节点（next域为null），把最后节点的next域指向新的节点</span><br><span class="line">    public void add(HeroNode heroNode) &#123;</span><br><span class="line">//因为head节点不能动，因此我们需要一个辅助遍历temp指针，来移动</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //找到链表的最后</span><br><span class="line">            if (temp.next == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果没有找到，就将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //当退出循环时，temp就指向了链表的最后</span><br><span class="line">        //将最后节点的next指向新的节点</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二种方式添加英雄，如果有这个排名，则添加失败，并给出提示</span><br><span class="line">    public void addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">        //因为是单链表，因为我们找到的temp是位于添加位置的前一个节点，否则无法添加</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = false;//标识添加编号是否存在，默认为false</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp.next == null) &#123;//说明temp已经在链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125; else if (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">                //位置找到，该节点添加到temp和temp.next之间插入</span><br><span class="line">                break;</span><br><span class="line">            &#125; else if (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                flag = true;//说明编号存在</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;//后移，遍历链表</span><br><span class="line">        &#125;</span><br><span class="line">        //退出循环之后，判断flag值</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            System.out.printf(&quot;准备插入的英雄的编号%d已经存在\n&quot;, heroNode.no);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //插入到链表中，temp的后面</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //修改节点信息，根据no编号来修改，即no编号不能改</span><br><span class="line">    public void update(HeroNode newHeroNode) &#123;</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //找到需要修改的节点，根据no编号</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        boolean flag = false;//表示是否找到该节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;//链表已经遍历结束</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                //找到节点</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //退出循环之后，根据flag判断是否找到要修改的节点</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;没找到编号为%d的节点，不能修改\n&quot;, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除节点</span><br><span class="line">//说明：是temp.next.no和需要删除的节点的no比较</span><br><span class="line">    public void del(int no) &#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        boolean flag = false;//标志是否找到待删除的节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp.next == null) &#123;</span><br><span class="line">                break;//到达链表尾部</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.next.no == no) &#123;</span><br><span class="line">                //找到待删除节点的前一个节点temp</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断flag</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            //可以删除</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;要删除的%d节点不存在\n&quot;, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //统计链表节点个数：去除头结点</span><br><span class="line">    public static int getLength(HeroNode head) &#123;</span><br><span class="line">        int length = 0;</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            HeroNode temp = head.next;</span><br><span class="line">            while (temp != null) &#123;</span><br><span class="line">                length++;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取单链表的倒数第K个节点</span><br><span class="line">    public static HeroNode findLastIndexNode(HeroNode hero, int index) &#123;</span><br><span class="line">        if (hero.next == null) &#123;</span><br><span class="line">            //链表为空</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //第一次遍历得到链表的长度（节点个数）</span><br><span class="line">        int size = getLength(hero);</span><br><span class="line">        //第二次遍历，先做index校验，是否合理</span><br><span class="line">        if (index &lt;= 0 || index &gt; size) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义一个辅助遍历temp</span><br><span class="line">        HeroNode temp = hero.next;</span><br><span class="line">        //往后数size-index个</span><br><span class="line">        for (int i = 0; i &lt; size - index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历链表，使用辅助变量遍历，因为head不能动</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //因为头结点不能动，所以我们需要一个辅助遍历来遍历</span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //判断是否到链表的最后</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //输出节点信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            //temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //单链表反转</span><br><span class="line">    public static void reverseList(HeroNode head) &#123;</span><br><span class="line">        //如果当前链表为空，或者只有一个节点，无需反转，直接返回</span><br><span class="line">        if (head.next == null || head.next.next == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义一个辅助指针，帮助我们遍历原来链表</span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        HeroNode next = null;//指向当前节点cur的下一个节点，作为中间变量</span><br><span class="line">        int sum = getLength(head);</span><br><span class="line">        //定义反转链表,注意此时的head在改变，所以提前获取到固定长度</span><br><span class="line">        HeroNode reverserHead = new HeroNode(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line">        for (int i = 0; i &lt; sum; i++) &#123;</span><br><span class="line">            //给原链表下个节点赋值,后续把next赋值给cur，达到移动的效果</span><br><span class="line">            next = cur.next;</span><br><span class="line">            //拼接操作，把reverserHead.next给cur.next,再把cur节点作为reverserHead.next</span><br><span class="line">            cur.next = reverserHead.next;</span><br><span class="line">            reverserHead.next = cur;</span><br><span class="line">            //next赋值给cur，达到移动的效果</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历反转链表，这里也可以直接把反转链表的next赋值给原来的head.next，直接用用来的list（）方法遍历</span><br><span class="line">        //判断是否为空</span><br><span class="line">        if (reverserHead.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //因为头结点不能动，所以我们需要一个辅助遍历来遍历</span><br><span class="line">        HeroNode temp = reverserHead.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //判断是否到链表的最后</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //输出节点信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            //temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printReverse() &#123;</span><br><span class="line">        HeroNode temp = head;//temp</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == head &amp;&amp; temp.next.next == null) &#123;</span><br><span class="line">                System.out.println(temp.next);</span><br><span class="line">                break;</span><br><span class="line">            &#125;//temp代表倒数第二个节点</span><br><span class="line">            if (temp.next.next == null) &#123;</span><br><span class="line">                System.out.println(temp.next);</span><br><span class="line">                temp.next = null;</span><br><span class="line">                temp = head;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //方式二</span><br><span class="line">    public void reversePrint() &#123;</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个栈，将各个节点压入栈中</span><br><span class="line">        Stack&lt;HeroNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;//cur后移</span><br><span class="line">        &#125;</span><br><span class="line">        //将栈中的节点进行打印，pop出栈,先进后出</span><br><span class="line">        while (stack.size() &gt; 0) &#123;</span><br><span class="line">            System.out.println(stack.pop());//后进先出</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建heroNode节点,每个heroNode对象就是一个节点</span><br><span class="line">class HeroNode &#123;</span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode next;//指向下一个节点</span><br><span class="line"></span><br><span class="line">    //构造器</span><br><span class="line">    public HeroNode(int hNo, String hName, String hNickname) &#123;</span><br><span class="line">        this.no = hNo;</span><br><span class="line">        this.name = hName;</span><br><span class="line">        this.nickname = hNickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //为了显示方便，重写tostring</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode[no=&quot; + no + &quot;,name=&quot; + name + &quot;,nickname=&quot; + nickname + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五：双向链表"><a href="#五：双向链表" class="headerlink" title="五：双向链表"></a>五：双向链表</h1><p>1：单向链表，查找只能一个方向next，而双休链表可以双向</p><p>2：单向链表不能自我删除，需要靠辅助节点temp</p><p>3：双向链表的遍历，添加，修改，删除的操作思路</p><p>​    添加步骤（默认添加到双向链表的最后）：</p><p>​    1：先找到双向链表的最后节点</p><p>​    2：temp.next=newHoroNode</p><p>​    3：newHoroNode.pre=temp</p><p>​    删除步骤：</p><p>​    1: 直接找到要删除的节点，比如temp</p><p>​    2：temp.pre.next=temp.next</p><p>​    3：temp.next.pre=temp.pre</p><p>4：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">package com.it.com.it.linkedlist;</span><br><span class="line"></span><br><span class="line">public class DoubleLinkedListDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 测试</span><br><span class="line">        System.out.println(&quot;双向链表的测试&quot;);</span><br><span class="line">        // 先创建节点</span><br><span class="line">        HeroNode2 hero1 = new HeroNode2(1, &quot;宋江&quot;, &quot;及时雨&quot;);</span><br><span class="line">        HeroNode2 hero2 = new HeroNode2(2, &quot;卢俊义&quot;, &quot;玉麒麟&quot;);</span><br><span class="line">        HeroNode2 hero3 = new HeroNode2(3, &quot;吴用&quot;, &quot;智多星&quot;);</span><br><span class="line">        HeroNode2 hero4 = new HeroNode2(4, &quot;林冲&quot;, &quot;豹子头&quot;);</span><br><span class="line">        // 创建一个双向链表</span><br><span class="line">        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();</span><br><span class="line">        // 添加数据</span><br><span class="line">        doubleLinkedList.add(hero1);</span><br><span class="line">        doubleLinkedList.add(hero2);</span><br><span class="line">        doubleLinkedList.add(hero3);</span><br><span class="line">        doubleLinkedList.add(hero4);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        // 修改</span><br><span class="line">        HeroNode2 newHeroNode = new HeroNode2(4, &quot;公孙胜&quot;, &quot;入云龙&quot;);</span><br><span class="line">        doubleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(&quot;修改后的链表情况&quot;);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        // 删除</span><br><span class="line">        doubleLinkedList.del(3);</span><br><span class="line">        System.out.println(&quot;删除后的链表情况~~&quot;);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个双向链表的类</span><br><span class="line">class DoubleLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    // 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span><br><span class="line">    private HeroNode2 head = new HeroNode2(0, &quot;&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    // 返回头节点</span><br><span class="line">    public HeroNode2 getHead() &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历双向链表的方法</span><br><span class="line">    // 显示链表[遍历]</span><br><span class="line">    public void list() &#123;</span><br><span class="line">        // 判断链表是否为空</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 判断是否到链表最后</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 输出节点的信息</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            // 将temp后移， 一定小心</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加一个节点到双向链表的最后.</span><br><span class="line">    public void add(HeroNode2 heroNode) &#123;</span><br><span class="line"></span><br><span class="line">        // 因为head节点不能动，因此我们需要一个辅助遍历 temp</span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        // 遍历链表，找到最后</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 找到链表的最后</span><br><span class="line">            if (temp.next == null) &#123;//</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果没有找到最后, 将将temp后移</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当退出while循环时，temp就指向了链表的最后</span><br><span class="line">        // 形成一个双向链表</span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样</span><br><span class="line">    // 只是 节点类型改成 HeroNode2</span><br><span class="line">    public void update(HeroNode2 newHeroNode) &#123;</span><br><span class="line">        // 判断是否空</span><br><span class="line">        if (head.next == null) &#123;</span><br><span class="line">            System.out.println(&quot;链表为空~&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到需要修改的节点, 根据no编号</span><br><span class="line">        // 定义一个辅助变量</span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        boolean flag = false; // 表示是否找到该节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == null) &#123;</span><br><span class="line">                break; // 已经遍历完链表</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                // 找到</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 根据flag 判断是否找到要修改的节点</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; else &#123; // 没有找到</span><br><span class="line">            System.out.printf(&quot;没有找到 编号 %d 的节点，不能修改\n&quot;, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从双向链表中删除一个节点,</span><br><span class="line">    // 说明</span><br><span class="line">    // 1 对于双向链表，我们可以直接找到要删除的这个节点</span><br><span class="line">    // 2 找到后，自我删除即可</span><br><span class="line">    public void del(int no) &#123;</span><br><span class="line"></span><br><span class="line">        // 判断当前链表是否为空</span><br><span class="line">        if (head.next == null) &#123;// 空链表</span><br><span class="line">            System.out.println(&quot;链表为空，无法删除&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode2 temp = head.next; // 辅助变量(指针)</span><br><span class="line">        boolean flag = false; // 标志是否找到待删除节点的</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (temp == null) &#123; // 已经到链表的最后</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.no == no) &#123;</span><br><span class="line">                // 找到的待删除节点的前一个节点temp</span><br><span class="line">                flag = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next; // temp后移，遍历</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断flag</span><br><span class="line">        if (flag) &#123; // 找到</span><br><span class="line">            // 可以删除</span><br><span class="line">            // temp.next = temp.next.next;[单向链表]</span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            // 这里我们的代码有问题?</span><br><span class="line">            // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span><br><span class="line">            if (temp.next != null) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.printf(&quot;要删除的 %d 节点不存在\n&quot;, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义HeroNode2 ， 每个HeroNode 对象就是一个节点</span><br><span class="line">class HeroNode2 &#123;</span><br><span class="line">    public int no;</span><br><span class="line">    public String name;</span><br><span class="line">    public String nickname;</span><br><span class="line">    public HeroNode2 next; // 指向下一个节点, 默认为null</span><br><span class="line">    public HeroNode2 pre; // 指向前一个节点, 默认为null</span><br><span class="line">    // 构造器</span><br><span class="line"></span><br><span class="line">    public HeroNode2(int no, String name, String nickname) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为了显示方法，我们重新toString</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;HeroNode [no=&quot; + no + &quot;, name=&quot; + name + &quot;, nickname=&quot; + nickname + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六：单向环形链表（约瑟夫环）"><a href="#六：单向环形链表（约瑟夫环）" class="headerlink" title="六：单向环形链表（约瑟夫环）"></a>六：单向环形链表（约瑟夫环）</h1><p>1：约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3，1。 </p><p>2：创建环形链表思路</p><p>​    1：先创建第一个节点，让first指向该节点，加入到已有的环形链表中即可</p><p>​    2：后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中</p><p>3：遍历环形链表</p><p>​    1：先让一个辅助指针（变量）curBoy,指向first节点</p><p>​    2：通过while循环遍历该环形链表即可，curBoy.next==first，结束</p><p>4：创建、遍历环形链表代码实现</p><p>5：出圈思路</p><p>​    1：根据用户的输入，生成一个小孩出圈的顺序</p><p>​    2：代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">package com.it.com.it.linkedlist;</span><br><span class="line"></span><br><span class="line">//约瑟夫问题：环形链表解决</span><br><span class="line">public class Josepfu &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();</span><br><span class="line">        circleSingleLinkedList.addBoy(10);</span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line">        //测试小孩出圈</span><br><span class="line">        circleSingleLinkedList.countBoy(1, 2, 10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建环形链表</span><br><span class="line">class CircleSingleLinkedList &#123;</span><br><span class="line">    //创建一个first节点，无编号</span><br><span class="line">    private Boy first = null;</span><br><span class="line"></span><br><span class="line">    //添加节点，构建成环形链表</span><br><span class="line">    public void addBoy(int nums) &#123;</span><br><span class="line">        //nums表示环形链表节点个数</span><br><span class="line">        if (nums &lt; 1) &#123;</span><br><span class="line">            System.out.println(&quot;nums值不正确&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy curBoy = null;//辅助指针，帮助构建环形链表</span><br><span class="line">        //使用for循环创建环形链表</span><br><span class="line">        for (int i = 1; i &lt;= nums; i++) &#123;</span><br><span class="line">            //根据编号创建小孩节点</span><br><span class="line">            Boy boy = new Boy(i);</span><br><span class="line">            //给第一个小孩赋值</span><br><span class="line">            if (i == 1) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);</span><br><span class="line">                //让curBoy指向第一个小孩，因为first不能变动，需要让curBoy辅助</span><br><span class="line">                curBoy = first;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //构建环</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                //curBoy后移</span><br><span class="line">                curBoy = curBoy.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //遍历环形链表</span><br><span class="line">    public void showBoy() &#123;</span><br><span class="line">        //判断链表是否为空</span><br><span class="line">        if (first == null) &#123;</span><br><span class="line">            System.out.println(&quot;没有小孩--&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //使用辅助指针帮助遍历</span><br><span class="line">        Boy curBoy = first;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.printf(&quot;小孩的编号%d:\n&quot;, curBoy.getNo());</span><br><span class="line">            //已经遍历完毕</span><br><span class="line">            if (curBoy.getNext() == first) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">//            curBoy后移</span><br><span class="line">            curBoy = curBoy.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //根据用户的输入，计算出圈的顺序</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param startNo  表示从第几个小孩开始数数</span><br><span class="line">     * @param countNum 表示数几下</span><br><span class="line">     * @param nums     表示最初有几个小孩，作为校验</span><br><span class="line">     */</span><br><span class="line">    public void countBoy(int startNo, int countNum, int nums) &#123;</span><br><span class="line">        if (first == null || startNo &lt; 1 || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(&quot;参数有误，请重新输入&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个辅助指针，帮助小孩出圈</span><br><span class="line">        Boy helper = first;</span><br><span class="line">        //使helper指向最后节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //相等说明helper在最后</span><br><span class="line">            if (helper.getNext() == first) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //helper后移</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //报数前，先让first和helper移动startNo-1次</span><br><span class="line">        for (int i = 0; i &lt; startNo - 1; i++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        //当小孩报数时，让first和helper指针同时移动countNum-1次，然后出圈</span><br><span class="line">        //这里是一个循环操作，知道圈中只有一个节点</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //说明圈中只有一个节点</span><br><span class="line">            if (helper == first) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //让first和helper指针同时移动countNum-1次，然后出圈</span><br><span class="line">            for (int i = 0; i &lt; countNum - 1; i++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            //这时first指向的节点就是要出圈的节点</span><br><span class="line">            System.out.printf(&quot;小孩%d出圈\n&quot;, first.getNo());</span><br><span class="line">            //first指向的节点出圈</span><br><span class="line">            first = first.getNext();//使first后移</span><br><span class="line">            helper.setNext(first);//使helper的next指向first</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(&quot;最后留在圈中的小孩编号是%d\n&quot;, first.getNo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建一个boy，表示一个节点</span><br><span class="line">class Boy &#123;</span><br><span class="line">    private int no;</span><br><span class="line">    private Boy next;//指向下一个节点，默认null</span><br><span class="line"></span><br><span class="line">    public Boy(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getNo() &#123;</span><br><span class="line">        return no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNo(int no) &#123;</span><br><span class="line">        this.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Boy getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(Boy next) &#123;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1：数据结构分类https-leetcode-cn-com-interview&quot;&gt;&lt;a href=&quot;#1：数据结构分类https-leetcode-cn-com-interview&quot; class=&quot;headerlink&quot; title=&quot;1：数据结构分类https:
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>怎么搭建自己的博客</title>
    <link href="https://yanyubing.xyz/2018/05/20/%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://yanyubing.xyz/2018/05/20/%E6%80%8E%E4%B9%88%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</id>
    <published>2018-05-20T13:46:12.000Z</published>
    <updated>2019-12-01T15:07:10.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h1><p>node.js</p><p>git</p><p>hexo</p><p>github账号</p><p>自己购买的域名</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>网上有很多基于hexo搭建github的博客可供参考：<a href="http://rosesnow.top/" target="_blank" rel="noopener">http://rosesnow.top</a> </p><p>这里主要描述流程和理解，方便遇到问题能够快速找到办法：</p><p>1：node.js是用于npm安装</p><p>2：hexo是本地博客servece</p><p>3：需要把hexo部署到github pages上</p><p>4：通过CNAME文件实现域名的重定向操作，最终实现自己的域名与hexo同步</p><p>5：直接在github上添加CANME文件可以实现一次转发，需要在blog/source目录下创建CNAME文件保证每次有效</p><p>6：最后在更新blog之后hexo  g ; hexo d 同步</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工具准备&quot;&gt;&lt;a href=&quot;#工具准备&quot; class=&quot;headerlink&quot; title=&quot;工具准备&quot;&gt;&lt;/a&gt;工具准备&lt;/h1&gt;&lt;p&gt;node.js&lt;/p&gt;
&lt;p&gt;git&lt;/p&gt;
&lt;p&gt;hexo&lt;/p&gt;
&lt;p&gt;github账号&lt;/p&gt;
&lt;p&gt;自己购买的域名&lt;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>

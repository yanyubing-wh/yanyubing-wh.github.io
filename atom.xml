<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鄢玉兵的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yanyubing.xyz/"/>
  <updated>2020-11-21T07:19:52.563Z</updated>
  <id>https://yanyubing.xyz/</id>
  
  <author>
    <name>鄢玉兵</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于制作视频抽帧数据集这件事</title>
    <link href="https://yanyubing.xyz/2020/11/21/%E5%85%B3%E4%BA%8E%E5%88%B6%E4%BD%9C%E8%A7%86%E9%A2%91%E6%8A%BD%E5%B8%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E8%BF%99%E4%BB%B6%E4%BA%8B/"/>
    <id>https://yanyubing.xyz/2020/11/21/%E5%85%B3%E4%BA%8E%E5%88%B6%E4%BD%9C%E8%A7%86%E9%A2%91%E6%8A%BD%E5%B8%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E8%BF%99%E4%BB%B6%E4%BA%8B/</id>
    <published>2020-11-21T07:10:14.506Z</published>
    <updated>2020-11-21T07:19:52.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于制作视频抽帧数据集这件事"><a href="#关于制作视频抽帧数据集这件事" class="headerlink" title="关于制作视频抽帧数据集这件事"></a>关于制作视频抽帧数据集这件事</h1><p>一：制作视频数据集的原则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.减少相同样本重复性（避免过拟合）</span><br><span class="line">2.能快速过滤到自己要的图片数据</span><br></pre></td></tr></table></figure><p>二：技巧与问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.如果目标类别在已有的预训练模型中有，并且业务逻辑也是伴随着目标类别来做的，那么可以使用预训练模型检测作为提取的第一步（这里conf阈值可以调高，更好的定位目标图片）</span><br><span class="line"></span><br><span class="line">2.问题：抽取的第一步会出现连续多帧都会被采集到，如何过滤？</span><br><span class="line">方案①：将提取比例作为超参数，随机提取此比例的图片</span><br><span class="line">方案②：间隔n张提取一张（适用于类别稳定出现的情况）</span><br><span class="line"></span><br><span class="line">3.问题：本人遇到的情形是，目标类别一般会均匀出现（3s出现一次，一次被抽取的第一步抽取到一张），但是偶尔会有特例出现（一次被抽取的第一步提取到100张）？</span><br><span class="line">使用上述方案①和方案②都不合适，会过多的采用同样的图片，或者有很多样本没有采用；</span><br><span class="line">解决方案为：视频流中有时间戳，通过时间戳的间隔来过滤</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于制作视频抽帧数据集这件事&quot;&gt;&lt;a href=&quot;#关于制作视频抽帧数据集这件事&quot; class=&quot;headerlink&quot; title=&quot;关于制作视频抽帧数据集这件事&quot;&gt;&lt;/a&gt;关于制作视频抽帧数据集这件事&lt;/h1&gt;&lt;p&gt;一：制作视频数据集的原则&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>10-目标跟踪</title>
    <link href="https://yanyubing.xyz/2020/11/17/10-%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/"/>
    <id>https://yanyubing.xyz/2020/11/17/10-%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA/</id>
    <published>2020-11-17T08:08:39.273Z</published>
    <updated>2020-11-17T08:08:39.273Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>09-场景文字识别</title>
    <link href="https://yanyubing.xyz/2020/11/17/09-%E5%9C%BA%E6%99%AF%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>https://yanyubing.xyz/2020/11/17/09-%E5%9C%BA%E6%99%AF%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/</id>
    <published>2020-11-17T08:08:24.208Z</published>
    <updated>2020-11-17T08:08:24.208Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>08-人体关键点检测</title>
    <link href="https://yanyubing.xyz/2020/11/17/08-%E4%BA%BA%E4%BD%93%E5%85%B3%E9%94%AE%E7%82%B9%E6%A3%80%E6%B5%8B/"/>
    <id>https://yanyubing.xyz/2020/11/17/08-%E4%BA%BA%E4%BD%93%E5%85%B3%E9%94%AE%E7%82%B9%E6%A3%80%E6%B5%8B/</id>
    <published>2020-11-17T08:08:11.615Z</published>
    <updated>2020-11-17T08:08:11.615Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>07-视频分类</title>
    <link href="https://yanyubing.xyz/2020/11/17/07-%E8%A7%86%E9%A2%91%E5%88%86%E7%B1%BB/"/>
    <id>https://yanyubing.xyz/2020/11/17/07-%E8%A7%86%E9%A2%91%E5%88%86%E7%B1%BB/</id>
    <published>2020-11-17T08:07:59.237Z</published>
    <updated>2020-11-17T08:07:59.237Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>06-实例分割</title>
    <link href="https://yanyubing.xyz/2020/11/17/06-%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"/>
    <id>https://yanyubing.xyz/2020/11/17/06-%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/</id>
    <published>2020-11-17T08:07:38.004Z</published>
    <updated>2020-11-17T08:07:38.004Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>05-语义分割</title>
    <link href="https://yanyubing.xyz/2020/11/17/05-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"/>
    <id>https://yanyubing.xyz/2020/11/17/05-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/</id>
    <published>2020-11-17T08:07:25.808Z</published>
    <updated>2020-11-17T08:07:25.808Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>04-目标检测</title>
    <link href="https://yanyubing.xyz/2020/11/17/04-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    <id>https://yanyubing.xyz/2020/11/17/04-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/</id>
    <published>2020-11-17T08:07:14.280Z</published>
    <updated>2020-11-17T08:07:14.280Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>03-图像分类</title>
    <link href="https://yanyubing.xyz/2020/11/17/03-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
    <id>https://yanyubing.xyz/2020/11/17/03-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</id>
    <published>2020-11-17T08:06:58.308Z</published>
    <updated>2020-11-18T08:35:36.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><p>1：KNN</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># 实现方法</span><br><span class="line"># 1）给定测试对象，计算它与训练集中每个对象的距离。</span><br><span class="line"># 将图片resize成固定大小，计算灰度图的每个像素的欧氏距离</span><br><span class="line"># 2）圈定距离最近的k个训练对象，作为测试对象的邻居。</span><br><span class="line"># 3）根据这k个近邻对象所属的类别，找到占比最高的那个类别作为测试对象的预测类别。</span><br><span class="line">import glob</span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 欧式距离</span><br><span class="line">def get_EuclideanDistance(x, y):</span><br><span class="line">    myx = np.array(x)</span><br><span class="line">    myy = np.array(y)</span><br><span class="line">    return np.sqrt(np.sum((myx - myy) * (myx - myy)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取数据集，返回 [class,image]</span><br><span class="line">def getDataSet(path):</span><br><span class="line">    if not path.endswith(&apos;.jpg&apos;):</span><br><span class="line">        # 获取路径下的图片</span><br><span class="line">        files = glob.glob(path + &apos;*.jpg&apos;)</span><br><span class="line">    else:</span><br><span class="line">        files = [path]</span><br><span class="line">    # 读取图片储存类别和对应的像素值</span><br><span class="line">    dataset = []</span><br><span class="line">    for file in files:</span><br><span class="line">        print(file)</span><br><span class="line">        image = cv2.imread(file, 0)</span><br><span class="line">        image = cv2.resize(image, (400, 400), interpolation=cv2.INTER_CUBIC)</span><br><span class="line">        class_ = file.split(&quot;\\&quot;)[-1].split(&apos;_&apos;)[0]</span><br><span class="line">        data = [class_, image]</span><br><span class="line">        dataset.append(data)</span><br><span class="line">    return dataset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 训练集的数据集</span><br><span class="line">    cat_train_path = &apos;D:/File_yan/study/ImageClassification/dataSet/train/cat/&apos;</span><br><span class="line">    dog_train_path = &apos;D:/File_yan/study/ImageClassification/dataSet/train/dog/&apos;</span><br><span class="line">    cat_data_set = getDataSet(cat_train_path)</span><br><span class="line">    dog_data_set = getDataSet(dog_train_path)</span><br><span class="line"></span><br><span class="line">    testFiles = glob.glob(&apos;D:/File_yan/study/ImageClassification/dataSet/test/cat/&apos; + &apos;*.jpg&apos;)</span><br><span class="line">    for file in testFiles:</span><br><span class="line">        EuclideanDistances = []</span><br><span class="line">        testData = getDataSet(file)</span><br><span class="line">        for test in testData:</span><br><span class="line">            for cat_data in cat_data_set:</span><br><span class="line">                EuclideanDistance = [cat_data[0], cat_data[1], get_EuclideanDistance(test[1], cat_data[1])]</span><br><span class="line">                EuclideanDistances.append(EuclideanDistance)</span><br><span class="line"></span><br><span class="line">            for dog_data in dog_data_set:</span><br><span class="line">                EuclideanDistance = [dog_data[0], dog_data[1], get_EuclideanDistance(test[1], dog_data[1])]</span><br><span class="line">                EuclideanDistances.append(EuclideanDistance)</span><br><span class="line">        testimage = cv2.imread(file)</span><br><span class="line">        cv2.imshow(&apos;test&apos;, testimage)</span><br><span class="line">        cv2.waitKey(0)</span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line">        EuclideanDistances.sort(key=lambda x: int(x[2]))</span><br><span class="line">        EuclideanDistances = np.array(EuclideanDistances)</span><br><span class="line">        for e in EuclideanDistances:</span><br><span class="line">            print(e[0])</span><br><span class="line">            cv2.imshow(&apos;target&apos;,e[1])</span><br><span class="line">            cv2.waitKey(0)</span><br><span class="line">            cv2.destroyAllWindows()</span><br><span class="line">            print(e[2])</span><br><span class="line"></span><br><span class="line">#问题</span><br><span class="line">#把每个像素作为特征输入，并不能很好的拟合实际图片的特征；并且数据量大的时候，匹配过程耗时长</span><br></pre></td></tr></table></figure><p>2：SVM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#实现方法</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">from sklearn import datasets</span><br><span class="line">from sklearn import svm</span><br><span class="line"></span><br><span class="line">digits = datasets.load_digits()</span><br><span class="line">clf = svm.SVC(gamma=0.0001, C=100)</span><br><span class="line"></span><br><span class="line">x, y = digits.data[:-10], digits.target[:-10]</span><br><span class="line">clf.fit(x, y)</span><br><span class="line"></span><br><span class="line">print(&apos;prediction:&apos;, clf.predict([digits.data[-2]]))</span><br><span class="line">plt.imshow(digits.images[-2], interpolation=&apos;nearest&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>3：BPNN</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#反向传播网络</span><br><span class="line">问题在于：全连接层导致参数过多，过拟合</span><br></pre></td></tr></table></figure><p>4：CNN</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">卷积神经网络，主要在于卷积运算</span><br><span class="line">特点：参数得到了控制，即使我们使用简单神经网络模型（BPNN）的最大验证准确性约为97％，但CNN模型仅需一个卷积层就能够获得98％+的收益！</span><br><span class="line">1 LeNet：</span><br><span class="line">2 AlexNet：</span><br><span class="line">3 VGG-Net：</span><br><span class="line">4 GoogLeNet：</span><br><span class="line">5 Resnet：</span><br></pre></td></tr></table></figure><p>5：迁移学习</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图像分类&quot;&gt;&lt;a href=&quot;#图像分类&quot; class=&quot;headerlink&quot; title=&quot;图像分类&quot;&gt;&lt;/a&gt;图像分类&lt;/h2&gt;&lt;p&gt;1：KNN&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>02-opencv</title>
    <link href="https://yanyubing.xyz/2020/11/17/02-opencv/"/>
    <id>https://yanyubing.xyz/2020/11/17/02-opencv/</id>
    <published>2020-11-17T01:54:47.343Z</published>
    <updated>2020-11-17T03:43:50.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h1><p>一：安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">清华源安装</span><br></pre></td></tr></table></figure><p>二：图像入门</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.imread()，cv.imshow()，cv.imwrite()</span><br></pre></td></tr></table></figure><p>三：视频入门</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv.VideoCapture()，cv.VideoWriter()</span><br><span class="line">涉及到视频的编码，根据储存视频大小的需求定</span><br></pre></td></tr></table></figure><p>四：opencv绘图功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.line()，cv.circle()，cv.rectangle()，cv.ellipse()，cv.putText()等。</span><br></pre></td></tr></table></figure><p>五：鼠标作为画笔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.setMouseCallback()</span><br></pre></td></tr></table></figure><p>六：调色板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.getTrackbarPos，**cv.createTrackbar**等。</span><br></pre></td></tr></table></figure><p>七：图像基本操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问像素值并修改它们 - 访问图像属性 - 设置感兴趣区域(ROI) - 分割和合并图像</span><br></pre></td></tr></table></figure><p>八：图像上的算术运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加法，减法，按位运算，融合</span><br></pre></td></tr></table></figure><p>九：改变颜色空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BGR↔灰色，BGR↔HSV等xxxxxxxxxx 改变颜色空间BGR↔灰色，BGR↔HSV等</span><br><span class="line">cv.cvtColor，cv.inRange</span><br></pre></td></tr></table></figure><p>十：图像的几何变换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">平移、旋转、仿射变换等</span><br><span class="line">OpenCV提供了两个转换函数**cv.warpAffine**和**cv.warpPerspective**，您可以使用它们进行各种转换。**cv.warpAffine**采用2x3转换矩阵，而**cv.warpPerspective**采用3x3转换矩阵作为输入。</span><br></pre></td></tr></table></figure><p>十一：图像阈值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单阈值，自适应阈值和Otsu阈值。</span><br></pre></td></tr></table></figure><p>十二：图像平滑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用各种低通滤镜模糊图像 - 将定制的滤镜应用于图像</span><br></pre></td></tr></table></figure><p>十三：形态学转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">侵蚀，膨胀，开运算，闭运算等</span><br></pre></td></tr></table></figure><p>十四：图像梯度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.Sobel()，cv.Scharr()，cv.Laplacian()等</span><br></pre></td></tr></table></figure><p>十五：边缘检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Canny边缘检测的概念 - OpenCV函数: cv.Canny()</span><br></pre></td></tr></table></figure><p>十六：图像金字塔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学习图像金字塔 - 我们将看到以下功能：cv.pyrUp()，cv.pyrDown()</span><br></pre></td></tr></table></figure><p>十七：轮廓</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①cv.findContours()，cv.drawContours()</span><br><span class="line">②轮廓特征：面积，周长，质心，边界框，轮廓凸包。。。</span><br><span class="line">③轮廓属性：长宽比，范围，坚实度。。。</span><br><span class="line">④更多属性：凸性缺陷，点多边形测试，形状匹配。。。</span><br><span class="line">⑤轮廓分层</span><br></pre></td></tr></table></figure><p>十八：直方图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">①使用OpenCV和Matplotlib函数绘制直方图 - 你将看到以下函数：cv.calcHist()，np.histogram()等。</span><br><span class="line">②直方图均衡</span><br></pre></td></tr></table></figure><p>十九：模板匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">①cv.matchTemplate()，cv.minMaxLoc()</span><br><span class="line">②多尺度模板匹配</span><br></pre></td></tr></table></figure><p>二十：霍夫曼</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">霍夫曼直线，霍夫曼圆</span><br></pre></td></tr></table></figure><p>二十一：特征检测与描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Shi-Tomasi拐角</span><br><span class="line">SIFT尺度不变特征</span><br><span class="line">SURF加速</span><br><span class="line">FAST角点检测</span><br><span class="line">BRIEF二进制鲁棒基本特征</span><br><span class="line">ORB定向快速和旋转简要</span><br><span class="line">特征匹配</span><br></pre></td></tr></table></figure><p>二十二：视频分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">背景分离</span><br><span class="line">运动检测</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;opencv&quot;&gt;&lt;a href=&quot;#opencv&quot; class=&quot;headerlink&quot; title=&quot;opencv&quot;&gt;&lt;/a&gt;opencv&lt;/h1&gt;&lt;p&gt;一：安装&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>01-python数据科学</title>
    <link href="https://yanyubing.xyz/2020/11/16/01-python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    <id>https://yanyubing.xyz/2020/11/16/01-python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/</id>
    <published>2020-11-16T06:53:40.764Z</published>
    <updated>2020-11-17T01:45:58.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python数据科学"><a href="#python数据科学" class="headerlink" title="python数据科学"></a>python数据科学</h1><p>一：python简介</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Anaconda虚拟环境</span><br></pre></td></tr></table></figure><p>二：操作符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数学运算符 + - * /</span><br><span class="line">比较运算符 &gt; &lt; == &gt;= &lt;=</span><br><span class="line">逻辑运算符 &amp; or not</span><br></pre></td></tr></table></figure><p>三：数据类型和变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常量和变量，变量区分大小写</span><br><span class="line">int float str bool</span><br></pre></td></tr></table></figure><p>四：条件表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (condition):</span><br><span class="line">statement1</span><br><span class="line">else:</span><br><span class="line">statement2</span><br></pre></td></tr></table></figure><p>5：循环结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for </span><br><span class="line">while </span><br><span class="line">for循环时可以在&apos;&apos;里面的</span><br></pre></td></tr></table></figure><p>6：方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def printX(x):</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><p>7：数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lists：添加多个对象，list.extend()</span><br><span class="line">Dictionaries</span><br></pre></td></tr></table></figure><p>8：标准库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">内建函数</span><br><span class="line">print(),max()...</span><br><span class="line">内建不变量</span><br><span class="line">False,True,None...</span><br><span class="line">数据类型</span><br><span class="line">int,float,bool,str</span><br><span class="line">文本格式</span><br><span class="line">Csv,excel...</span><br><span class="line">模块</span><br><span class="line">Arithmetic.py</span><br><span class="line">包</span><br><span class="line">Operator/Arithmetic.py</span><br></pre></td></tr></table></figure><p>9：pandas</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://pandas.pydata.org/docs/getting_started/index.html</span><br><span class="line">查看</span><br><span class="line">排序</span><br><span class="line">合并：相同字段合并，外连接，内连接，右连接，左连接</span><br><span class="line">遍历：行遍历apply(lambda x:x[0])，列遍历apply(lambda x:x[0]，axis=1)</span><br></pre></td></tr></table></figure><p>10：数据可视化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matplotlib和Seaborn</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python数据科学&quot;&gt;&lt;a href=&quot;#python数据科学&quot; class=&quot;headerlink&quot; title=&quot;python数据科学&quot;&gt;&lt;/a&gt;python数据科学&lt;/h1&gt;&lt;p&gt;一：python简介&lt;/p&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>解决工业主机远程桌面控制</title>
    <link href="https://yanyubing.xyz/2020/11/16/%E8%A7%A3%E5%86%B3%E5%B7%A5%E4%B8%9A%E4%B8%BB%E6%9C%BA%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6/"/>
    <id>https://yanyubing.xyz/2020/11/16/%E8%A7%A3%E5%86%B3%E5%B7%A5%E4%B8%9A%E4%B8%BB%E6%9C%BA%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6/</id>
    <published>2020-11-16T06:27:56.873Z</published>
    <updated>2020-11-16T06:29:05.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决工业主机桌面远程控制"><a href="#解决工业主机桌面远程控制" class="headerlink" title="解决工业主机桌面远程控制"></a>解决工业主机桌面远程控制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">场景：</span><br><span class="line">工业主机无显示器，无法远程控制和调试</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line">买虚拟现实器，向日葵开机自启</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;解决工业主机桌面远程控制&quot;&gt;&lt;a href=&quot;#解决工业主机桌面远程控制&quot; class=&quot;headerlink&quot; title=&quot;解决工业主机桌面远程控制&quot;&gt;&lt;/a&gt;解决工业主机桌面远程控制&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>神经网络名词解释</title>
    <link href="https://yanyubing.xyz/2020/11/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    <id>https://yanyubing.xyz/2020/11/12/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</id>
    <published>2020-11-12T06:28:15.203Z</published>
    <updated>2020-11-12T07:20:16.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度学习名词解释"><a href="#深度学习名词解释" class="headerlink" title="深度学习名词解释"></a>深度学习名词解释</h1><p>1.线性回归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，运用十分广泛。其表达形式为y = w&apos;x+e，e为误差服从均值为0的正态分布。</span><br><span class="line">①如果目标是预测或者映射，线性回归可以用来对观测数据集的和X的值拟合出一个预测模型。当完成这样一个模型以后，对于一个新增的X值，在没有给定与它相配对的y的情况下，可以用这个拟合过的模型预测出一个y值。</span><br><span class="line">②给定一个变量y和一些变量X1,...,Xp，这些变量有可能与y相关，线性回归分析可以用来量化y与Xj之间相关性的强度，评估出与y不相关的Xj，并识别出哪些Xj的子集包含了关于y的冗余信息。</span><br><span class="line"></span><br><span class="line">一般采用均方差损失</span><br><span class="line">pytorch实现：</span><br><span class="line">nn.Linear()</span><br><span class="line">criterion = nn.MSELoss()</span><br></pre></td></tr></table></figure><p>2.逻辑回归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logistic回归是一种广义线性回归（generalized linear model），因此与多重线性回归分析有很多相同之处。它们的模型形式基本上相同，都具有 w‘x+b，其中w和b是待求参数，其区别在于他们的因变量不同，多重线性回归直接将w‘x+b作为因变量，即y =w‘x+b，而logistic回归则通过函数L将w‘x+b对应一个隐状态p，p =L(w‘x+b),然后根据p 与1-p的大小决定因变量的值。如果L是logistic函数，就是logistic回归，如果L是多项式函数就是多项式回归。 [1]</span><br><span class="line"></span><br><span class="line">一般采用交叉熵损失</span><br><span class="line">model = nn.Linear(input_size, num_classes)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure><p>3.梯度下降</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是一个一阶最优化算法, 要使用梯度下降法找到一个函数的局部极小值，必须向函数上当前点对应梯度（或者是近似梯度）的反方向的规定步长距离点进行迭代搜索。</span><br></pre></td></tr></table></figure><p>4.前馈神经网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多层感知机</span><br><span class="line">①每个线性单元完成之后加入非线性激活函数，可以更好的拟合</span><br></pre></td></tr></table></figure><p>5.正则化</p><p>6.损失函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深度学习名词解释&quot;&gt;&lt;a href=&quot;#深度学习名词解释&quot; class=&quot;headerlink&quot; title=&quot;深度学习名词解释&quot;&gt;&lt;/a&gt;深度学习名词解释&lt;/h1&gt;&lt;p&gt;1.线性回归&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>记一次crontab不成功的例子</title>
    <link href="https://yanyubing.xyz/2020/11/07/%E8%AE%B0%E4%B8%80%E6%AC%A1crontab%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E4%BE%8B%E5%AD%90/"/>
    <id>https://yanyubing.xyz/2020/11/07/%E8%AE%B0%E4%B8%80%E6%AC%A1crontab%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E4%BE%8B%E5%AD%90/</id>
    <published>2020-11-07T01:53:03.829Z</published>
    <updated>2020-11-07T01:58:05.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="crontab-不成功的解决方案"><a href="#crontab-不成功的解决方案" class="headerlink" title="crontab 不成功的解决方案"></a>crontab 不成功的解决方案</h1><p>系统：Ubuntu18.04lts</p><p>crontab脚本本地执行没问题，放在定时任务失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查看日志：cat /var/log/cron.log</span><br><span class="line">(CRON) info (No MTA installed, discarding output)</span><br><span class="line"></span><br><span class="line">安装 sudo apt-get install postfix</span><br><span class="line"></span><br><span class="line">定时任务</span><br><span class="line">55 9 * * * sh /home/crontab.sh &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">日志无问题，但是还是执行不成功，取消2&gt;&amp;1</span><br><span class="line">查看日志： cat /var/spool/mail/root</span><br><span class="line">Non-ASCII character &apos;\xe7&apos; in file moveFile.py on line 1</span><br><span class="line"></span><br><span class="line">发现python脚本开头注释问题，解决！</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：Ubuntu系统很容易出现这些类似的问题，注意查看日志！</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;crontab-不成功的解决方案&quot;&gt;&lt;a href=&quot;#crontab-不成功的解决方案&quot; class=&quot;headerlink&quot; title=&quot;crontab 不成功的解决方案&quot;&gt;&lt;/a&gt;crontab 不成功的解决方案&lt;/h1&gt;&lt;p&gt;系统：Ubuntu18.04
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>获取rtsp流断开连接的情况</title>
    <link href="https://yanyubing.xyz/2020/11/06/%E8%8E%B7%E5%8F%96rtsp%E6%B5%81%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%83%85%E5%86%B5/"/>
    <id>https://yanyubing.xyz/2020/11/06/%E8%8E%B7%E5%8F%96rtsp%E6%B5%81%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%83%85%E5%86%B5/</id>
    <published>2020-11-06T01:18:20.486Z</published>
    <updated>2020-11-06T03:04:30.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rtsp流断开连接，但是cap-read-返回一直是最后一帧的情况，需要解决的问题是程序不用动，断开连接之后流有了继续可以读到新的流"><a href="#rtsp流断开连接，但是cap-read-返回一直是最后一帧的情况，需要解决的问题是程序不用动，断开连接之后流有了继续可以读到新的流" class="headerlink" title="rtsp流断开连接，但是cap.read()返回一直是最后一帧的情况，需要解决的问题是程序不用动，断开连接之后流有了继续可以读到新的流"></a>rtsp流断开连接，但是cap.read()返回一直是最后一帧的情况，需要解决的问题是程序不用动，断开连接之后流有了继续可以读到新的流</h2><p>1.结合场景的处理方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于即时性没有那么强，计算资源也有限，如果计算资源足够，可以比较累计相同连续帧；</span><br><span class="line">每天晚上三点和晚上一点的图片作为比较，如果相同，则表示流断掉；如果不相同，则未断；断掉一次之后记录下来，后续可以查看日志。</span><br><span class="line"></span><br><span class="line">暂时无法在代码中重新读取新的流，只能记录查看</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;rtsp流断开连接，但是cap-read-返回一直是最后一帧的情况，需要解决的问题是程序不用动，断开连接之后流有了继续可以读到新的流&quot;&gt;&lt;a href=&quot;#rtsp流断开连接，但是cap-read-返回一直是最后一帧的情况，需要解决的问题是程序不用动，断开连接之后
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>pyTorch深度学习—book</title>
    <link href="https://yanyubing.xyz/2020/11/05/pyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E2%80%94book/"/>
    <id>https://yanyubing.xyz/2020/11/05/pyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E2%80%94book/</id>
    <published>2020-11-05T07:58:00.551Z</published>
    <updated>2020-11-05T07:58:00.551Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>提取海康威视摄像头水印时间</title>
    <link href="https://yanyubing.xyz/2020/11/03/%E6%8F%90%E5%8F%96%E6%B5%B7%E5%BA%B7%E5%A8%81%E8%A7%86%E6%91%84%E5%83%8F%E5%A4%B4%E6%B0%B4%E5%8D%B0%E6%97%B6%E9%97%B4/"/>
    <id>https://yanyubing.xyz/2020/11/03/%E6%8F%90%E5%8F%96%E6%B5%B7%E5%BA%B7%E5%A8%81%E8%A7%86%E6%91%84%E5%83%8F%E5%A4%B4%E6%B0%B4%E5%8D%B0%E6%97%B6%E9%97%B4/</id>
    <published>2020-11-03T08:44:17.074Z</published>
    <updated>2020-11-04T02:53:37.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="海康威视摄像头水印时间的获取"><a href="#海康威视摄像头水印时间的获取" class="headerlink" title="海康威视摄像头水印时间的获取"></a>海康威视摄像头水印时间的获取</h1><p>1.为什么要提取时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获取每一帧图片对应的事件发生时间，并且记录</span><br></pre></td></tr></table></figure><p>2.为什么不从流中获取时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①业务场景为视频已经保存，以时间搓命名</span><br><span class="line">②获取文件名之后记帧来获取时间的问题有：</span><br><span class="line">时间可能未同步，需要额外文件名的依赖</span><br></pre></td></tr></table></figure><p>3.怎么操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方案一：模板匹配1，需要准备模板和一个ROI区域对比，获取模板的x坐标，排序，得到时间</span><br><span class="line">方案二：模板匹配2，得到多个ROI区域，每个区域和准备的模板对比</span><br><span class="line">方案三：ocr识别</span><br></pre></td></tr></table></figure><p>4：方案一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#前提：设置OSD颜色，不要为黑白自动，避免模板不单一</span><br><span class="line"># 方法一：模板匹配</span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 传入帧的图片，获取时间</span><br><span class="line">def getTime(image):</span><br><span class="line">    x_locations = []</span><br><span class="line">    ROI = image[21:34, 33:230]</span><br><span class="line">    ROI_gray = cv2.cvtColor(ROI, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    for i in range(10):</span><br><span class="line">        image_path = str(i) + &apos;.jpg&apos;</span><br><span class="line">        template = cv2.imread(image_path, 0)</span><br><span class="line">        w, h = template.shape[::-1]</span><br><span class="line">        res = cv2.matchTemplate(ROI_gray, template, cv2.TM_CCOEFF_NORMED)</span><br><span class="line">        threshold = 0.9</span><br><span class="line">        loc = np.where(res &gt;= threshold)</span><br><span class="line">        for pt in zip(*loc[::-1]):</span><br><span class="line">            x_location = [i, pt[0]]</span><br><span class="line">            x_locations.append(x_location)</span><br><span class="line">            pt0 = (pt[0] + 33, pt[1] + 21)</span><br><span class="line">            pt1 = (pt[0] + 33 + w, pt[1] + 21 + h)</span><br><span class="line">            cv2.rectangle(image, pt0, pt1, (0, 0, 255), 1)</span><br><span class="line">        cv2.imshow(&apos;res.png&apos;, image)</span><br><span class="line">    x_locations.sort(key=lambda x: int(x[1]))</span><br><span class="line">    print(x_locations)</span><br><span class="line">    str_time = &apos;&apos;</span><br><span class="line">    for i in x_locations:</span><br><span class="line">        str_time += str(i[0])</span><br><span class="line">    print(str_time)</span><br><span class="line">    return str_time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    videopath = &apos;video/20201104022617.mp4&apos;</span><br><span class="line">    cap = cv2.VideoCapture(videopath)</span><br><span class="line">    success, image = cap.read()</span><br><span class="line">    while success:</span><br><span class="line">        getTime(image)</span><br><span class="line">        success, image = cap.read()</span><br></pre></td></tr></table></figure><p>5.3种方案的对比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模板匹配对于这种固定性的图形处理最优(准确率和速度上都是)；前提是对于模板的处理需要精细化。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;海康威视摄像头水印时间的获取&quot;&gt;&lt;a href=&quot;#海康威视摄像头水印时间的获取&quot; class=&quot;headerlink&quot; title=&quot;海康威视摄像头水印时间的获取&quot;&gt;&lt;/a&gt;海康威视摄像头水印时间的获取&lt;/h1&gt;&lt;p&gt;1.为什么要提取时间&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hog+SVM</title>
    <link href="https://yanyubing.xyz/2020/11/03/Hog+SVM/"/>
    <id>https://yanyubing.xyz/2020/11/03/Hog+SVM/</id>
    <published>2020-11-03T07:07:20.731Z</published>
    <updated>2020-11-03T07:08:27.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像金字塔-svm分类器"><a href="#图像金字塔-svm分类器" class="headerlink" title="图像金字塔+svm分类器"></a>图像金字塔+svm分类器</h1><p>1.图像金字塔</p><p>2.每一层进行滑动窗口</p><p>3.svm检测是否包含</p><p>4.nms非极大值抑制得到最优的box</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图像金字塔-svm分类器&quot;&gt;&lt;a href=&quot;#图像金字塔-svm分类器&quot; class=&quot;headerlink&quot; title=&quot;图像金字塔+svm分类器&quot;&gt;&lt;/a&gt;图像金字塔+svm分类器&lt;/h1&gt;&lt;p&gt;1.图像金字塔&lt;/p&gt;
&lt;p&gt;2.每一层进行滑动窗口&lt;/p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>检测图片中的条形码</title>
    <link href="https://yanyubing.xyz/2020/11/03/%E6%A3%80%E6%B5%8B%E5%9B%BE%E7%89%87%E4%B8%AD%E7%9A%84%E6%9D%A1%E5%BD%A2%E7%A0%81/"/>
    <id>https://yanyubing.xyz/2020/11/03/%E6%A3%80%E6%B5%8B%E5%9B%BE%E7%89%87%E4%B8%AD%E7%9A%84%E6%9D%A1%E5%BD%A2%E7%A0%81/</id>
    <published>2020-11-03T06:43:44.639Z</published>
    <updated>2020-11-03T06:45:03.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="检测图片中的条形码"><a href="#检测图片中的条形码" class="headerlink" title="检测图片中的条形码"></a>检测图片中的条形码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 条形码检测</span><br><span class="line">import numpy as np</span><br><span class="line">import argparse</span><br><span class="line">import imutils</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">image = cv2.imread(&apos;CodeBay.jpg&apos;)</span><br><span class="line">gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">ddepth = cv2.CV_32F</span><br><span class="line">gradX = cv2.Sobel(gray, ddepth=ddepth, dx=1, dy=0, ksize=-1)</span><br><span class="line">gradY = cv2.Sobel(gray, ddepth=ddepth, dx=0, dy=1, ksize=-1)</span><br><span class="line"># x渐变减去y方向渐变，得到高水平梯度和低垂直梯度</span><br><span class="line">gradient = cv2.subtract(gradX, gradY)</span><br><span class="line">gradient = cv2.convertScaleAbs(gradient)</span><br><span class="line"># 去噪</span><br><span class="line">blurred = cv2.blur(gradient, (9, 9))</span><br><span class="line">(_, thresh) = cv2.threshold(blurred, 225, 255, cv2.THRESH_BINARY)</span><br><span class="line"># 去噪2</span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (21, 7))</span><br><span class="line">closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)</span><br><span class="line"></span><br><span class="line"># 消除小斑点</span><br><span class="line">closed = cv2.erode(closed, None, iterations=4)</span><br><span class="line">closed = cv2.dilate(closed, None, iterations=4)</span><br><span class="line"></span><br><span class="line">cnts = cv2.findContours(closed.copy(), cv2.RETR_EXTERNAL,</span><br><span class="line">cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">cnts = imutils.grab_contours(cnts)</span><br><span class="line">c = sorted(cnts, key = cv2.contourArea, reverse = True)[0]</span><br><span class="line"># compute the rotated bounding box of the largest contour</span><br><span class="line">rect = cv2.minAreaRect(c)</span><br><span class="line">box = cv2.boxPoints(rect)</span><br><span class="line">box = np.int0(box)</span><br><span class="line"># draw a bounding box arounded the detected barcode and display the</span><br><span class="line"># image</span><br><span class="line">cv2.drawContours(image, [box], -1, (0, 255, 0), 3)</span><br><span class="line">cv2.imshow(&quot;Image&quot;, image)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">充分了解对象的特征，使用形态学方式提取出来</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;检测图片中的条形码&quot;&gt;&lt;a href=&quot;#检测图片中的条形码&quot; class=&quot;headerlink&quot; title=&quot;检测图片中的条形码&quot;&gt;&lt;/a&gt;检测图片中的条形码&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用flask来进行文件传输</title>
    <link href="https://yanyubing.xyz/2020/11/03/%E4%BD%BF%E7%94%A8flask%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    <id>https://yanyubing.xyz/2020/11/03/%E4%BD%BF%E7%94%A8flask%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</id>
    <published>2020-11-03T06:18:22.927Z</published>
    <updated>2020-11-03T06:20:22.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用flask来进行文件的传输"><a href="#使用flask来进行文件的传输" class="headerlink" title="使用flask来进行文件的传输"></a>使用flask来进行文件的传输</h1><p>1.服务器端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#!/user/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># 作者：yan</span><br><span class="line"># 创建：2020-10-27</span><br><span class="line"># 更新：2020-10-27</span><br><span class="line"># 用意：服务器接收文件端</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">from flask import Blueprint, request, app, Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def hello_world():</span><br><span class="line">    return &apos;Hello World!&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;/upload_files&quot;, methods=(&quot;POST&quot;,))</span><br><span class="line">def upload_files():</span><br><span class="line">    if request.method == &quot;POST&quot;:</span><br><span class="line">        files = request.files</span><br><span class="line">        for file in files.values():</span><br><span class="line">            # 保存文件</span><br><span class="line">            file.save(file.filename)</span><br><span class="line">        return json.dumps(&#123;&quot;msg&quot;: &quot;Save files successfully!&quot;, &quot;code&quot;: 0&#125;, ensure_ascii=False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(debug=True,host=&apos;0.0.0.0&apos;,port=8080)</span><br></pre></td></tr></table></figure><p>2.客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#!/user/bin/env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># 作者：yan</span><br><span class="line"># 创建：2020-10-27</span><br><span class="line"># 更新：2020-10-27</span><br><span class="line"># 用意：触发器，文件传输客户端，每一个小时传输一次(后面替换为每天晚上10点传输)</span><br><span class="line"></span><br><span class="line">import datetime</span><br><span class="line">import os, requests</span><br><span class="line"></span><br><span class="line"># 发送请求</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def sendPost():</span><br><span class="line">    # 台式机地址</span><br><span class="line">    url = &quot;http://192.168.10.102:8080/upload_files&quot;</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        i = datetime.datetime.now().strftime(&apos;%Y%m%d%H%M%S&apos;)</span><br><span class="line">        if int(i) % 100 == 0:</span><br><span class="line">            # 睡1s，避免1s内多次操作</span><br><span class="line">            sleep(1)</span><br><span class="line">            print(i)</span><br><span class="line">        #每半个小时执行一次</span><br><span class="line">        if int(i) % 10000 == 0 :</span><br><span class="line">            # 睡1s，避免1s内多次操作</span><br><span class="line">            sleep(1)</span><br><span class="line">            files = []</span><br><span class="line">            post_files = [file for file in os.listdir(&quot;../motionDetection/&quot;) if file.endswith(&apos;avi&apos;)][:-1]</span><br><span class="line">            if len(post_files) == 0:</span><br><span class="line">                sleep(5)</span><br><span class="line">            else:</span><br><span class="line">                for post_file in post_files:</span><br><span class="line">                    files.append([post_file, open(&quot;../motionDetection/&quot; + post_file, &quot;rb&quot;)])</span><br><span class="line">                r = requests.post(url, files=files)</span><br><span class="line">                print(r.status_code)</span><br><span class="line">            # 使变量不可用，避免占用文件</span><br><span class="line">            del files</span><br><span class="line">            for post_file in post_files:</span><br><span class="line">                os.remove(&quot;../motionDetection/&quot; + post_file)</span><br><span class="line">                print(&apos;移除完成&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    sendPost()</span><br></pre></td></tr></table></figure><p>3.注意端口和防火墙</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用flask来进行文件的传输&quot;&gt;&lt;a href=&quot;#使用flask来进行文件的传输&quot; class=&quot;headerlink&quot; title=&quot;使用flask来进行文件的传输&quot;&gt;&lt;/a&gt;使用flask来进行文件的传输&lt;/h1&gt;&lt;p&gt;1.服务器端&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
